<!-- HTML header for doxygen 1.8.4-->
<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="generator" content="Doxygen 1.8.6"/>
<title>PVRVk: pvrvk::impl::SecondaryCommandBuffer_ Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="IMGdoxygen.css" rel="stylesheet" type="text/css"/>
<link rel="shortcut icon" href="http://www.imgtec.com/images/img.ico">
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
  <div class="headercontent">
    <div class="PVRlogo">
      <a href="http://www.powervrinsider.com" target="_blank"><img src="PVRlogo.png" width="40%" height="40%"  border="none" /></a>
    </div>
    <a class="SiteTitle"><span id="projectname">PVRVk</span> Documentation</a>
   <tbody>
  </div>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.6 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="inherits.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Macros</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(10)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacepvrvk.html">pvrvk</a></li><li class="navelem"><a class="el" href="namespacepvrvk_1_1impl.html">impl</a></li><li class="navelem"><a class="el" href="classpvrvk_1_1impl_1_1_secondary_command_buffer__.html">SecondaryCommandBuffer_</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> &#124;
<a href="classpvrvk_1_1impl_1_1_secondary_command_buffer__-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">pvrvk::impl::SecondaryCommandBuffer_ Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Contains all the commands and states that need to be submitted to the gpu, including pipeline, texture, and samplers. Virtually everything that needs to happen on the GPU is submitted to the CommandBuffer.  
 <a href="classpvrvk_1_1impl_1_1_secondary_command_buffer__.html#details">More...</a></p>
<div class="dynheader">
Inheritance diagram for pvrvk::impl::SecondaryCommandBuffer_:</div>
<div class="dyncontent">
<div class="center"><img src="classpvrvk_1_1impl_1_1_secondary_command_buffer____inherit__graph.png" border="0" usemap="#pvrvk_1_1impl_1_1_secondary_command_buffer___inherit__map" alt="Inheritance graph"/></div>
<map name="pvrvk_1_1impl_1_1_secondary_command_buffer___inherit__map" id="pvrvk_1_1impl_1_1_secondary_command_buffer___inherit__map">
<area shape="rect" id="node2" href="classpvrvk_1_1impl_1_1_command_buffer_base__.html" title="Contains all the commands and states that need to be recorded for later submission to the gpu includi..." alt="" coords="19,6,208,47"/></map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a4f76288bd10eeb9fd943676d70b96060"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvrvk_1_1impl_1_1_command_buffer_base__.html#a4f76288bd10eeb9fd943676d70b96060">begin</a> (const VkCommandBufferUsageFlags flags=VkCommandBufferUsageFlags(0))</td></tr>
<tr class="memdesc:a4f76288bd10eeb9fd943676d70b96060"><td class="mdescLeft">&#160;</td><td class="mdescRight">Call this function before beginning to record commands. <a href="#a4f76288bd10eeb9fd943676d70b96060">More...</a><br/></td></tr>
<tr class="separator:a4f76288bd10eeb9fd943676d70b96060"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a29de9fd9b732a83d33ab70feb26abc94"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvrvk_1_1impl_1_1_secondary_command_buffer__.html#a29de9fd9b732a83d33ab70feb26abc94">begin</a> (const <a class="el" href="namespacepvrvk.html#a55f833c5feaaa65f3aaed3a08a7a55e6">RenderPass</a> &amp;renderpass, uint32_t subpass=0, const VkCommandBufferUsageFlags flags=VkCommandBufferUsageFlags::e_RENDER_PASS_CONTINUE_BIT)</td></tr>
<tr class="memdesc:a29de9fd9b732a83d33ab70feb26abc94"><td class="mdescLeft">&#160;</td><td class="mdescRight">Call this function before beginning to record commands. If the Framebuffer object is known, prefer the Framebuffer overload as it may offer better performance. <a href="#a29de9fd9b732a83d33ab70feb26abc94">More...</a><br/></td></tr>
<tr class="separator:a29de9fd9b732a83d33ab70feb26abc94"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c9a9895e19f73ff06990c2faf29c21c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvrvk_1_1impl_1_1_secondary_command_buffer__.html#a5c9a9895e19f73ff06990c2faf29c21c">begin</a> (const <a class="el" href="namespacepvrvk.html#a7639515cddb57ed4370a5ce02287988a">Framebuffer</a> &amp;framebuffer, uint32_t subpass=0, const VkCommandBufferUsageFlags flags=VkCommandBufferUsageFlags::e_RENDER_PASS_CONTINUE_BIT)</td></tr>
<tr class="memdesc:a5c9a9895e19f73ff06990c2faf29c21c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Call this function before beginning to record commands. <a href="#a5c9a9895e19f73ff06990c2faf29c21c">More...</a><br/></td></tr>
<tr class="separator:a5c9a9895e19f73ff06990c2faf29c21c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa2790065ae29813b0752b76d0485d210"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvrvk_1_1impl_1_1_command_buffer_base__.html#aa2790065ae29813b0752b76d0485d210">bindDescriptorSet</a> (VkPipelineBindPoint bindingPoint, const <a class="el" href="namespacepvrvk.html#a34bb21497524a13e145b1398450989d0">PipelineLayout</a> &amp;pipelineLayout, uint32_t firstSet, const <a class="el" href="namespacepvrvk.html#afaa5d3390eb48fd21197430158a7d5ac">DescriptorSet</a> set, const uint32_t *dynamicOffsets=nullptr, uint32_t numDynamicOffsets=0)</td></tr>
<tr class="memdesc:aa2790065ae29813b0752b76d0485d210"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bind descriptorset <a href="#aa2790065ae29813b0752b76d0485d210">More...</a><br/></td></tr>
<tr class="separator:aa2790065ae29813b0752b76d0485d210"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2fa18c915c858eae6c62666e63c8d023"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvrvk_1_1impl_1_1_command_buffer_base__.html#a2fa18c915c858eae6c62666e63c8d023">bindDescriptorSets</a> (VkPipelineBindPoint bindingPoint, const <a class="el" href="namespacepvrvk.html#a34bb21497524a13e145b1398450989d0">PipelineLayout</a> &amp;pipelineLayout, uint32_t firstSet, const <a class="el" href="namespacepvrvk.html#afaa5d3390eb48fd21197430158a7d5ac">DescriptorSet</a> *sets, uint32_t numDescriptorSets, const uint32_t *dynamicOffsets=nullptr, uint32_t numDynamicOffsets=0)</td></tr>
<tr class="memdesc:a2fa18c915c858eae6c62666e63c8d023"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bind descriptorsets <a href="#a2fa18c915c858eae6c62666e63c8d023">More...</a><br/></td></tr>
<tr class="separator:a2fa18c915c858eae6c62666e63c8d023"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a59e59dde44ad5822f7dcd1008250a070"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvrvk_1_1impl_1_1_command_buffer_base__.html#a59e59dde44ad5822f7dcd1008250a070">bindIndexBuffer</a> (const <a class="el" href="namespacepvrvk.html#a2a117db0aab25382d050908b2bfa4c8b">Buffer</a> &amp;buffer, uint32_t offset, VkIndexType indexType)</td></tr>
<tr class="memdesc:a59e59dde44ad5822f7dcd1008250a070"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bind index bufer <a href="#a59e59dde44ad5822f7dcd1008250a070">More...</a><br/></td></tr>
<tr class="separator:a59e59dde44ad5822f7dcd1008250a070"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adfc394932317683fb0582841423527b2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvrvk_1_1impl_1_1_command_buffer_base__.html#adfc394932317683fb0582841423527b2">bindPipeline</a> (const <a class="el" href="namespacepvrvk.html#aa2443b681960df638797cf93bbf33fb7">GraphicsPipeline</a> &amp;pipeline)</td></tr>
<tr class="memdesc:adfc394932317683fb0582841423527b2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bind a graphics pipeline. <a href="#adfc394932317683fb0582841423527b2">More...</a><br/></td></tr>
<tr class="separator:adfc394932317683fb0582841423527b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a79d2f3d38f2aad3fa3ba4b7b793d1421"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvrvk_1_1impl_1_1_command_buffer_base__.html#a79d2f3d38f2aad3fa3ba4b7b793d1421">bindPipeline</a> (<a class="el" href="namespacepvrvk.html#a946a7145c9e18b9a797fa714ce677f32">ComputePipeline</a> &amp;pipeline)</td></tr>
<tr class="memdesc:a79d2f3d38f2aad3fa3ba4b7b793d1421"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bind a compute pipeline <a href="#a79d2f3d38f2aad3fa3ba4b7b793d1421">More...</a><br/></td></tr>
<tr class="separator:a79d2f3d38f2aad3fa3ba4b7b793d1421"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2382fc789d3e96d50693f9e5483ff0b0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvrvk_1_1impl_1_1_command_buffer_base__.html#a2382fc789d3e96d50693f9e5483ff0b0">bindVertexBuffer</a> (const <a class="el" href="namespacepvrvk.html#a2a117db0aab25382d050908b2bfa4c8b">Buffer</a> &amp;buffer, uint32_t offset, uint16_t bindingIndex)</td></tr>
<tr class="memdesc:a2382fc789d3e96d50693f9e5483ff0b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bind vertex buffer <a href="#a2382fc789d3e96d50693f9e5483ff0b0">More...</a><br/></td></tr>
<tr class="separator:a2382fc789d3e96d50693f9e5483ff0b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2853f758e9e70e100e3140405fc8e03c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvrvk_1_1impl_1_1_command_buffer_base__.html#a2853f758e9e70e100e3140405fc8e03c">bindVertexBuffer</a> (<a class="el" href="namespacepvrvk.html#a2a117db0aab25382d050908b2bfa4c8b">Buffer</a> const *buffers, uint32_t *offsets, uint16_t numBuffers, uint16_t startBinding, uint16_t numBindings)</td></tr>
<tr class="memdesc:a2853f758e9e70e100e3140405fc8e03c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bind vertex buffer <a href="#a2853f758e9e70e100e3140405fc8e03c">More...</a><br/></td></tr>
<tr class="separator:a2853f758e9e70e100e3140405fc8e03c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af6acf0e46f17c2b81f59626333956913"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvrvk_1_1impl_1_1_command_buffer_base__.html#af6acf0e46f17c2b81f59626333956913">blitImage</a> (const <a class="el" href="namespacepvrvk.html#a0dde8112e297d1089979fbdbdcbbe0f4">Image</a> &amp;srcImage, <a class="el" href="namespacepvrvk.html#a0dde8112e297d1089979fbdbdcbbe0f4">Image</a> &amp;dstImage, const <a class="el" href="structpvrvk_1_1_image_blit_range.html">ImageBlitRange</a> *regions, uint32_t numRegions, VkFilter filter, VkImageLayout srcLayout, VkImageLayout dstLayout)</td></tr>
<tr class="memdesc:af6acf0e46f17c2b81f59626333956913"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies regions of a src image into a dst image, potentially also performing format conversions, aritrary scaling and filtering. <a href="#af6acf0e46f17c2b81f59626333956913">More...</a><br/></td></tr>
<tr class="separator:af6acf0e46f17c2b81f59626333956913"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a26d8498fee836c63989072eb483d8938"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvrvk_1_1impl_1_1_command_buffer_base__.html#a26d8498fee836c63989072eb483d8938">clearAttachment</a> (const <a class="el" href="structpvrvk_1_1_clear_attachment.html">ClearAttachment</a> &amp;clearAttachment, const <a class="el" href="structpvrvk_1_1_clear_rect.html">ClearRect</a> &amp;clearRectangle)</td></tr>
<tr class="memdesc:a26d8498fee836c63989072eb483d8938"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clears a particular attachment using a provided region whilst inside of a renderpass. <a href="#a26d8498fee836c63989072eb483d8938">More...</a><br/></td></tr>
<tr class="separator:a26d8498fee836c63989072eb483d8938"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac681c14ddfb7b443d318e695633571b5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvrvk_1_1impl_1_1_command_buffer_base__.html#ac681c14ddfb7b443d318e695633571b5">clearAttachments</a> (const uint32_t numAttachments, const <a class="el" href="structpvrvk_1_1_clear_attachment.html">ClearAttachment</a> *clearAttachments, uint32_t numRectangles, const <a class="el" href="structpvrvk_1_1_clear_rect.html">ClearRect</a> *clearRectangles)</td></tr>
<tr class="memdesc:ac681c14ddfb7b443d318e695633571b5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clear a set of attacments using a number of regions for each selected attachment to clear whilst inside a renderpass. <a href="#ac681c14ddfb7b443d318e695633571b5">More...</a><br/></td></tr>
<tr class="separator:ac681c14ddfb7b443d318e695633571b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a908a20001250afc90bb6c4dc0f3343fb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvrvk_1_1impl_1_1_command_buffer_base__.html#a908a20001250afc90bb6c4dc0f3343fb">clearColorImage</a> (<a class="el" href="namespacepvrvk.html#ad4da214c95fffe4edccb14eb2c270f07">ImageView</a> &amp;image, const <a class="el" href="structpvrvk_1_1_clear_color_value.html">ClearColorValue</a> &amp;clearColor, VkImageLayout currentLayout, const uint32_t baseMipLevel=0, const uint32_t numLevels=1, const uint32_t baseArrayLayer=0, const uint32_t numLayers=1)</td></tr>
<tr class="memdesc:a908a20001250afc90bb6c4dc0f3343fb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clears a color image outside of a renderpass instance. <a href="#a908a20001250afc90bb6c4dc0f3343fb">More...</a><br/></td></tr>
<tr class="separator:a908a20001250afc90bb6c4dc0f3343fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a702388020e9ee489d3fad1006b087098"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvrvk_1_1impl_1_1_command_buffer_base__.html#a702388020e9ee489d3fad1006b087098">clearColorImage</a> (<a class="el" href="namespacepvrvk.html#ad4da214c95fffe4edccb14eb2c270f07">ImageView</a> &amp;image, const <a class="el" href="structpvrvk_1_1_clear_color_value.html">ClearColorValue</a> &amp;clearColor, VkImageLayout currentLayout, const uint32_t *baseMipLevels, const uint32_t *numLevels, const uint32_t *baseArrayLayers, const uint32_t *numLayers, uint32_t numRanges)</td></tr>
<tr class="memdesc:a702388020e9ee489d3fad1006b087098"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clears a color image outside of a renderpass instance using a number of ranges. <a href="#a702388020e9ee489d3fad1006b087098">More...</a><br/></td></tr>
<tr class="separator:a702388020e9ee489d3fad1006b087098"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e25c0e9893a227a4d456b7a5ccba992"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvrvk_1_1impl_1_1_command_buffer_base__.html#a5e25c0e9893a227a4d456b7a5ccba992">clearDepthImage</a> (<a class="el" href="namespacepvrvk.html#a0dde8112e297d1089979fbdbdcbbe0f4">Image</a> &amp;image, float clearDepth, const uint32_t baseMipLevel, const uint32_t numLevels, const uint32_t baseArrayLayer, const uint32_t numLayers, VkImageLayout layout)</td></tr>
<tr class="memdesc:a5e25c0e9893a227a4d456b7a5ccba992"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clear depth image outside of a renderpass instance. <a href="#a5e25c0e9893a227a4d456b7a5ccba992">More...</a><br/></td></tr>
<tr class="separator:a5e25c0e9893a227a4d456b7a5ccba992"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af82e7d8c6572469f44d2a242571c2144"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvrvk_1_1impl_1_1_command_buffer_base__.html#af82e7d8c6572469f44d2a242571c2144">clearDepthImage</a> (<a class="el" href="namespacepvrvk.html#a0dde8112e297d1089979fbdbdcbbe0f4">Image</a> &amp;image, float clearDepth, const uint32_t *baseMipLevels, const uint32_t *numLevels, const uint32_t *baseArrayLayers, const uint32_t *numLayers, uint32_t numRanges, VkImageLayout layout)</td></tr>
<tr class="memdesc:af82e7d8c6572469f44d2a242571c2144"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clears the depth image outside of a renderpass instance using a number of ranges. <a href="#af82e7d8c6572469f44d2a242571c2144">More...</a><br/></td></tr>
<tr class="separator:af82e7d8c6572469f44d2a242571c2144"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c4b67263fa0035d6793d6f5fbe85f47"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvrvk_1_1impl_1_1_command_buffer_base__.html#a4c4b67263fa0035d6793d6f5fbe85f47">clearDepthStencilImage</a> (<a class="el" href="namespacepvrvk.html#a0dde8112e297d1089979fbdbdcbbe0f4">Image</a> &amp;image, float clearDepth, uint32_t clearStencil, const uint32_t baseMipLevel, const uint32_t numLevels, const uint32_t baseArrayLayer, const uint32_t numLayers, VkImageLayout layout)</td></tr>
<tr class="memdesc:a4c4b67263fa0035d6793d6f5fbe85f47"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clear depth stencil image outside of a renderpass instance. <a href="#a4c4b67263fa0035d6793d6f5fbe85f47">More...</a><br/></td></tr>
<tr class="separator:a4c4b67263fa0035d6793d6f5fbe85f47"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7333520583cd3639bbe1fb0fdcbd9320"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvrvk_1_1impl_1_1_command_buffer_base__.html#a7333520583cd3639bbe1fb0fdcbd9320">clearDepthStencilImage</a> (<a class="el" href="namespacepvrvk.html#a0dde8112e297d1089979fbdbdcbbe0f4">Image</a> &amp;image, float clearDepth, uint32_t clearStencil, const uint32_t *baseMipLevels, const uint32_t *numLevels, const uint32_t *baseArrayLayers, const uint32_t *numLayers, uint32_t numRanges, VkImageLayout layout)</td></tr>
<tr class="memdesc:a7333520583cd3639bbe1fb0fdcbd9320"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clear depth stencil image outside of a renderpass instance using a number of ranges. <a href="#a7333520583cd3639bbe1fb0fdcbd9320">More...</a><br/></td></tr>
<tr class="separator:a7333520583cd3639bbe1fb0fdcbd9320"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8938944ae6d1febc5e54c4db514963d4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvrvk_1_1impl_1_1_command_buffer_base__.html#a8938944ae6d1febc5e54c4db514963d4">clearStencilImage</a> (<a class="el" href="namespacepvrvk.html#a0dde8112e297d1089979fbdbdcbbe0f4">Image</a> &amp;image, uint32_t clearStencil, const uint32_t baseMipLevel, const uint32_t numLevels, const uint32_t baseArrayLayer, const uint32_t numLayers, VkImageLayout layout)</td></tr>
<tr class="memdesc:a8938944ae6d1febc5e54c4db514963d4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clears a stencil image outside of a renderpass instance. <a href="#a8938944ae6d1febc5e54c4db514963d4">More...</a><br/></td></tr>
<tr class="separator:a8938944ae6d1febc5e54c4db514963d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a477cecb59ce2b13ce1e82340a434057e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvrvk_1_1impl_1_1_command_buffer_base__.html#a477cecb59ce2b13ce1e82340a434057e">clearStencilImage</a> (<a class="el" href="namespacepvrvk.html#a0dde8112e297d1089979fbdbdcbbe0f4">Image</a> &amp;image, uint32_t clearStencil, const uint32_t *baseMipLevels, const uint32_t *numLevels, const uint32_t *baseArrayLayers, const uint32_t *numLayers, uint32_t numRanges, VkImageLayout layout)</td></tr>
<tr class="memdesc:a477cecb59ce2b13ce1e82340a434057e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clear stencil image outside of a renderpass instance using a number of ranges. <a href="#a477cecb59ce2b13ce1e82340a434057e">More...</a><br/></td></tr>
<tr class="separator:a477cecb59ce2b13ce1e82340a434057e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a525433b2c0308819a0d4b1ec68a6690f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvrvk_1_1impl_1_1_command_buffer_base__.html#a525433b2c0308819a0d4b1ec68a6690f">copyBuffer</a> (<a class="el" href="namespacepvrvk.html#a2a117db0aab25382d050908b2bfa4c8b">Buffer</a> srcBuffer, <a class="el" href="namespacepvrvk.html#a2a117db0aab25382d050908b2bfa4c8b">Buffer</a> dstBuffer, uint32_t srcOffset, uint32_t dstOffset, uint32_t sizeInBytes)</td></tr>
<tr class="memdesc:a525433b2c0308819a0d4b1ec68a6690f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy Buffer <a href="#a525433b2c0308819a0d4b1ec68a6690f">More...</a><br/></td></tr>
<tr class="separator:a525433b2c0308819a0d4b1ec68a6690f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a377b54630f07c121e53196ee32d56a8c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvrvk_1_1impl_1_1_command_buffer_base__.html#a377b54630f07c121e53196ee32d56a8c">copyBufferToImage</a> (const <a class="el" href="namespacepvrvk.html#a2a117db0aab25382d050908b2bfa4c8b">Buffer</a> &amp;buffer, <a class="el" href="namespacepvrvk.html#a0dde8112e297d1089979fbdbdcbbe0f4">Image</a> &amp;image, VkImageLayout dstImageLayout, uint32_t regionsCount, const <a class="el" href="structpvrvk_1_1_buffer_image_copy.html">BufferImageCopy</a> *regions)</td></tr>
<tr class="memdesc:a377b54630f07c121e53196ee32d56a8c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy buffer to image <a href="#a377b54630f07c121e53196ee32d56a8c">More...</a><br/></td></tr>
<tr class="separator:a377b54630f07c121e53196ee32d56a8c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a7f6ef1773c48cc63c66a540fb17caf"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvrvk_1_1impl_1_1_command_buffer_base__.html#a5a7f6ef1773c48cc63c66a540fb17caf">copyImage</a> (<a class="el" href="namespacepvrvk.html#a0dde8112e297d1089979fbdbdcbbe0f4">Image</a> &amp;srcImage, <a class="el" href="namespacepvrvk.html#a0dde8112e297d1089979fbdbdcbbe0f4">Image</a> &amp;dstImage, VkImageLayout srcImageLayout, VkImageLayout dstImageLayout, uint32_t numRegions, const <a class="el" href="structpvrvk_1_1_image_copy.html">ImageCopy</a> *regions)</td></tr>
<tr class="memdesc:a5a7f6ef1773c48cc63c66a540fb17caf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy data between Images <a href="#a5a7f6ef1773c48cc63c66a540fb17caf">More...</a><br/></td></tr>
<tr class="separator:a5a7f6ef1773c48cc63c66a540fb17caf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7348f826328fc3b1822fb4ed686e773a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvrvk_1_1impl_1_1_command_buffer_base__.html#a7348f826328fc3b1822fb4ed686e773a">copyImageToBuffer</a> (<a class="el" href="namespacepvrvk.html#a0dde8112e297d1089979fbdbdcbbe0f4">Image</a> &amp;srcImage, VkImageLayout srcImageLayout, <a class="el" href="namespacepvrvk.html#a2a117db0aab25382d050908b2bfa4c8b">Buffer</a> &amp;dstBuffer, const <a class="el" href="structpvrvk_1_1_buffer_image_copy.html">BufferImageCopy</a> *regions, uint32_t numRegions)</td></tr>
<tr class="memdesc:a7348f826328fc3b1822fb4ed686e773a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy image to buffer <a href="#a7348f826328fc3b1822fb4ed686e773a">More...</a><br/></td></tr>
<tr class="separator:a7348f826328fc3b1822fb4ed686e773a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a96aeb9ef8d82603dfeac45d2ff177ba2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvrvk_1_1impl_1_1_command_buffer_base__.html#a96aeb9ef8d82603dfeac45d2ff177ba2">dispatch</a> (uint32_t numGroupX, uint32_t numGroupY, uint32_t numGroupZ)</td></tr>
<tr class="memdesc:a96aeb9ef8d82603dfeac45d2ff177ba2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dispatching work provokes work in a compute pipeline. A compute pipeline must be bound to the command buffer before any dispatch commands are recorded. <a href="#a96aeb9ef8d82603dfeac45d2ff177ba2">More...</a><br/></td></tr>
<tr class="separator:a96aeb9ef8d82603dfeac45d2ff177ba2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb78b08d16568eeb47ffed3294d3f6e2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvrvk_1_1impl_1_1_command_buffer_base__.html#acb78b08d16568eeb47ffed3294d3f6e2">dispatchIndirect</a> (<a class="el" href="namespacepvrvk.html#a2a117db0aab25382d050908b2bfa4c8b">Buffer</a> &amp;buffer, uint32_t offset)</td></tr>
<tr class="memdesc:acb78b08d16568eeb47ffed3294d3f6e2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dispatching work provokes work in a compute pipeline. A compute pipeline must be bound to the command buffer before any dispatch commands are recorded. dispatchIndirect behaves similarly to dispatch except that the parameters are read by the device from a buffer during execution. The parameters of the dispatch are encoded in a VkDispatchIndirectCommand structure taken from buffer starting at offset <a href="#acb78b08d16568eeb47ffed3294d3f6e2">More...</a><br/></td></tr>
<tr class="separator:acb78b08d16568eeb47ffed3294d3f6e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a38f7566ddeb086f6aa546ee3311288"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvrvk_1_1impl_1_1_command_buffer_base__.html#a4a38f7566ddeb086f6aa546ee3311288">draw</a> (uint32_t firstVertex, uint32_t numVertices, uint32_t firstInstance=0, uint32_t numInstances=1)</td></tr>
<tr class="memdesc:a4a38f7566ddeb086f6aa546ee3311288"><td class="mdescLeft">&#160;</td><td class="mdescRight">Non-indexed drawing command. <a href="#a4a38f7566ddeb086f6aa546ee3311288">More...</a><br/></td></tr>
<tr class="separator:a4a38f7566ddeb086f6aa546ee3311288"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d0dd5fece38c2da3f474f302f70eba8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvrvk_1_1impl_1_1_command_buffer_base__.html#a9d0dd5fece38c2da3f474f302f70eba8">drawIndexed</a> (uint32_t firstIndex, uint32_t numIndices, uint32_t vertexOffset=0, uint32_t firstInstance=0, uint32_t numInstances=1)</td></tr>
<tr class="memdesc:a9d0dd5fece38c2da3f474f302f70eba8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Indexed drawing command. <a href="#a9d0dd5fece38c2da3f474f302f70eba8">More...</a><br/></td></tr>
<tr class="separator:a9d0dd5fece38c2da3f474f302f70eba8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2da4e6e18ae17379fd66ae6a7e3d3eb7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvrvk_1_1impl_1_1_command_buffer_base__.html#a2da4e6e18ae17379fd66ae6a7e3d3eb7">drawIndexedIndirect</a> (<a class="el" href="namespacepvrvk.html#a2a117db0aab25382d050908b2bfa4c8b">Buffer</a> &amp;buffer, uint32_t offset, uint32_t count, uint32_t stride)</td></tr>
<tr class="memdesc:a2da4e6e18ae17379fd66ae6a7e3d3eb7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Non-indexed indirect drawing command. <a href="#a2da4e6e18ae17379fd66ae6a7e3d3eb7">More...</a><br/></td></tr>
<tr class="separator:a2da4e6e18ae17379fd66ae6a7e3d3eb7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a38db7b68a0aafa77bc03b5f199843b6c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvrvk_1_1impl_1_1_command_buffer_base__.html#a38db7b68a0aafa77bc03b5f199843b6c">drawIndirect</a> (<a class="el" href="namespacepvrvk.html#a2a117db0aab25382d050908b2bfa4c8b">Buffer</a> &amp;buffer, uint32_t offset, uint32_t count, uint32_t stride)</td></tr>
<tr class="memdesc:a38db7b68a0aafa77bc03b5f199843b6c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Non-indexed indirect drawing command. <a href="#a38db7b68a0aafa77bc03b5f199843b6c">More...</a><br/></td></tr>
<tr class="separator:a38db7b68a0aafa77bc03b5f199843b6c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a571250974bf01a908011ca732dbb74d7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvrvk_1_1impl_1_1_command_buffer_base__.html#a571250974bf01a908011ca732dbb74d7">end</a> ()</td></tr>
<tr class="memdesc:a571250974bf01a908011ca732dbb74d7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Call this function when you are done recording commands. BeginRecording must be called first.  <a href="#a571250974bf01a908011ca732dbb74d7">More...</a><br/></td></tr>
<tr class="separator:a571250974bf01a908011ca732dbb74d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a56e3f2184eeb8f9aadaa631c1338179b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvrvk_1_1impl_1_1_command_buffer_base__.html#a56e3f2184eeb8f9aadaa631c1338179b">fillBuffer</a> (<a class="el" href="namespacepvrvk.html#a2a117db0aab25382d050908b2bfa4c8b">Buffer</a> dstBuffer, uint32_t dstOffset, uint32_t data, uint64_t size=VK_WHOLE_SIZE)</td></tr>
<tr class="memdesc:a56e3f2184eeb8f9aadaa631c1338179b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clear buffer data <a href="#a56e3f2184eeb8f9aadaa631c1338179b">More...</a><br/></td></tr>
<tr class="separator:a56e3f2184eeb8f9aadaa631c1338179b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afbec4fbcfddbaff8fa39c6abf03f21f8"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="namespacepvrvk.html#ac9949394db8b3d968a7402b837567f87">CommandPool</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvrvk_1_1impl_1_1_command_buffer_base__.html#afbec4fbcfddbaff8fa39c6abf03f21f8">getCommandPool</a> () const </td></tr>
<tr class="memdesc:afbec4fbcfddbaff8fa39c6abf03f21f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Const getter for the command pool used to allocate this command buffer. <a href="#afbec4fbcfddbaff8fa39c6abf03f21f8">More...</a><br/></td></tr>
<tr class="separator:afbec4fbcfddbaff8fa39c6abf03f21f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a54e2c4a1abb377258b09261677deda20"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacepvrvk.html#a8dd5932a80187b088ce6b591712dc2c2">DeviceWeakPtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvrvk_1_1impl_1_1_command_buffer_base__.html#a54e2c4a1abb377258b09261677deda20">getDevice</a> ()</td></tr>
<tr class="memdesc:a54e2c4a1abb377258b09261677deda20"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get weak a reference to the device which was used to create this CommandBuffer. <a href="#a54e2c4a1abb377258b09261677deda20">More...</a><br/></td></tr>
<tr class="separator:a54e2c4a1abb377258b09261677deda20"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab9987985cff04d01121c6cbb8221487f"><td class="memItemLeft" align="right" valign="top">VkCommandBuffer &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvrvk_1_1impl_1_1_command_buffer_base__.html#ab9987985cff04d01121c6cbb8221487f">getNativeObject</a> ()</td></tr>
<tr class="memdesc:ab9987985cff04d01121c6cbb8221487f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Getter for this command buffers vulkan handle. <a href="#ab9987985cff04d01121c6cbb8221487f">More...</a><br/></td></tr>
<tr class="separator:ab9987985cff04d01121c6cbb8221487f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1bec22ca816d4c36fb11d5fa43ef65ac"><td class="memItemLeft" align="right" valign="top">const VkCommandBuffer &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvrvk_1_1impl_1_1_command_buffer_base__.html#a1bec22ca816d4c36fb11d5fa43ef65ac">getNativeObject</a> () const </td></tr>
<tr class="memdesc:a1bec22ca816d4c36fb11d5fa43ef65ac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Const getter for this command buffers vulkan handle. <a href="#a1bec22ca816d4c36fb11d5fa43ef65ac">More...</a><br/></td></tr>
<tr class="separator:a1bec22ca816d4c36fb11d5fa43ef65ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f32e4b0b8899d01ff783456befcb5b9"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvrvk_1_1impl_1_1_command_buffer_base__.html#a0f32e4b0b8899d01ff783456befcb5b9">isRecording</a> ()</td></tr>
<tr class="memdesc:a0f32e4b0b8899d01ff783456befcb5b9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Queries if a command buffer is in the recording state <a href="#a0f32e4b0b8899d01ff783456befcb5b9">More...</a><br/></td></tr>
<tr class="separator:a0f32e4b0b8899d01ff783456befcb5b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a79917bf8d77bb0d5d2a43aa9654eb5cc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvrvk_1_1impl_1_1_command_buffer_base__.html#a79917bf8d77bb0d5d2a43aa9654eb5cc">pipelineBarrier</a> (VkPipelineStageFlags srcStage, VkPipelineStageFlags dstStage, const <a class="el" href="classpvrvk_1_1_memory_barrier_set.html">MemoryBarrierSet</a> &amp;barriers, bool dependencyByRegion=true)</td></tr>
<tr class="memdesc:a79917bf8d77bb0d5d2a43aa9654eb5cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a memory barrier to the command stream, forcing preceeding commands to be written before succeeding commands are executed. <a href="#a79917bf8d77bb0d5d2a43aa9654eb5cc">More...</a><br/></td></tr>
<tr class="separator:a79917bf8d77bb0d5d2a43aa9654eb5cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a450ff6f0132701950130b984f1f2cf41"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvrvk_1_1impl_1_1_command_buffer_base__.html#a450ff6f0132701950130b984f1f2cf41">pushConstants</a> (<a class="el" href="namespacepvrvk.html#a34bb21497524a13e145b1398450989d0">PipelineLayout</a> &amp;pipelineLayout, VkShaderStageFlags stageFlags, uint32_t offset, uint32_t size, const void *data)</td></tr>
<tr class="memdesc:a450ff6f0132701950130b984f1f2cf41"><td class="mdescLeft">&#160;</td><td class="mdescRight">Updates the value of shader push constants at the offset specified. <a href="#a450ff6f0132701950130b984f1f2cf41">More...</a><br/></td></tr>
<tr class="separator:a450ff6f0132701950130b984f1f2cf41"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe3165cf1f7f36e14d6e6b9ef30fdfff"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="afe3165cf1f7f36e14d6e6b9ef30fdfff"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvrvk_1_1impl_1_1_command_buffer_base__.html#afe3165cf1f7f36e14d6e6b9ef30fdfff">reset</a> (VkCommandBufferResetFlags resetFlags)</td></tr>
<tr class="memdesc:afe3165cf1f7f36e14d6e6b9ef30fdfff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clears this CommandBuffer discarding any previously recorded commands and puts the command buffer in the initial state. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">resetFlags</td><td>Is a bitmask of VkCommandBufferResetFlagBits controlling the reset operation.</td></tr>
  </table>
  </dd>
</dl>
<br/></td></tr>
<tr class="separator:afe3165cf1f7f36e14d6e6b9ef30fdfff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac7a619081148516d5bfecd9ef11588b2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvrvk_1_1impl_1_1_command_buffer_base__.html#ac7a619081148516d5bfecd9ef11588b2">resetEvent</a> (<a class="el" href="namespacepvrvk.html#a6696a17453f99f2b221a28bb05e4934b">Event</a> &amp;event, VkPipelineStageFlags pipelineStageFlags=VkPipelineStageFlags::e_ALL_COMMANDS_BIT)</td></tr>
<tr class="memdesc:ac7a619081148516d5bfecd9ef11588b2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defines an execution dependency on commands that were submitted before it, and defines an event unsignal operation which resets the event to the unsignaled state. <a href="#ac7a619081148516d5bfecd9ef11588b2">More...</a><br/></td></tr>
<tr class="separator:ac7a619081148516d5bfecd9ef11588b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adbf21794fa62a0c0183978806be8ed2f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvrvk_1_1impl_1_1_command_buffer_base__.html#adbf21794fa62a0c0183978806be8ed2f">resolveImage</a> (<a class="el" href="namespacepvrvk.html#a0dde8112e297d1089979fbdbdcbbe0f4">Image</a> &amp;srcImage, <a class="el" href="namespacepvrvk.html#a0dde8112e297d1089979fbdbdcbbe0f4">Image</a> &amp;dstImage, const <a class="el" href="structpvrvk_1_1_image_resolve.html">ImageResolve</a> *regions, uint32_t numRegions, VkImageLayout srcLayout, VkImageLayout dstLayout)</td></tr>
<tr class="memdesc:adbf21794fa62a0c0183978806be8ed2f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies regions of a src image into a dst image, potentially also performing format conversions, aritrary scaling and filtering. <a href="#adbf21794fa62a0c0183978806be8ed2f">More...</a><br/></td></tr>
<tr class="separator:adbf21794fa62a0c0183978806be8ed2f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ce2c215aa9814e5e8aa02f679f9fa24"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvrvk_1_1impl_1_1_command_buffer_base__.html#a9ce2c215aa9814e5e8aa02f679f9fa24">setBlendConstants</a> (float rgba[4])</td></tr>
<tr class="memdesc:a9ce2c215aa9814e5e8aa02f679f9fa24"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the dynamic blend constant bias state affecting pipeline objects created with VK_DYNAMIC_STATE_BLEND_CONSTANTS enabled. <a href="#a9ce2c215aa9814e5e8aa02f679f9fa24">More...</a><br/></td></tr>
<tr class="separator:a9ce2c215aa9814e5e8aa02f679f9fa24"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a486a9d46e8f693398db0dc03fede5fb6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvrvk_1_1impl_1_1_command_buffer_base__.html#a486a9d46e8f693398db0dc03fede5fb6">setDepthBias</a> (float constantFactor, float clamp, float slopeFactor)</td></tr>
<tr class="memdesc:a486a9d46e8f693398db0dc03fede5fb6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the dynamic depth bias state affecting pipeline objects created where depthBiasEnable is enabled. <a href="#a486a9d46e8f693398db0dc03fede5fb6">More...</a><br/></td></tr>
<tr class="separator:a486a9d46e8f693398db0dc03fede5fb6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae41e1a87d69f9f3476ea6e20037b9b00"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvrvk_1_1impl_1_1_command_buffer_base__.html#ae41e1a87d69f9f3476ea6e20037b9b00">setDepthBounds</a> (float min, float max)</td></tr>
<tr class="memdesc:ae41e1a87d69f9f3476ea6e20037b9b00"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the dynamic depth bounds state affecting pipeline objects created with VK_DYNAMIC_STATE_DEPTH_BOUNDS enabled. <a href="#ae41e1a87d69f9f3476ea6e20037b9b00">More...</a><br/></td></tr>
<tr class="separator:ae41e1a87d69f9f3476ea6e20037b9b00"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a6c05f7450a1d1d925cb07787b8305a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvrvk_1_1impl_1_1_command_buffer_base__.html#a1a6c05f7450a1d1d925cb07787b8305a">setEvent</a> (<a class="el" href="namespacepvrvk.html#a6696a17453f99f2b221a28bb05e4934b">Event</a> &amp;event, VkPipelineStageFlags pipelineStageFlags=VkPipelineStageFlags::e_ALL_COMMANDS_BIT)</td></tr>
<tr class="memdesc:a1a6c05f7450a1d1d925cb07787b8305a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defines an execution dependency on commands that were submitted before it, and defines an event signal operation which sets the event to the signaled state. <a href="#a1a6c05f7450a1d1d925cb07787b8305a">More...</a><br/></td></tr>
<tr class="separator:a1a6c05f7450a1d1d925cb07787b8305a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e36ba62ffb95e3a6fd71aa415542391"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvrvk_1_1impl_1_1_command_buffer_base__.html#a6e36ba62ffb95e3a6fd71aa415542391">setLineWidth</a> (float lineWidth)</td></tr>
<tr class="memdesc:a6e36ba62ffb95e3a6fd71aa415542391"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the dynamic line width state affecting pipeline objects created with VK_DYNAMIC_STATE_LINE_WIDTH enabled. <a href="#a6e36ba62ffb95e3a6fd71aa415542391">More...</a><br/></td></tr>
<tr class="separator:a6e36ba62ffb95e3a6fd71aa415542391"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a55552c7dc09c30e96cd91a09b04c14fe"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvrvk_1_1impl_1_1_command_buffer_base__.html#a55552c7dc09c30e96cd91a09b04c14fe">setScissor</a> (uint32_t firstScissor, uint32_t numScissors, const <a class="el" href="structpvrvk_1_1_rect2_di.html">Rect2Di</a> *scissors)</td></tr>
<tr class="memdesc:a55552c7dc09c30e96cd91a09b04c14fe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the dynamic scissor state affecting pipeline objects created with VK_DYNAMIC_STATE_SCISSOR enabled. <a href="#a55552c7dc09c30e96cd91a09b04c14fe">More...</a><br/></td></tr>
<tr class="separator:a55552c7dc09c30e96cd91a09b04c14fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad983598915f237dd07e8b99736e06fb6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvrvk_1_1impl_1_1_command_buffer_base__.html#ad983598915f237dd07e8b99736e06fb6">setStencilCompareMask</a> (VkStencilFaceFlags face, uint32_t compareMask)</td></tr>
<tr class="memdesc:ad983598915f237dd07e8b99736e06fb6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the dynamic stencil compare mask state affecting pipeline objects created with VK_DYNAMIC_STATE_STENCIL_COMPARE_MASK enabled. <a href="#ad983598915f237dd07e8b99736e06fb6">More...</a><br/></td></tr>
<tr class="separator:ad983598915f237dd07e8b99736e06fb6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8bf69dcfe53aed66cdfed3d83e450966"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvrvk_1_1impl_1_1_command_buffer_base__.html#a8bf69dcfe53aed66cdfed3d83e450966">setStencilReference</a> (VkStencilFaceFlags face, uint32_t reference)</td></tr>
<tr class="memdesc:a8bf69dcfe53aed66cdfed3d83e450966"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the dynamic stencil reference mask state affecting pipeline objects created with VK_DYNAMIC_STATE_STENCIL_REFERENCE enabled. <a href="#a8bf69dcfe53aed66cdfed3d83e450966">More...</a><br/></td></tr>
<tr class="separator:a8bf69dcfe53aed66cdfed3d83e450966"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae21c88d1469550959a7dab962362f493"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvrvk_1_1impl_1_1_command_buffer_base__.html#ae21c88d1469550959a7dab962362f493">setStencilWriteMask</a> (VkStencilFaceFlags face, uint32_t writeMask)</td></tr>
<tr class="memdesc:ae21c88d1469550959a7dab962362f493"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the dynamic stencil write mask state affecting pipeline objects created with VK_DYNAMIC_STATE_STENCIL_WRITE_MASK enabled. <a href="#ae21c88d1469550959a7dab962362f493">More...</a><br/></td></tr>
<tr class="separator:ae21c88d1469550959a7dab962362f493"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b850bccfeda750ecb9e2c98c8c2b018"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvrvk_1_1impl_1_1_command_buffer_base__.html#a8b850bccfeda750ecb9e2c98c8c2b018">setViewport</a> (const <a class="el" href="structpvrvk_1_1_viewport.html">Viewport</a> &amp;viewport)</td></tr>
<tr class="memdesc:a8b850bccfeda750ecb9e2c98c8c2b018"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set viewport <a href="#a8b850bccfeda750ecb9e2c98c8c2b018">More...</a><br/></td></tr>
<tr class="separator:a8b850bccfeda750ecb9e2c98c8c2b018"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ec18d08b6609a9078a081fa31f3ce77"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvrvk_1_1impl_1_1_command_buffer_base__.html#a9ec18d08b6609a9078a081fa31f3ce77">updateBuffer</a> (<a class="el" href="namespacepvrvk.html#a2a117db0aab25382d050908b2bfa4c8b">Buffer</a> &amp;buffer, const void *data, uint32_t offset, uint32_t length)</td></tr>
<tr class="memdesc:a9ec18d08b6609a9078a081fa31f3ce77"><td class="mdescLeft">&#160;</td><td class="mdescRight">Updates buffer data inline in a command buffer. The update is only allowed outside of a renderpass and is treated as a transfer operation for the purposes of syncrhonization. <a href="#a9ec18d08b6609a9078a081fa31f3ce77">More...</a><br/></td></tr>
<tr class="separator:a9ec18d08b6609a9078a081fa31f3ce77"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a50b272c0a71f01ce4f8734ba15605456"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvrvk_1_1impl_1_1_command_buffer_base__.html#a50b272c0a71f01ce4f8734ba15605456">waitForEvent</a> (const <a class="el" href="namespacepvrvk.html#a6696a17453f99f2b221a28bb05e4934b">Event</a> &amp;event, VkPipelineStageFlags srcStage, VkPipelineStageFlags dstStage, const <a class="el" href="classpvrvk_1_1_memory_barrier_set.html">MemoryBarrierSet</a> &amp;barriers)</td></tr>
<tr class="memdesc:a50b272c0a71f01ce4f8734ba15605456"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defines a memory dependency between prior event signal operations and subsequent commands. <a href="#a50b272c0a71f01ce4f8734ba15605456">More...</a><br/></td></tr>
<tr class="separator:a50b272c0a71f01ce4f8734ba15605456"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad3245f9af726e52e6a611c4cabf12289"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvrvk_1_1impl_1_1_command_buffer_base__.html#ad3245f9af726e52e6a611c4cabf12289">waitForEvents</a> (const <a class="el" href="namespacepvrvk.html#a6696a17453f99f2b221a28bb05e4934b">Event</a> *events, uint32_t numEvents, VkPipelineStageFlags srcStage, VkPipelineStageFlags dstStage, const <a class="el" href="classpvrvk_1_1_memory_barrier_set.html">MemoryBarrierSet</a> &amp;barriers)</td></tr>
<tr class="memdesc:ad3245f9af726e52e6a611c4cabf12289"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defines a set of memory dependencies between prior event signal operations and subsequent commands. <a href="#ad3245f9af726e52e6a611c4cabf12289">More...</a><br/></td></tr>
<tr class="separator:ad3245f9af726e52e6a611c4cabf12289"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:a86e1b4cc6a21665d524d41e661036e99"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacepvrvk.html#a8dd5932a80187b088ce6b591712dc2c2">DeviceWeakPtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvrvk_1_1impl_1_1_command_buffer_base__.html#a86e1b4cc6a21665d524d41e661036e99">_device</a></td></tr>
<tr class="memdesc:a86e1b4cc6a21665d524d41e661036e99"><td class="mdescLeft">&#160;</td><td class="mdescRight">The device used to create this command buffer. <a href="#a86e1b4cc6a21665d524d41e661036e99">More...</a><br/></td></tr>
<tr class="separator:a86e1b4cc6a21665d524d41e661036e99"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a759e4e7ca81cb8812048075ddcf274d6"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvrvk_1_1impl_1_1_command_buffer_base__.html#a759e4e7ca81cb8812048075ddcf274d6">_isRecording</a></td></tr>
<tr class="memdesc:a759e4e7ca81cb8812048075ddcf274d6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specifies whether the command buffer is currently in the recording state which is controlled via calling the begin function. <a href="#a759e4e7ca81cb8812048075ddcf274d6">More...</a><br/></td></tr>
<tr class="separator:a759e4e7ca81cb8812048075ddcf274d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a943d27103dec9450a0966c8352aef979"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacepvrvk.html#a946a7145c9e18b9a797fa714ce677f32">ComputePipeline</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvrvk_1_1impl_1_1_command_buffer_base__.html#a943d27103dec9450a0966c8352aef979">_lastBoundComputePipe</a></td></tr>
<tr class="memdesc:a943d27103dec9450a0966c8352aef979"><td class="mdescLeft">&#160;</td><td class="mdescRight">Holds a reference to the last bound compute pipeline. This can then be used for optimising binding the same compute pipeline repeatedly. <a href="#a943d27103dec9450a0966c8352aef979">More...</a><br/></td></tr>
<tr class="separator:a943d27103dec9450a0966c8352aef979"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa0f1be52e5e2affe2a3f57ea68a8d036"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacepvrvk.html#aa2443b681960df638797cf93bbf33fb7">GraphicsPipeline</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvrvk_1_1impl_1_1_command_buffer_base__.html#aa0f1be52e5e2affe2a3f57ea68a8d036">_lastBoundGraphicsPipe</a></td></tr>
<tr class="memdesc:aa0f1be52e5e2affe2a3f57ea68a8d036"><td class="mdescLeft">&#160;</td><td class="mdescRight">Holds a reference to the last bound graphics pipeline. This can then be used for optimising binding the same graphics pipeline repeatedly. <a href="#aa0f1be52e5e2affe2a3f57ea68a8d036">More...</a><br/></td></tr>
<tr class="separator:aa0f1be52e5e2affe2a3f57ea68a8d036"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c87869144c258a576df247c3555252d"><td class="memItemLeft" align="right" valign="top">std::vector<br class="typebreak"/>
&lt; RefCountedResource&lt; void &gt;&gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvrvk_1_1impl_1_1_command_buffer_base__.html#a2c87869144c258a576df247c3555252d">_objectReferences</a></td></tr>
<tr class="memdesc:a2c87869144c258a576df247c3555252d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Holds a list of references to the objects currently in use by this command buffer. This ensures that objects are kept alive through reference counting until the command buffer is finished with them. <a href="#a2c87869144c258a576df247c3555252d">More...</a><br/></td></tr>
<tr class="separator:a2c87869144c258a576df247c3555252d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb4cc024978587b241ae65a8541d5815"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacepvrvk.html#ac9949394db8b3d968a7402b837567f87">CommandPool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvrvk_1_1impl_1_1_command_buffer_base__.html#adb4cc024978587b241ae65a8541d5815">_pool</a></td></tr>
<tr class="memdesc:adb4cc024978587b241ae65a8541d5815"><td class="mdescLeft">&#160;</td><td class="mdescRight">The command pool from which this command buffer was allocated. <a href="#adb4cc024978587b241ae65a8541d5815">More...</a><br/></td></tr>
<tr class="separator:adb4cc024978587b241ae65a8541d5815"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7906881f09d2e7f2a137438771f53377"><td class="memItemLeft" align="right" valign="top">VkCommandBuffer&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvrvk_1_1impl_1_1_command_buffer_base__.html#a7906881f09d2e7f2a137438771f53377">_vkCmdBuffer</a></td></tr>
<tr class="memdesc:a7906881f09d2e7f2a137438771f53377"><td class="mdescLeft">&#160;</td><td class="mdescRight">The Vulkan handle for this command buffer. <a href="#a7906881f09d2e7f2a137438771f53377">More...</a><br/></td></tr>
<tr class="separator:a7906881f09d2e7f2a137438771f53377"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Contains all the commands and states that need to be submitted to the gpu, including pipeline, texture, and samplers. Virtually everything that needs to happen on the GPU is submitted to the CommandBuffer. </p>
<p>Secondary command buffers cannot contain RenderPasses, and cannot be submitted to the GPU. SecondaryCommandBuffers can be submitted to the primaryCommandBuffer -It is invalid to submit commands to a command buffer while it is not being recorded. -It is invalid to reset a command buffer while it is being recorded. -It is invalid to submit a command buffer more than once if it is one time submit command buffer -Draw commands must be between a BeginRenderpass and an EndRenderpass command</p>
</div><h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="a4f76288bd10eeb9fd943676d70b96060"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void pvrvk::impl::CommandBufferBase_::begin </td>
          <td>(</td>
          <td class="paramtype">const VkCommandBufferUsageFlags&#160;</td>
          <td class="paramname"><em>flags</em> = <code>VkCommandBufferUsageFlags(0)</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Call this function before beginning to record commands.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">flags</td><td>Flags is a bitmask of VkCommandBufferUsageFlagBits specifying usage behavior for the command buffer.</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a29de9fd9b732a83d33ab70feb26abc94"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pvrvk::impl::SecondaryCommandBuffer_::begin </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacepvrvk.html#a55f833c5feaaa65f3aaed3a08a7a55e6">RenderPass</a> &amp;&#160;</td>
          <td class="paramname"><em>renderpass</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>subpass</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const VkCommandBufferUsageFlags&#160;</td>
          <td class="paramname"><em>flags</em> = <code>VkCommandBufferUsageFlags::e_RENDER_PASS_CONTINUE_BIT</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Call this function before beginning to record commands. If the Framebuffer object is known, prefer the Framebuffer overload as it may offer better performance.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">renderpass</td><td>A RenderPass object defining which render passes this SecondaryCommandBuffer will be compatible with and can be executed within.</td></tr>
    <tr><td class="paramname">subpass</td><td>The index of the subpass within the render pass instance that this CommandBuffer will be executed within.</td></tr>
    <tr><td class="paramname">flags</td><td>Flags is a bitmask of VkCommandBufferUsageFlagBits specifying usage behavior for the command buffer.</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a5c9a9895e19f73ff06990c2faf29c21c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pvrvk::impl::SecondaryCommandBuffer_::begin </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacepvrvk.html#a7639515cddb57ed4370a5ce02287988a">Framebuffer</a> &amp;&#160;</td>
          <td class="paramname"><em>framebuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>subpass</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const VkCommandBufferUsageFlags&#160;</td>
          <td class="paramname"><em>flags</em> = <code>VkCommandBufferUsageFlags::e_RENDER_PASS_CONTINUE_BIT</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Call this function before beginning to record commands.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">framebuffer</td><td>Refers to an Framebuffer object that this CommandBuffer will be rendering to if it is executed within a render pass instance.</td></tr>
    <tr><td class="paramname">subpass</td><td>The index of the subpass within the render pass instance that this CommandBuffer will be executed within.</td></tr>
    <tr><td class="paramname">flags</td><td>Flags is a bitmask of VkCommandBufferUsageFlagBits specifying usage behavior for the command buffer.</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aa2790065ae29813b0752b76d0485d210"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void pvrvk::impl::CommandBufferBase_::bindDescriptorSet </td>
          <td>(</td>
          <td class="paramtype">VkPipelineBindPoint&#160;</td>
          <td class="paramname"><em>bindingPoint</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacepvrvk.html#a34bb21497524a13e145b1398450989d0">PipelineLayout</a> &amp;&#160;</td>
          <td class="paramname"><em>pipelineLayout</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>firstSet</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacepvrvk.html#afaa5d3390eb48fd21197430158a7d5ac">DescriptorSet</a>&#160;</td>
          <td class="paramname"><em>set</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint32_t *&#160;</td>
          <td class="paramname"><em>dynamicOffsets</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>numDynamicOffsets</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Bind descriptorset</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bindingPoint</td><td>Pipeline binding point</td></tr>
    <tr><td class="paramname">pipelineLayout</td><td>Pipeline layout</td></tr>
    <tr><td class="paramname">firstSet</td><td>The set number of the first descriptor set to be bound</td></tr>
    <tr><td class="paramname">set</td><td>Descriptor set to be bound</td></tr>
    <tr><td class="paramname">dynamicOffsets</td><td>Pointer to an array of uint</td></tr>
  </table>
  </dd>
</dl>
<p>32_t values specifying dynamic offsets </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">numDynamicOffsets</td><td>Number of dynamic offsets</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a2fa18c915c858eae6c62666e63c8d023"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void pvrvk::impl::CommandBufferBase_::bindDescriptorSets </td>
          <td>(</td>
          <td class="paramtype">VkPipelineBindPoint&#160;</td>
          <td class="paramname"><em>bindingPoint</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacepvrvk.html#a34bb21497524a13e145b1398450989d0">PipelineLayout</a> &amp;&#160;</td>
          <td class="paramname"><em>pipelineLayout</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>firstSet</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacepvrvk.html#afaa5d3390eb48fd21197430158a7d5ac">DescriptorSet</a> *&#160;</td>
          <td class="paramname"><em>sets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>numDescriptorSets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint32_t *&#160;</td>
          <td class="paramname"><em>dynamicOffsets</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>numDynamicOffsets</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Bind descriptorsets</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bindingPoint</td><td>Pipeline binding point</td></tr>
    <tr><td class="paramname">pipelineLayout</td><td>Pipeline layout</td></tr>
    <tr><td class="paramname">firstSet</td><td>The set number of the first descriptor set to be bound</td></tr>
    <tr><td class="paramname">sets</td><td>Pointer to the descriptor sets to be bound</td></tr>
    <tr><td class="paramname">numDescriptorSets</td><td>Number of descriptor sets</td></tr>
    <tr><td class="paramname">dynamicOffsets</td><td>Pointer to an array of uint</td></tr>
  </table>
  </dd>
</dl>
<p>32_t values specifying dynamic offsets </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">numDynamicOffsets</td><td>Number of dynamic offsets</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a59e59dde44ad5822f7dcd1008250a070"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void pvrvk::impl::CommandBufferBase_::bindIndexBuffer </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacepvrvk.html#a2a117db0aab25382d050908b2bfa4c8b">Buffer</a> &amp;&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VkIndexType&#160;</td>
          <td class="paramname"><em>indexType</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Bind index bufer</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buffer</td><td>Imdex buffer</td></tr>
    <tr><td class="paramname">offset</td><td>Buffer offset</td></tr>
    <tr><td class="paramname">indexType</td><td>IndexType</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="adfc394932317683fb0582841423527b2"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void pvrvk::impl::CommandBufferBase_::bindPipeline </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacepvrvk.html#aa2443b681960df638797cf93bbf33fb7">GraphicsPipeline</a> &amp;&#160;</td>
          <td class="paramname"><em>pipeline</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Bind a graphics pipeline.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pipeline</td><td>The GraphicsPipeline to bind.</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a79d2f3d38f2aad3fa3ba4b7b793d1421"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void pvrvk::impl::CommandBufferBase_::bindPipeline </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacepvrvk.html#a946a7145c9e18b9a797fa714ce677f32">ComputePipeline</a> &amp;&#160;</td>
          <td class="paramname"><em>pipeline</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Bind a compute pipeline</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pipeline</td><td>The ComputePipeline to bind</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a2382fc789d3e96d50693f9e5483ff0b0"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void pvrvk::impl::CommandBufferBase_::bindVertexBuffer </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacepvrvk.html#a2a117db0aab25382d050908b2bfa4c8b">Buffer</a> &amp;&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>bindingIndex</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Bind vertex buffer</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buffer</td><td>Buffer</td></tr>
    <tr><td class="paramname">offset</td><td>Buffer offset</td></tr>
    <tr><td class="paramname">bindingIndex</td><td>The index of the vertex input binding whose state is updated by the command. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a2853f758e9e70e100e3140405fc8e03c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void pvrvk::impl::CommandBufferBase_::bindVertexBuffer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacepvrvk.html#a2a117db0aab25382d050908b2bfa4c8b">Buffer</a> const *&#160;</td>
          <td class="paramname"><em>buffers</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>offsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>numBuffers</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>startBinding</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>numBindings</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Bind vertex buffer</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buffers</td><td>Buffers to be bound</td></tr>
    <tr><td class="paramname">offsets</td><td>Pointer to an array of buffer offsets.</td></tr>
    <tr><td class="paramname">numBuffers</td><td>number of buffers</td></tr>
    <tr><td class="paramname">startBinding</td><td>The indices of the first vertex input binding whose state is updated by the command.</td></tr>
    <tr><td class="paramname">numBindings</td><td>Number of bindings</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="af6acf0e46f17c2b81f59626333956913"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void pvrvk::impl::CommandBufferBase_::blitImage </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacepvrvk.html#a0dde8112e297d1089979fbdbdcbbe0f4">Image</a> &amp;&#160;</td>
          <td class="paramname"><em>srcImage</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacepvrvk.html#a0dde8112e297d1089979fbdbdcbbe0f4">Image</a> &amp;&#160;</td>
          <td class="paramname"><em>dstImage</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structpvrvk_1_1_image_blit_range.html">ImageBlitRange</a> *&#160;</td>
          <td class="paramname"><em>regions</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>numRegions</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VkFilter&#160;</td>
          <td class="paramname"><em>filter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VkImageLayout&#160;</td>
          <td class="paramname"><em>srcLayout</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VkImageLayout&#160;</td>
          <td class="paramname"><em>dstLayout</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copies regions of a src image into a dst image, potentially also performing format conversions, aritrary scaling and filtering.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">srcImage</td><td>The src Image in the copy.</td></tr>
    <tr><td class="paramname">dstImage</td><td>The dst image.</td></tr>
    <tr><td class="paramname">regions</td><td>A pointer to an array of <a class="el" href="structpvrvk_1_1_image_blit_range.html" title="Represents a blit operation through source and destination offsets">ImageBlitRange</a> structures specifying the regions to blit.</td></tr>
    <tr><td class="paramname">numRegions</td><td>The number of regions to blit.</td></tr>
    <tr><td class="paramname">filter</td><td>A VkFilter specifying the filter to apply if the blits require scaling</td></tr>
    <tr><td class="paramname">srcLayout</td><td>The layout of the src image subresrcs for the blit.</td></tr>
    <tr><td class="paramname">dstLayout</td><td>The layout of the dst image subresrcs for the blit.</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a26d8498fee836c63989072eb483d8938"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void pvrvk::impl::CommandBufferBase_::clearAttachment </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structpvrvk_1_1_clear_attachment.html">ClearAttachment</a> &amp;&#160;</td>
          <td class="paramname"><em>clearAttachment</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structpvrvk_1_1_clear_rect.html">ClearRect</a> &amp;&#160;</td>
          <td class="paramname"><em>clearRectangle</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Clears a particular attachment using a provided region whilst inside of a renderpass.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">clearAttachment</td><td>A single <a class="el" href="structpvrvk_1_1_clear_attachment.html" title="ClearAttachment structures defining the attachments to clear and the clear values to use...">ClearAttachment</a> structure defining the attachment to clear and the clear value to use</td></tr>
    <tr><td class="paramname">clearRectangle</td><td>A <a class="el" href="structpvrvk_1_1_clear_rect.html" title="ClearRect structures defining regions within each selected attachment to clear in Commandbuffer::clea...">ClearRect</a> structure defining a region within the attachment to clear</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ac681c14ddfb7b443d318e695633571b5"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void pvrvk::impl::CommandBufferBase_::clearAttachments </td>
          <td>(</td>
          <td class="paramtype">const uint32_t&#160;</td>
          <td class="paramname"><em>numAttachments</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structpvrvk_1_1_clear_attachment.html">ClearAttachment</a> *&#160;</td>
          <td class="paramname"><em>clearAttachments</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>numRectangles</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structpvrvk_1_1_clear_rect.html">ClearRect</a> *&#160;</td>
          <td class="paramname"><em>clearRectangles</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Clear a set of attacments using a number of regions for each selected attachment to clear whilst inside a renderpass.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">numAttachments</td><td>The number of entries in the clearAttachments array.</td></tr>
    <tr><td class="paramname">clearAttachments</td><td>Is a pointer to an array of <a class="el" href="structpvrvk_1_1_clear_attachment.html" title="ClearAttachment structures defining the attachments to clear and the clear values to use...">ClearAttachment</a> structures which defines the attachments to clear and the clear values to use.</td></tr>
    <tr><td class="paramname">numRectangles</td><td>Is the number of entries in the clearRects array.</td></tr>
    <tr><td class="paramname">clearRectangles</td><td>Points to an array of <a class="el" href="structpvrvk_1_1_clear_rect.html" title="ClearRect structures defining regions within each selected attachment to clear in Commandbuffer::clea...">ClearRect</a> structures defining regions within each selected attachment to clear.</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a908a20001250afc90bb6c4dc0f3343fb"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void pvrvk::impl::CommandBufferBase_::clearColorImage </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacepvrvk.html#ad4da214c95fffe4edccb14eb2c270f07">ImageView</a> &amp;&#160;</td>
          <td class="paramname"><em>image</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structpvrvk_1_1_clear_color_value.html">ClearColorValue</a> &amp;&#160;</td>
          <td class="paramname"><em>clearColor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VkImageLayout&#160;</td>
          <td class="paramname"><em>currentLayout</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint32_t&#160;</td>
          <td class="paramname"><em>baseMipLevel</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint32_t&#160;</td>
          <td class="paramname"><em>numLevels</em> = <code>1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint32_t&#160;</td>
          <td class="paramname"><em>baseArrayLayer</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint32_t&#160;</td>
          <td class="paramname"><em>numLayers</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Clears a color image outside of a renderpass instance.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">image</td><td>Image to clear</td></tr>
    <tr><td class="paramname">clearColor</td><td>Clear color value</td></tr>
    <tr><td class="paramname">currentLayout</td><td>Image current layout</td></tr>
    <tr><td class="paramname">baseMipLevel</td><td>Base mip map level to clear</td></tr>
    <tr><td class="paramname">numLevels</td><td>Number of mipmap levels to clear</td></tr>
    <tr><td class="paramname">baseArrayLayer</td><td>Base array layer to clear</td></tr>
    <tr><td class="paramname">numLayers</td><td>Number of array layers to clear</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a702388020e9ee489d3fad1006b087098"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void pvrvk::impl::CommandBufferBase_::clearColorImage </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacepvrvk.html#ad4da214c95fffe4edccb14eb2c270f07">ImageView</a> &amp;&#160;</td>
          <td class="paramname"><em>image</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structpvrvk_1_1_clear_color_value.html">ClearColorValue</a> &amp;&#160;</td>
          <td class="paramname"><em>clearColor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VkImageLayout&#160;</td>
          <td class="paramname"><em>currentLayout</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint32_t *&#160;</td>
          <td class="paramname"><em>baseMipLevels</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint32_t *&#160;</td>
          <td class="paramname"><em>numLevels</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint32_t *&#160;</td>
          <td class="paramname"><em>baseArrayLayers</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint32_t *&#160;</td>
          <td class="paramname"><em>numLayers</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>numRanges</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Clears a color image outside of a renderpass instance using a number of ranges.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">image</td><td>Image to clear.</td></tr>
    <tr><td class="paramname">clearColor</td><td>Clear color value.</td></tr>
    <tr><td class="paramname">currentLayout</td><td>Image current layout.</td></tr>
    <tr><td class="paramname">baseMipLevels</td><td>Base mip map level to clear.</td></tr>
    <tr><td class="paramname">numLevels</td><td>A pointer to an array of a number of mipmap levels to clear.</td></tr>
    <tr><td class="paramname">baseArrayLayers</td><td>A pointer to an array of base array layers to clear.</td></tr>
    <tr><td class="paramname">numLayers</td><td>A pointer to an array array layers to clear.</td></tr>
    <tr><td class="paramname">numRanges</td><td>The number of elements in the baseMipLevel, numLevels, baseArrayLayers and numLayers arrays.</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a5e25c0e9893a227a4d456b7a5ccba992"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void pvrvk::impl::CommandBufferBase_::clearDepthImage </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacepvrvk.html#a0dde8112e297d1089979fbdbdcbbe0f4">Image</a> &amp;&#160;</td>
          <td class="paramname"><em>image</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>clearDepth</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint32_t&#160;</td>
          <td class="paramname"><em>baseMipLevel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint32_t&#160;</td>
          <td class="paramname"><em>numLevels</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint32_t&#160;</td>
          <td class="paramname"><em>baseArrayLayer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint32_t&#160;</td>
          <td class="paramname"><em>numLayers</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VkImageLayout&#160;</td>
          <td class="paramname"><em>layout</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Clear depth image outside of a renderpass instance.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">image</td><td>Image to clear</td></tr>
    <tr><td class="paramname">clearDepth</td><td>Clear value</td></tr>
    <tr><td class="paramname">baseMipLevel</td><td>Base mip map level to clear </td></tr>
    <tr><td class="paramname">numLevels</td><td>Number of mipmap levels to clear</td></tr>
    <tr><td class="paramname">baseArrayLayer</td><td>Base arraylayer to clear</td></tr>
    <tr><td class="paramname">numLayers</td><td>Number of array layers to clear</td></tr>
    <tr><td class="paramname">layout</td><td>Current layout of the image</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="af82e7d8c6572469f44d2a242571c2144"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void pvrvk::impl::CommandBufferBase_::clearDepthImage </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacepvrvk.html#a0dde8112e297d1089979fbdbdcbbe0f4">Image</a> &amp;&#160;</td>
          <td class="paramname"><em>image</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>clearDepth</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint32_t *&#160;</td>
          <td class="paramname"><em>baseMipLevels</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint32_t *&#160;</td>
          <td class="paramname"><em>numLevels</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint32_t *&#160;</td>
          <td class="paramname"><em>baseArrayLayers</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint32_t *&#160;</td>
          <td class="paramname"><em>numLayers</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>numRanges</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VkImageLayout&#160;</td>
          <td class="paramname"><em>layout</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Clears the depth image outside of a renderpass instance using a number of ranges.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">image</td><td>Image to clear</td></tr>
    <tr><td class="paramname">clearDepth</td><td>Clear depth value</td></tr>
    <tr><td class="paramname">baseMipLevels</td><td>A pointer to an array of base mip map levels to clear</td></tr>
    <tr><td class="paramname">numLevels</td><td>A pointer to an array of the number of mipmap levels to clear</td></tr>
    <tr><td class="paramname">baseArrayLayers</td><td>A pointer to an array of base array layers to clear</td></tr>
    <tr><td class="paramname">numLayers</td><td>A pointer to an array of the number of layers to clear</td></tr>
    <tr><td class="paramname">numRanges</td><td>A number of ranges of the stencil image to clear. This number will be used as the number of array elements in the arrays passed to baseMipLevels, numLevels, baseArrayLayers and numLayers</td></tr>
    <tr><td class="paramname">layout</td><td>Image current layout</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a4c4b67263fa0035d6793d6f5fbe85f47"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void pvrvk::impl::CommandBufferBase_::clearDepthStencilImage </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacepvrvk.html#a0dde8112e297d1089979fbdbdcbbe0f4">Image</a> &amp;&#160;</td>
          <td class="paramname"><em>image</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>clearDepth</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>clearStencil</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint32_t&#160;</td>
          <td class="paramname"><em>baseMipLevel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint32_t&#160;</td>
          <td class="paramname"><em>numLevels</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint32_t&#160;</td>
          <td class="paramname"><em>baseArrayLayer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint32_t&#160;</td>
          <td class="paramname"><em>numLayers</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VkImageLayout&#160;</td>
          <td class="paramname"><em>layout</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Clear depth stencil image outside of a renderpass instance.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">image</td><td>Image to clear</td></tr>
    <tr><td class="paramname">clearDepth</td><td>Clear depth value</td></tr>
    <tr><td class="paramname">clearStencil</td><td>Clear stencil value</td></tr>
    <tr><td class="paramname">baseMipLevel</td><td>Base mip map level to clear</td></tr>
    <tr><td class="paramname">numLevels</td><td>Number of mipmap levels to clear</td></tr>
    <tr><td class="paramname">baseArrayLayer</td><td>Base array layer to clear</td></tr>
    <tr><td class="paramname">numLayers</td><td>Number of array layers to clear</td></tr>
    <tr><td class="paramname">layout</td><td>Image current layout</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a7333520583cd3639bbe1fb0fdcbd9320"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void pvrvk::impl::CommandBufferBase_::clearDepthStencilImage </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacepvrvk.html#a0dde8112e297d1089979fbdbdcbbe0f4">Image</a> &amp;&#160;</td>
          <td class="paramname"><em>image</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>clearDepth</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>clearStencil</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint32_t *&#160;</td>
          <td class="paramname"><em>baseMipLevels</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint32_t *&#160;</td>
          <td class="paramname"><em>numLevels</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint32_t *&#160;</td>
          <td class="paramname"><em>baseArrayLayers</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint32_t *&#160;</td>
          <td class="paramname"><em>numLayers</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>numRanges</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VkImageLayout&#160;</td>
          <td class="paramname"><em>layout</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Clear depth stencil image outside of a renderpass instance using a number of ranges.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">image</td><td>Image to clear</td></tr>
    <tr><td class="paramname">clearDepth</td><td>Clear depth value</td></tr>
    <tr><td class="paramname">clearStencil</td><td>Clear stencil value</td></tr>
    <tr><td class="paramname">baseMipLevels</td><td>A pointer to an array of base mip map levels to clear</td></tr>
    <tr><td class="paramname">numLevels</td><td>A pointer to an array of the number of mipmap levels to clear</td></tr>
    <tr><td class="paramname">baseArrayLayers</td><td>A pointer to an array of base array layers to clear</td></tr>
    <tr><td class="paramname">numLayers</td><td>A pointer to an array of the number of layers to clear</td></tr>
    <tr><td class="paramname">numRanges</td><td>A number of ranges of the depth stencil image to clear. This number will be used as the number of array elements in the arrays passed to baseMipLevels, numLevels, baseArrayLayers and numLayers</td></tr>
    <tr><td class="paramname">layout</td><td>Image current layout</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a8938944ae6d1febc5e54c4db514963d4"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void pvrvk::impl::CommandBufferBase_::clearStencilImage </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacepvrvk.html#a0dde8112e297d1089979fbdbdcbbe0f4">Image</a> &amp;&#160;</td>
          <td class="paramname"><em>image</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>clearStencil</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint32_t&#160;</td>
          <td class="paramname"><em>baseMipLevel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint32_t&#160;</td>
          <td class="paramname"><em>numLevels</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint32_t&#160;</td>
          <td class="paramname"><em>baseArrayLayer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint32_t&#160;</td>
          <td class="paramname"><em>numLayers</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VkImageLayout&#160;</td>
          <td class="paramname"><em>layout</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Clears a stencil image outside of a renderpass instance.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">image</td><td>Image to clear</td></tr>
    <tr><td class="paramname">clearStencil</td><td>Clear stencil value</td></tr>
    <tr><td class="paramname">baseMipLevel</td><td>Base mip map level to clear</td></tr>
    <tr><td class="paramname">numLevels</td><td>Number of mipmap levels to clear</td></tr>
    <tr><td class="paramname">baseArrayLayer</td><td>Base array layer to clear</td></tr>
    <tr><td class="paramname">numLayers</td><td>Number of array layers to clear</td></tr>
    <tr><td class="paramname">layout</td><td>Image current layout</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a477cecb59ce2b13ce1e82340a434057e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void pvrvk::impl::CommandBufferBase_::clearStencilImage </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacepvrvk.html#a0dde8112e297d1089979fbdbdcbbe0f4">Image</a> &amp;&#160;</td>
          <td class="paramname"><em>image</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>clearStencil</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint32_t *&#160;</td>
          <td class="paramname"><em>baseMipLevels</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint32_t *&#160;</td>
          <td class="paramname"><em>numLevels</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint32_t *&#160;</td>
          <td class="paramname"><em>baseArrayLayers</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint32_t *&#160;</td>
          <td class="paramname"><em>numLayers</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>numRanges</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VkImageLayout&#160;</td>
          <td class="paramname"><em>layout</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Clear stencil image outside of a renderpass instance using a number of ranges.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">image</td><td>Image to clear</td></tr>
    <tr><td class="paramname">clearStencil</td><td>Clear stencil value</td></tr>
    <tr><td class="paramname">baseMipLevels</td><td>A pointer to an array of base mip map levels to clear</td></tr>
    <tr><td class="paramname">numLevels</td><td>A pointer to an array of the number of mipmap levels to clear</td></tr>
    <tr><td class="paramname">baseArrayLayers</td><td>A pointer to an array of base array layers to clear</td></tr>
    <tr><td class="paramname">numLayers</td><td>A pointer to an array of the number of layers to clear</td></tr>
    <tr><td class="paramname">numRanges</td><td>A number of ranges of the stencil image to clear. This number will be used as the number of array elements in the arrays passed to baseMipLevels, numLevels, baseArrayLayers and numLayers</td></tr>
    <tr><td class="paramname">layout</td><td>Image current layout</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a525433b2c0308819a0d4b1ec68a6690f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void pvrvk::impl::CommandBufferBase_::copyBuffer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacepvrvk.html#a2a117db0aab25382d050908b2bfa4c8b">Buffer</a>&#160;</td>
          <td class="paramname"><em>srcBuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacepvrvk.html#a2a117db0aab25382d050908b2bfa4c8b">Buffer</a>&#160;</td>
          <td class="paramname"><em>dstBuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>srcOffset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>dstOffset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>sizeInBytes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy Buffer</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">srcBuffer</td><td>Source buffer</td></tr>
    <tr><td class="paramname">dstBuffer</td><td>Destination buffer</td></tr>
    <tr><td class="paramname">srcOffset</td><td>Source buffer offset</td></tr>
    <tr><td class="paramname">dstOffset</td><td>Destination buffer offset</td></tr>
    <tr><td class="paramname">sizeInBytes</td><td>Size in bytes</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a377b54630f07c121e53196ee32d56a8c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void pvrvk::impl::CommandBufferBase_::copyBufferToImage </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacepvrvk.html#a2a117db0aab25382d050908b2bfa4c8b">Buffer</a> &amp;&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacepvrvk.html#a0dde8112e297d1089979fbdbdcbbe0f4">Image</a> &amp;&#160;</td>
          <td class="paramname"><em>image</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VkImageLayout&#160;</td>
          <td class="paramname"><em>dstImageLayout</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>regionsCount</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structpvrvk_1_1_buffer_image_copy.html">BufferImageCopy</a> *&#160;</td>
          <td class="paramname"><em>regions</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy buffer to image</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buffer</td><td>Source Buffer </td></tr>
    <tr><td class="paramname">image</td><td>Destination image</td></tr>
    <tr><td class="paramname">dstImageLayout</td><td>Destination image's current layout</td></tr>
    <tr><td class="paramname">regionsCount</td><td>Copy regions</td></tr>
    <tr><td class="paramname">regions</td><td>Number of regions</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a5a7f6ef1773c48cc63c66a540fb17caf"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void pvrvk::impl::CommandBufferBase_::copyImage </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacepvrvk.html#a0dde8112e297d1089979fbdbdcbbe0f4">Image</a> &amp;&#160;</td>
          <td class="paramname"><em>srcImage</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacepvrvk.html#a0dde8112e297d1089979fbdbdcbbe0f4">Image</a> &amp;&#160;</td>
          <td class="paramname"><em>dstImage</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VkImageLayout&#160;</td>
          <td class="paramname"><em>srcImageLayout</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VkImageLayout&#160;</td>
          <td class="paramname"><em>dstImageLayout</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>numRegions</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structpvrvk_1_1_image_copy.html">ImageCopy</a> *&#160;</td>
          <td class="paramname"><em>regions</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy data between Images</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">srcImage</td><td>Source image</td></tr>
    <tr><td class="paramname">dstImage</td><td>Destination image</td></tr>
    <tr><td class="paramname">srcImageLayout</td><td>Source image layout</td></tr>
    <tr><td class="paramname">dstImageLayout</td><td>Destination image layout</td></tr>
    <tr><td class="paramname">regions</td><td>Regions to copy</td></tr>
    <tr><td class="paramname">numRegions</td><td>Number of regions</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a7348f826328fc3b1822fb4ed686e773a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void pvrvk::impl::CommandBufferBase_::copyImageToBuffer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacepvrvk.html#a0dde8112e297d1089979fbdbdcbbe0f4">Image</a> &amp;&#160;</td>
          <td class="paramname"><em>srcImage</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VkImageLayout&#160;</td>
          <td class="paramname"><em>srcImageLayout</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacepvrvk.html#a2a117db0aab25382d050908b2bfa4c8b">Buffer</a> &amp;&#160;</td>
          <td class="paramname"><em>dstBuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structpvrvk_1_1_buffer_image_copy.html">BufferImageCopy</a> *&#160;</td>
          <td class="paramname"><em>regions</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>numRegions</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy image to buffer</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">srcImage</td><td>Source image to copy from</td></tr>
    <tr><td class="paramname">srcImageLayout</td><td>Current src image layout</td></tr>
    <tr><td class="paramname">dstBuffer</td><td>Destination buffer</td></tr>
    <tr><td class="paramname">regions</td><td>Regions to copy</td></tr>
    <tr><td class="paramname">numRegions</td><td>Number of regions</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a96aeb9ef8d82603dfeac45d2ff177ba2"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void pvrvk::impl::CommandBufferBase_::dispatch </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>numGroupX</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>numGroupY</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>numGroupZ</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Dispatching work provokes work in a compute pipeline. A compute pipeline must be bound to the command buffer before any dispatch commands are recorded.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">numGroupX</td><td>The number of local workgroups to dispatch in the X dimension.</td></tr>
    <tr><td class="paramname">numGroupY</td><td>The number of local workgroups to dispatch in the Y dimension.</td></tr>
    <tr><td class="paramname">numGroupZ</td><td>The number of local workgroups to dispatch in the Z dimension.</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="acb78b08d16568eeb47ffed3294d3f6e2"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void pvrvk::impl::CommandBufferBase_::dispatchIndirect </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacepvrvk.html#a2a117db0aab25382d050908b2bfa4c8b">Buffer</a> &amp;&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>offset</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Dispatching work provokes work in a compute pipeline. A compute pipeline must be bound to the command buffer before any dispatch commands are recorded. dispatchIndirect behaves similarly to dispatch except that the parameters are read by the device from a buffer during execution. The parameters of the dispatch are encoded in a VkDispatchIndirectCommand structure taken from buffer starting at offset</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buffer</td><td>The buffer containing dispatch parameters.</td></tr>
    <tr><td class="paramname">offset</td><td>The byte offset into buffer where parameters begin.</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a4a38f7566ddeb086f6aa546ee3311288"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void pvrvk::impl::CommandBufferBase_::draw </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>firstVertex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>numVertices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>firstInstance</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>numInstances</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Non-indexed drawing command.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">firstVertex</td><td>The index of the first vertex to draw.</td></tr>
    <tr><td class="paramname">numVertices</td><td>The number of vertices to draw.</td></tr>
    <tr><td class="paramname">firstInstance</td><td>The instance ID of the first instance to draw.</td></tr>
    <tr><td class="paramname">numInstances</td><td>The number of instances to draw.</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a9d0dd5fece38c2da3f474f302f70eba8"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void pvrvk::impl::CommandBufferBase_::drawIndexed </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>firstIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>numIndices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>vertexOffset</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>firstInstance</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>numInstances</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Indexed drawing command.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">firstIndex</td><td>The base index within the index buffer.</td></tr>
    <tr><td class="paramname">numIndices</td><td>The number of vertices to draw.</td></tr>
    <tr><td class="paramname">vertexOffset</td><td>The value added to the vertex index before indexining into the vertex buffer.</td></tr>
    <tr><td class="paramname">firstInstance</td><td>The instance ID of the first instance to draw.</td></tr>
    <tr><td class="paramname">numInstances</td><td>The number of instances to draw.</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a2da4e6e18ae17379fd66ae6a7e3d3eb7"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void pvrvk::impl::CommandBufferBase_::drawIndexedIndirect </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacepvrvk.html#a2a117db0aab25382d050908b2bfa4c8b">Buffer</a> &amp;&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>stride</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Non-indexed indirect drawing command.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buffer</td><td>The buffer containing draw parameters.</td></tr>
    <tr><td class="paramname">offset</td><td>The byte offset into buffer where parameters begin.</td></tr>
    <tr><td class="paramname">count</td><td>The number of draws to execute.</td></tr>
    <tr><td class="paramname">stride</td><td>The byte stride between successive sets of draw commands.</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a38db7b68a0aafa77bc03b5f199843b6c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void pvrvk::impl::CommandBufferBase_::drawIndirect </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacepvrvk.html#a2a117db0aab25382d050908b2bfa4c8b">Buffer</a> &amp;&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>stride</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Non-indexed indirect drawing command.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buffer</td><td>The buffer containing draw parameters.</td></tr>
    <tr><td class="paramname">offset</td><td>The byte offset into buffer where parameters begin.</td></tr>
    <tr><td class="paramname">count</td><td>The number of draws to execute.</td></tr>
    <tr><td class="paramname">stride</td><td>The byte stride between successive sets of draw commands.</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a571250974bf01a908011ca732dbb74d7"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void pvrvk::impl::CommandBufferBase_::end </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Call this function when you are done recording commands. BeginRecording must be called first. </p>

</div>
</div>
<a class="anchor" id="a56e3f2184eeb8f9aadaa631c1338179b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void pvrvk::impl::CommandBufferBase_::fillBuffer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacepvrvk.html#a2a117db0aab25382d050908b2bfa4c8b">Buffer</a>&#160;</td>
          <td class="paramname"><em>dstBuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>dstOffset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>size</em> = <code>VK_WHOLE_SIZE</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Clear buffer data</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dstBuffer</td><td>Destination buffer to be filled</td></tr>
    <tr><td class="paramname">dstOffset</td><td>The byte offset into the buffer at which to start filling.</td></tr>
    <tr><td class="paramname">data</td><td>A 4-byte word written repeatedly to the buffer to fill size bytes of data. The data word is written to memory according to the host endianness.</td></tr>
    <tr><td class="paramname">size</td><td>The number of bytes to fill, and must be either a multiple of 4, or VK_WHOLE_SIZE to fill the range from offset to the end of the buffer</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="afbec4fbcfddbaff8fa39c6abf03f21f8"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="namespacepvrvk.html#ac9949394db8b3d968a7402b837567f87">CommandPool</a>&amp; pvrvk::impl::CommandBufferBase_::getCommandPool </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Const getter for the command pool used to allocate this command buffer.</p>
<dl class="section return"><dt>Returns</dt><dd>The command pool used to allocate this command buffer.</dd></dl>

</div>
</div>
<a class="anchor" id="a54e2c4a1abb377258b09261677deda20"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacepvrvk.html#a8dd5932a80187b088ce6b591712dc2c2">DeviceWeakPtr</a> pvrvk::impl::CommandBufferBase_::getDevice </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get weak a reference to the device which was used to create this CommandBuffer.</p>
<dl class="section return"><dt>Returns</dt><dd>A weak reference to the device which was used to create this CommandBuffer.</dd></dl>

</div>
</div>
<a class="anchor" id="ab9987985cff04d01121c6cbb8221487f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">VkCommandBuffer&amp; pvrvk::impl::CommandBufferBase_::getNativeObject </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Getter for this command buffers vulkan handle.</p>
<dl class="section return"><dt>Returns</dt><dd>The vulkan handle of this command buffer.</dd></dl>

</div>
</div>
<a class="anchor" id="a1bec22ca816d4c36fb11d5fa43ef65ac"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const VkCommandBuffer&amp; pvrvk::impl::CommandBufferBase_::getNativeObject </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Const getter for this command buffers vulkan handle.</p>
<dl class="section return"><dt>Returns</dt><dd>The vulkan handle of this command buffer.</dd></dl>

</div>
</div>
<a class="anchor" id="a0f32e4b0b8899d01ff783456befcb5b9"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool pvrvk::impl::CommandBufferBase_::isRecording </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Queries if a command buffer is in the recording state</p>
<dl class="section return"><dt>Returns</dt><dd>True if recording, false otherwise</dd></dl>

</div>
</div>
<a class="anchor" id="a79917bf8d77bb0d5d2a43aa9654eb5cc"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void pvrvk::impl::CommandBufferBase_::pipelineBarrier </td>
          <td>(</td>
          <td class="paramtype">VkPipelineStageFlags&#160;</td>
          <td class="paramname"><em>srcStage</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VkPipelineStageFlags&#160;</td>
          <td class="paramname"><em>dstStage</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classpvrvk_1_1_memory_barrier_set.html">MemoryBarrierSet</a> &amp;&#160;</td>
          <td class="paramname"><em>barriers</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>dependencyByRegion</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Add a memory barrier to the command stream, forcing preceeding commands to be written before succeeding commands are executed.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">srcStage</td><td>A bitmask of VkPipelineStageFlags specifying the src stage mask.</td></tr>
    <tr><td class="paramname">dstStage</td><td>A bitmask of VkPipelineStageFlags specifying the dst stage mask.</td></tr>
    <tr><td class="paramname">barriers</td><td>A set of memory barriers to be used in the pipeline barrier.</td></tr>
    <tr><td class="paramname">dependencyByRegion</td><td>A bitmask of VkDependencyFlags specifying how the execution and memory dependencies are formed.</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a450ff6f0132701950130b984f1f2cf41"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void pvrvk::impl::CommandBufferBase_::pushConstants </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacepvrvk.html#a34bb21497524a13e145b1398450989d0">PipelineLayout</a> &amp;&#160;</td>
          <td class="paramname"><em>pipelineLayout</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VkShaderStageFlags&#160;</td>
          <td class="paramname"><em>stageFlags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Updates the value of shader push constants at the offset specified.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pipelineLayout</td><td>The pipeline layout used to program the push constant updates.</td></tr>
    <tr><td class="paramname">stageFlags</td><td>A bitmask of VkShaderStageFlag specifying the shader stages that will use the push constants in the updated range.</td></tr>
    <tr><td class="paramname">offset</td><td>The start offset of the push constant range to update, in units of bytes.</td></tr>
    <tr><td class="paramname">size</td><td>The size of the push constant range to update, in units of bytes.</td></tr>
    <tr><td class="paramname">data</td><td>An array of size bytes containing the new push constant values.</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ac7a619081148516d5bfecd9ef11588b2"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void pvrvk::impl::CommandBufferBase_::resetEvent </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacepvrvk.html#a6696a17453f99f2b221a28bb05e4934b">Event</a> &amp;&#160;</td>
          <td class="paramname"><em>event</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VkPipelineStageFlags&#160;</td>
          <td class="paramname"><em>pipelineStageFlags</em> = <code>VkPipelineStageFlags::e_ALL_COMMANDS_BIT</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Defines an execution dependency on commands that were submitted before it, and defines an event unsignal operation which resets the event to the unsignaled state.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">event</td><td>The event object that will be unsignaled.</td></tr>
    <tr><td class="paramname">pipelineStageFlags</td><td>Is a bitmask of VkPipelineStageFlags specifying the src stage mask used to determine when the event is unsignaled.</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="adbf21794fa62a0c0183978806be8ed2f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void pvrvk::impl::CommandBufferBase_::resolveImage </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacepvrvk.html#a0dde8112e297d1089979fbdbdcbbe0f4">Image</a> &amp;&#160;</td>
          <td class="paramname"><em>srcImage</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacepvrvk.html#a0dde8112e297d1089979fbdbdcbbe0f4">Image</a> &amp;&#160;</td>
          <td class="paramname"><em>dstImage</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structpvrvk_1_1_image_resolve.html">ImageResolve</a> *&#160;</td>
          <td class="paramname"><em>regions</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>numRegions</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VkImageLayout&#160;</td>
          <td class="paramname"><em>srcLayout</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VkImageLayout&#160;</td>
          <td class="paramname"><em>dstLayout</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copies regions of a src image into a dst image, potentially also performing format conversions, aritrary scaling and filtering.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">srcImage</td><td>The src Image in the copy.</td></tr>
    <tr><td class="paramname">dstImage</td><td>The dst image.</td></tr>
    <tr><td class="paramname">regions</td><td>A pointer to an array of <a class="el" href="structpvrvk_1_1_image_blit_range.html" title="Represents a blit operation through source and destination offsets">ImageBlitRange</a> structures specifying the regions to blit.</td></tr>
    <tr><td class="paramname">numRegions</td><td>The number of regions to blit.</td></tr>
    <tr><td class="paramname">srcLayout</td><td>The layout of the src image subresrcs for the blit.</td></tr>
    <tr><td class="paramname">dstLayout</td><td>The layout of the dst image subresrcs for the blit.</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a9ce2c215aa9814e5e8aa02f679f9fa24"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void pvrvk::impl::CommandBufferBase_::setBlendConstants </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>rgba</em>[4]</td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the dynamic blend constant bias state affecting pipeline objects created with VK_DYNAMIC_STATE_BLEND_CONSTANTS enabled.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rgba</td><td>An array of four values specifying the R, G, B, and A components of the blend constant color used in blending, depending on the blend factor</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a486a9d46e8f693398db0dc03fede5fb6"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void pvrvk::impl::CommandBufferBase_::setDepthBias </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>constantFactor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>clamp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>slopeFactor</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the dynamic depth bias state affecting pipeline objects created where depthBiasEnable is enabled.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">constantFactor</td><td>A scalar factor controlling the constant depth value added to each fragment.</td></tr>
    <tr><td class="paramname">clamp</td><td>The maximum (or minimum) depth bias of a fragment.</td></tr>
    <tr><td class="paramname">slopeFactor</td><td>A scalar factor applied to a fragments slope in depth bias calculations.</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ae41e1a87d69f9f3476ea6e20037b9b00"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void pvrvk::impl::CommandBufferBase_::setDepthBounds </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>min</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>max</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the dynamic depth bounds state affecting pipeline objects created with VK_DYNAMIC_STATE_DEPTH_BOUNDS enabled.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">min</td><td>The lower bound of the range of depth values used in the depth bounds test.</td></tr>
    <tr><td class="paramname">max</td><td>The upper bound of the range.</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a1a6c05f7450a1d1d925cb07787b8305a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void pvrvk::impl::CommandBufferBase_::setEvent </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacepvrvk.html#a6696a17453f99f2b221a28bb05e4934b">Event</a> &amp;&#160;</td>
          <td class="paramname"><em>event</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VkPipelineStageFlags&#160;</td>
          <td class="paramname"><em>pipelineStageFlags</em> = <code>VkPipelineStageFlags::e_ALL_COMMANDS_BIT</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Defines an execution dependency on commands that were submitted before it, and defines an event signal operation which sets the event to the signaled state.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">event</td><td>The event object that will be signaled.</td></tr>
    <tr><td class="paramname">pipelineStageFlags</td><td>Specifies the src stage mask used to determine when the event is signaled.</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a6e36ba62ffb95e3a6fd71aa415542391"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void pvrvk::impl::CommandBufferBase_::setLineWidth </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>lineWidth</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the dynamic line width state affecting pipeline objects created with VK_DYNAMIC_STATE_LINE_WIDTH enabled.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lineWidth</td><td>The width of rasterized line segments.</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a55552c7dc09c30e96cd91a09b04c14fe"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void pvrvk::impl::CommandBufferBase_::setScissor </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>firstScissor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>numScissors</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structpvrvk_1_1_rect2_di.html">Rect2Di</a> *&#160;</td>
          <td class="paramname"><em>scissors</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the dynamic scissor state affecting pipeline objects created with VK_DYNAMIC_STATE_SCISSOR enabled.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">firstScissor</td><td>The index of the first scissor whose state is updated.</td></tr>
    <tr><td class="paramname">numScissors</td><td>The number of scissors whose rectangles are updated.</td></tr>
    <tr><td class="paramname">scissors</td><td>A pointer to an array of VkRect2D structures defining scissor rectangles.</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ad983598915f237dd07e8b99736e06fb6"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void pvrvk::impl::CommandBufferBase_::setStencilCompareMask </td>
          <td>(</td>
          <td class="paramtype">VkStencilFaceFlags&#160;</td>
          <td class="paramname"><em>face</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>compareMask</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the dynamic stencil compare mask state affecting pipeline objects created with VK_DYNAMIC_STATE_STENCIL_COMPARE_MASK enabled.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">face</td><td>A bitmask of VkStencilFaceFlags specifying the set of stencil state for which to update the compare mask.</td></tr>
    <tr><td class="paramname">compareMask</td><td>The new value to use as the stencil compare value.</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a8bf69dcfe53aed66cdfed3d83e450966"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void pvrvk::impl::CommandBufferBase_::setStencilReference </td>
          <td>(</td>
          <td class="paramtype">VkStencilFaceFlags&#160;</td>
          <td class="paramname"><em>face</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>reference</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the dynamic stencil reference mask state affecting pipeline objects created with VK_DYNAMIC_STATE_STENCIL_REFERENCE enabled.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">face</td><td>A bitmask of VkStencilFaceFlags specifying the set of stencil state for which to update the reference value.</td></tr>
    <tr><td class="paramname">reference</td><td>The new value to use as the stencil reference value.</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ae21c88d1469550959a7dab962362f493"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void pvrvk::impl::CommandBufferBase_::setStencilWriteMask </td>
          <td>(</td>
          <td class="paramtype">VkStencilFaceFlags&#160;</td>
          <td class="paramname"><em>face</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>writeMask</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the dynamic stencil write mask state affecting pipeline objects created with VK_DYNAMIC_STATE_STENCIL_WRITE_MASK enabled.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">face</td><td>A bitmask of VkStencilFaceFlags specifying the set of stencil state for which to update the write mask.</td></tr>
    <tr><td class="paramname">writeMask</td><td>The new value to use as the stencil write mask</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a8b850bccfeda750ecb9e2c98c8c2b018"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void pvrvk::impl::CommandBufferBase_::setViewport </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structpvrvk_1_1_viewport.html">Viewport</a> &amp;&#160;</td>
          <td class="paramname"><em>viewport</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set viewport</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">viewport</td><td><a class="el" href="structpvrvk_1_1_viewport.html" title="Viewport specifes the drawing region, min and max depth. The viewport region x and y starts bottom le...">Viewport</a></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a9ec18d08b6609a9078a081fa31f3ce77"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void pvrvk::impl::CommandBufferBase_::updateBuffer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacepvrvk.html#a2a117db0aab25382d050908b2bfa4c8b">Buffer</a> &amp;&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Updates buffer data inline in a command buffer. The update is only allowed outside of a renderpass and is treated as a transfer operation for the purposes of syncrhonization.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buffer</td><td>The buffer to be updated.</td></tr>
    <tr><td class="paramname">data</td><td>A pointer to the src data for the buffer update. The data must be at least length bytes in size.</td></tr>
    <tr><td class="paramname">offset</td><td>The byte offset into the buffer to start updating, and must be a multiple of 4.</td></tr>
    <tr><td class="paramname">length</td><td>The number of bytes to update, and must be a multiple of 4.</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a50b272c0a71f01ce4f8734ba15605456"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void pvrvk::impl::CommandBufferBase_::waitForEvent </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacepvrvk.html#a6696a17453f99f2b221a28bb05e4934b">Event</a> &amp;&#160;</td>
          <td class="paramname"><em>event</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VkPipelineStageFlags&#160;</td>
          <td class="paramname"><em>srcStage</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VkPipelineStageFlags&#160;</td>
          <td class="paramname"><em>dstStage</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classpvrvk_1_1_memory_barrier_set.html">MemoryBarrierSet</a> &amp;&#160;</td>
          <td class="paramname"><em>barriers</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Defines a memory dependency between prior event signal operations and subsequent commands.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">event</td><td>The event object to wait on.</td></tr>
    <tr><td class="paramname">srcStage</td><td>A bitmask of VkPipelineStageFlags specifying the src stage mask.</td></tr>
    <tr><td class="paramname">dstStage</td><td>A bitmask of VkPipelineStageFlags specifying the dst stage mask.</td></tr>
    <tr><td class="paramname">barriers</td><td>A set of memory barriers to be used in the pipeline barrier.</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ad3245f9af726e52e6a611c4cabf12289"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void pvrvk::impl::CommandBufferBase_::waitForEvents </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacepvrvk.html#a6696a17453f99f2b221a28bb05e4934b">Event</a> *&#160;</td>
          <td class="paramname"><em>events</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>numEvents</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VkPipelineStageFlags&#160;</td>
          <td class="paramname"><em>srcStage</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VkPipelineStageFlags&#160;</td>
          <td class="paramname"><em>dstStage</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classpvrvk_1_1_memory_barrier_set.html">MemoryBarrierSet</a> &amp;&#160;</td>
          <td class="paramname"><em>barriers</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Defines a set of memory dependencies between prior event signal operations and subsequent commands.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">events</td><td>A pointer to an array of Event objects to wait on.</td></tr>
    <tr><td class="paramname">numEvents</td><td>The number of event objects to wait on.</td></tr>
    <tr><td class="paramname">srcStage</td><td>A bitmask of VkPipelineStageFlags specifying the src stage mask.</td></tr>
    <tr><td class="paramname">dstStage</td><td>A bitmask of VkPipelineStageFlags specifying the dst stage mask.</td></tr>
    <tr><td class="paramname">barriers</td><td>A set of .</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a class="anchor" id="a86e1b4cc6a21665d524d41e661036e99"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacepvrvk.html#a8dd5932a80187b088ce6b591712dc2c2">DeviceWeakPtr</a> pvrvk::impl::CommandBufferBase_::_device</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The device used to create this command buffer.</p>

</div>
</div>
<a class="anchor" id="a759e4e7ca81cb8812048075ddcf274d6"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool pvrvk::impl::CommandBufferBase_::_isRecording</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Specifies whether the command buffer is currently in the recording state which is controlled via calling the begin function.</p>

</div>
</div>
<a class="anchor" id="a943d27103dec9450a0966c8352aef979"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacepvrvk.html#a946a7145c9e18b9a797fa714ce677f32">ComputePipeline</a> pvrvk::impl::CommandBufferBase_::_lastBoundComputePipe</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Holds a reference to the last bound compute pipeline. This can then be used for optimising binding the same compute pipeline repeatedly.</p>

</div>
</div>
<a class="anchor" id="aa0f1be52e5e2affe2a3f57ea68a8d036"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacepvrvk.html#aa2443b681960df638797cf93bbf33fb7">GraphicsPipeline</a> pvrvk::impl::CommandBufferBase_::_lastBoundGraphicsPipe</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Holds a reference to the last bound graphics pipeline. This can then be used for optimising binding the same graphics pipeline repeatedly.</p>

</div>
</div>
<a class="anchor" id="a2c87869144c258a576df247c3555252d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;RefCountedResource&lt;void&gt;&gt; pvrvk::impl::CommandBufferBase_::_objectReferences</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Holds a list of references to the objects currently in use by this command buffer. This ensures that objects are kept alive through reference counting until the command buffer is finished with them.</p>

</div>
</div>
<a class="anchor" id="adb4cc024978587b241ae65a8541d5815"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacepvrvk.html#ac9949394db8b3d968a7402b837567f87">CommandPool</a> pvrvk::impl::CommandBufferBase_::_pool</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The command pool from which this command buffer was allocated.</p>

</div>
</div>
<a class="anchor" id="a7906881f09d2e7f2a137438771f53377"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">VkCommandBuffer pvrvk::impl::CommandBufferBase_::_vkCmdBuffer</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The Vulkan handle for this command buffer.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>/usr/buildxl/buildroot/sdk/branch/Framework/PVRVk/<a class="el" href="_command_buffer_vk_8h_source.html">CommandBufferVk.h</a></li>
</ul>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.8.4-->
<!-- start footer part (NON TREEVIEW ONLY!!) -->
<!--BEGIN GENERATE_TREEVIEW-->
<div id="FooterMainContainer">
	<div id="FooterContainer">
		<div class="footerlogo">
			<a href="http://www.imgtec.com" target="_blank"><img src="img-footer-logo-grey.png" width="100%" height="100%" border="none" /></a>
		</div>
		<div class="copyright"><p>&copy; Imagination Technologies Limited<br> All rights reserved</p></div>
	</div>
</div>
</body>
</html>
