<!-- HTML header for doxygen 1.8.4-->
<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="generator" content="Doxygen 1.8.4"/>
<title>PVRAssets: pvr::assets::TextureHeader Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="IMGdoxygen.css" rel="stylesheet" type="text/css"/>
<link rel="shortcut icon" href="http://www.imgtec.com/images/img.ico">
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
  <div class="headercontent">
    <div class="PVRlogo">
      <a href="http://www.powervrinsider.com" target="_blank"><img src="PVRlogo.png" width="40%" height="40%" border="none"/></a>
    </div>
    <a class="SiteTitle"><span id="projectname">PVRAssets</span> Documentation</a>
   <tbody>
  </div>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.4 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="inherits.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Macros</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(10)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacepvr.html">pvr</a></li><li class="navelem"><a class="el" href="namespacepvr_1_1assets.html">assets</a></li><li class="navelem"><a class="el" href="classpvr_1_1assets_1_1_texture_header.html">TextureHeader</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> &#124;
<a href="classpvr_1_1assets_1_1_texture_header-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">pvr::assets::TextureHeader Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>A class mirroring the PVR <a class="el" href="classpvr_1_1assets_1_1_texture.html" title="A 2D Texture asset, together with Information, Metadata and actual Pixel data. Only represents the ac...">Texture</a> container format header, and which can in general represent any <a class="el" href="classpvr_1_1assets_1_1_texture.html" title="A 2D Texture asset, together with Information, Metadata and actual Pixel data. Only represents the ac...">Texture</a> asset. Contains accessors functions to facilitate using the <a class="el" href="classpvr_1_1assets_1_1_texture.html" title="A 2D Texture asset, together with Information, Metadata and actual Pixel data. Only represents the ac...">Texture</a> data in application code.  
 <a href="classpvr_1_1assets_1_1_texture_header.html#details">More...</a></p>
<div class="dynheader">
Inheritance diagram for pvr::assets::TextureHeader:</div>
<div class="dyncontent">
<div class="center"><img src="classpvr_1_1assets_1_1_texture_header__inherit__graph.png" border="0" usemap="#pvr_1_1assets_1_1_texture_header_inherit__map" alt="Inheritance graph"/></div>
<map name="pvr_1_1assets_1_1_texture_header_inherit__map" id="pvr_1_1assets_1_1_texture_header_inherit__map">
<area shape="rect" id="node2" href="classpvr_1_1assets_1_1_texture.html" title="A 2D Texture asset, together with Information, Metadata and actual Pixel data. Only represents the ac..." alt="" coords="5,88,141,115"/>
<area shape="rect" id="node3" href="classpvr_1_1assets_1_1_texture_header_with_meta_data.html" title="This class contains all information a texture has (size, format etc.) and any metadata it may carry..." alt="" coords="166,81,343,122"/>
</map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpvr_1_1assets_1_1_texture_header_1_1_header.html">Header</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This header stores everything that you would ever need to load (but not necessarily use) a texture's data accurately, but no more. Data that is provided but is not needed to read the data is stored in the Metadata section (See TextureHeaderWithMetadata). Correct use of the texture may rely on meta data, but accurate data loading can be done through the standard header alone.  <a href="structpvr_1_1assets_1_1_texture_header_1_1_header.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a65c71b3903ebc6d5ef561ed68feca7b3"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1assets_1_1_texture_header.html#a65c71b3903ebc6d5ef561ed68feca7b3">TextureHeader</a> ()</td></tr>
<tr class="memdesc:a65c71b3903ebc6d5ef561ed68feca7b3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default constructor for a <a class="el" href="classpvr_1_1assets_1_1_texture_header.html" title="A class mirroring the PVR Texture container format header, and which can in general represent any Tex...">TextureHeader</a>. Returns an empty header.  <a href="#a65c71b3903ebc6d5ef561ed68feca7b3">More...</a><br/></td></tr>
<tr class="separator:a65c71b3903ebc6d5ef561ed68feca7b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd5fec67b112e803290a5dbbae2f341a"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1assets_1_1_texture_header.html#abd5fec67b112e803290a5dbbae2f341a">TextureHeader</a> (const <a class="el" href="classpvr_1_1assets_1_1_texture_header.html">TextureHeader</a> &amp;rhs)</td></tr>
<tr class="memdesc:abd5fec67b112e803290a5dbbae2f341a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy constructor.  <a href="#abd5fec67b112e803290a5dbbae2f341a">More...</a><br/></td></tr>
<tr class="separator:abd5fec67b112e803290a5dbbae2f341a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a14ad724d7cb3bb45741a31cd1676fc7c"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1assets_1_1_texture_header.html#a14ad724d7cb3bb45741a31cd1676fc7c">TextureHeader</a> (<a class="el" href="structpvr_1_1assets_1_1_texture_header_1_1_header.html">Header</a> &amp;header)</td></tr>
<tr class="memdesc:a14ad724d7cb3bb45741a31cd1676fc7c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct this from the given file header.  <a href="#a14ad724d7cb3bb45741a31cd1676fc7c">More...</a><br/></td></tr>
<tr class="separator:a14ad724d7cb3bb45741a31cd1676fc7c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad798e9be66154840ce572e7a6c11523c"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1assets_1_1_texture_header.html#ad798e9be66154840ce572e7a6c11523c">TextureHeader</a> (<a class="el" href="structpvr_1_1assets_1_1_texture_header_1_1_header.html">Header</a> fileHeader, uint32 metaDataCount, <a class="el" href="classpvr_1_1assets_1_1_texture_meta_data.html">TextureMetaData</a> *metaData)</td></tr>
<tr class="memdesc:ad798e9be66154840ce572e7a6c11523c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct this from file header and meta data.  <a href="#ad798e9be66154840ce572e7a6c11523c">More...</a><br/></td></tr>
<tr class="separator:ad798e9be66154840ce572e7a6c11523c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a898f6f25951b3b57a64d20e4828ebb"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1assets_1_1_texture_header.html#a5a898f6f25951b3b57a64d20e4828ebb">TextureHeader</a> (<a class="el" href="classpvr_1_1_pixel_format.html">PixelFormat</a> pixelFormat, uint32 width, uint32 height, uint32 depth=1, uint32 mipMapCount=1, ColorSpace::Enum colorSpace=ColorSpace::lRGB, <a class="el" href="namespacepvr_1_1_variable_type.html#a82d3ceaf1b4b315cd1ab51824a78b632">VariableType::Enum</a> channelType=<a class="el" href="namespacepvr_1_1_variable_type.html#a82d3ceaf1b4b315cd1ab51824a78b632a984876a9a95310c1f27dbbc69512cb6b">VariableType::UnsignedByteNorm</a>, uint32 numberOfSurfaces=1, uint32 numberOfFaces=1, uint32 flags=0, <a class="el" href="classpvr_1_1assets_1_1_texture_meta_data.html">TextureMetaData</a> *metaData=NULL, uint32 metaDataSize=0)</td></tr>
<tr class="memdesc:a5a898f6f25951b3b57a64d20e4828ebb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor.  <a href="#a5a898f6f25951b3b57a64d20e4828ebb">More...</a><br/></td></tr>
<tr class="separator:a5a898f6f25951b3b57a64d20e4828ebb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad967120d23991f749b9b876f3ad36598"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1assets_1_1_texture_header.html#ad967120d23991f749b9b876f3ad36598">addMetaData</a> (const <a class="el" href="classpvr_1_1assets_1_1_texture_meta_data.html">TextureMetaData</a> &amp;metaData)</td></tr>
<tr class="memdesc:ad967120d23991f749b9b876f3ad36598"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds an arbitrary piece of meta data.  <a href="#ad967120d23991f749b9b876f3ad36598">More...</a><br/></td></tr>
<tr class="separator:ad967120d23991f749b9b876f3ad36598"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad1b5489ed47de45d350ca786729d283b"><td class="memItemLeft" align="right" valign="top">uint32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1assets_1_1_texture_header.html#ad1b5489ed47de45d350ca786729d283b">getBitsPerPixel</a> () const </td></tr>
<tr class="separator:ad1b5489ed47de45d350ca786729d283b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe2c0211848d38728a14154d76ca9325"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacepvr_1_1_variable_type.html#a82d3ceaf1b4b315cd1ab51824a78b632">VariableType::Enum</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1assets_1_1_texture_header.html#afe2c0211848d38728a14154d76ca9325">getChannelType</a> () const </td></tr>
<tr class="memdesc:afe2c0211848d38728a14154d76ca9325"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the channel type that the texture's data is stored in.  <a href="#afe2c0211848d38728a14154d76ca9325">More...</a><br/></td></tr>
<tr class="separator:afe2c0211848d38728a14154d76ca9325"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abce36cfc298d5136b79fcaaeabd38fe3"><td class="memItemLeft" align="right" valign="top">ColorSpace::Enum&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1assets_1_1_texture_header.html#abce36cfc298d5136b79fcaaeabd38fe3">getColorSpace</a> () const </td></tr>
<tr class="memdesc:abce36cfc298d5136b79fcaaeabd38fe3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the color space of the texture.  <a href="#abce36cfc298d5136b79fcaaeabd38fe3">More...</a><br/></td></tr>
<tr class="separator:abce36cfc298d5136b79fcaaeabd38fe3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d1a894abf399bb3f3f3703f8a27beaf"><td class="memItemLeft" align="right" valign="top">const std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1assets_1_1_texture_header.html#a5d1a894abf399bb3f3f3703f8a27beaf">getCubeMapOrder</a> () const </td></tr>
<tr class="memdesc:a5d1a894abf399bb3f3f3703f8a27beaf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the cube map face order.  <a href="#a5d1a894abf399bb3f3f3703f8a27beaf">More...</a><br/></td></tr>
<tr class="separator:a5d1a894abf399bb3f3f3703f8a27beaf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a54643ce3775b8f342f6a2ad83106e3f4"><td class="memItemLeft" align="right" valign="top">ptrdiff_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1assets_1_1_texture_header.html#a54643ce3775b8f342f6a2ad83106e3f4">getDataOffset</a> (uint32 mipMapLevel=0, uint32 arrayMember=0, uint32 face=0) const </td></tr>
<tr class="memdesc:a54643ce3775b8f342f6a2ad83106e3f4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a offset in the data.  <a href="#a54643ce3775b8f342f6a2ad83106e3f4">More...</a><br/></td></tr>
<tr class="separator:a54643ce3775b8f342f6a2ad83106e3f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a42529af539b3570fbcc651c6a9c92238"><td class="memItemLeft" align="right" valign="top">uint32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1assets_1_1_texture_header.html#a42529af539b3570fbcc651c6a9c92238">getDataSize</a> (int32 mipLevel=c_pvrTextureAllMIPMaps, bool allSurfaces=true, bool allFaces=true) const </td></tr>
<tr class="memdesc:a42529af539b3570fbcc651c6a9c92238"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the size in BYTES of the texture, given various input parameters.  <a href="#a42529af539b3570fbcc651c6a9c92238">More...</a><br/></td></tr>
<tr class="separator:a42529af539b3570fbcc651c6a9c92238"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a5beec8e0059d71a8225c6773b96352"><td class="memItemLeft" align="right" valign="top">uint32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1assets_1_1_texture_header.html#a4a5beec8e0059d71a8225c6773b96352">getDepth</a> (uint32 mipLevel=c_pvrTextureTopMIPMap) const </td></tr>
<tr class="separator:a4a5beec8e0059d71a8225c6773b96352"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a83693e94d6af18da907ef496903cff17"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1assets_1_1_texture_header.html#a83693e94d6af18da907ef496903cff17">getDirect3DFormat</a> (uint32 &amp;outD3dFormat) const </td></tr>
<tr class="memdesc:a83693e94d6af18da907ef496903cff17"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the Direct3D equivalent format enumeration for this texture.  <a href="#a83693e94d6af18da907ef496903cff17">More...</a><br/></td></tr>
<tr class="separator:a83693e94d6af18da907ef496903cff17"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef946cf89b0730669b1ecb4b5003fbb0"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1assets_1_1_texture_header.html#aef946cf89b0730669b1ecb4b5003fbb0">getDirectXGIFormat</a> (uint32 &amp;outDxgiFormat, bool &amp;notAlpha) const </td></tr>
<tr class="memdesc:aef946cf89b0730669b1ecb4b5003fbb0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the DirectXGI equivalent format enumeration for this texture.  <a href="#aef946cf89b0730669b1ecb4b5003fbb0">More...</a><br/></td></tr>
<tr class="separator:aef946cf89b0730669b1ecb4b5003fbb0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad1566dc62e49e5bc3dffce1d0ef1ce7b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structpvr_1_1assets_1_1_texture_header_1_1_header.html">Header</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1assets_1_1_texture_header.html#ad1566dc62e49e5bc3dffce1d0ef1ce7b">getFileHeader</a> () const </td></tr>
<tr class="memdesc:ad1566dc62e49e5bc3dffce1d0ef1ce7b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the file header structure.  <a href="#ad1566dc62e49e5bc3dffce1d0ef1ce7b">More...</a><br/></td></tr>
<tr class="separator:ad1566dc62e49e5bc3dffce1d0ef1ce7b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a239c9927fb8f2ee7e8e74e8bea27117c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structpvr_1_1assets_1_1_texture_header_1_1_header.html">Header</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1assets_1_1_texture_header.html#a239c9927fb8f2ee7e8e74e8bea27117c">getFileHeaderAccess</a> ()</td></tr>
<tr class="memdesc:a239c9927fb8f2ee7e8e74e8bea27117c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the file header access.  <a href="#a239c9927fb8f2ee7e8e74e8bea27117c">More...</a><br/></td></tr>
<tr class="separator:a239c9927fb8f2ee7e8e74e8bea27117c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ed7376ba257c1e4c14ca4cb5b18169d"><td class="memItemLeft" align="right" valign="top">uint32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1assets_1_1_texture_header.html#a8ed7376ba257c1e4c14ca4cb5b18169d">getHeight</a> (uint32 uiMipLevel=c_pvrTextureTopMIPMap) const </td></tr>
<tr class="separator:a8ed7376ba257c1e4c14ca4cb5b18169d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a54aed1c9b68bc68ed126aee17e8a6b8c"><td class="memItemLeft" align="right" valign="top">const std::map&lt; uint32, <br class="typebreak"/>
std::map&lt; uint32, <br class="typebreak"/>
<a class="el" href="classpvr_1_1assets_1_1_texture_meta_data.html">TextureMetaData</a> &gt; &gt; *const&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1assets_1_1_texture_header.html#a54aed1c9b68bc68ed126aee17e8a6b8c">getMetaDataMap</a> () const </td></tr>
<tr class="memdesc:a54aed1c9b68bc68ed126aee17e8a6b8c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a pointer directly to the Meta Data Map, to allow users to read out data.  <a href="#a54aed1c9b68bc68ed126aee17e8a6b8c">More...</a><br/></td></tr>
<tr class="separator:a54aed1c9b68bc68ed126aee17e8a6b8c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afae4e0671acd51eb785ef58804e7a05a"><td class="memItemLeft" align="right" valign="top">uint32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1assets_1_1_texture_header.html#afae4e0671acd51eb785ef58804e7a05a">getMetaDataSize</a> () const </td></tr>
<tr class="memdesc:afae4e0671acd51eb785ef58804e7a05a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the total size of the meta data stored in the header. This includes the size of all information stored in all CPVRMetaDataBlocks.  <a href="#afae4e0671acd51eb785ef58804e7a05a">More...</a><br/></td></tr>
<tr class="separator:afae4e0671acd51eb785ef58804e7a05a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40d9d589409abb8c2f3b66ad6d999641"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1assets_1_1_texture_header.html#a40d9d589409abb8c2f3b66ad6d999641">getMinDimensionsForFormat</a> (uint32 &amp;minX, uint32 &amp;minY, uint32 &amp;minZ) const </td></tr>
<tr class="memdesc:a40d9d589409abb8c2f3b66ad6d999641"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the minimum dimensions that the texture format of this header can be.  <a href="#a40d9d589409abb8c2f3b66ad6d999641">More...</a><br/></td></tr>
<tr class="separator:a40d9d589409abb8c2f3b66ad6d999641"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb4c82af8bcbb2cc4f757f7ffbfa69e3"><td class="memItemLeft" align="right" valign="top">uint32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1assets_1_1_texture_header.html#aeb4c82af8bcbb2cc4f757f7ffbfa69e3">getNumberOfArrayMembers</a> () const </td></tr>
<tr class="memdesc:aeb4c82af8bcbb2cc4f757f7ffbfa69e3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the number of array members stored in this texture.  <a href="#aeb4c82af8bcbb2cc4f757f7ffbfa69e3">More...</a><br/></td></tr>
<tr class="separator:aeb4c82af8bcbb2cc4f757f7ffbfa69e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a662057362da180165dc48a64ea587ef2"><td class="memItemLeft" align="right" valign="top">uint32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1assets_1_1_texture_header.html#a662057362da180165dc48a64ea587ef2">getNumberOfFaces</a> () const </td></tr>
<tr class="memdesc:a662057362da180165dc48a64ea587ef2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the number of faces stored in this texture.  <a href="#a662057362da180165dc48a64ea587ef2">More...</a><br/></td></tr>
<tr class="separator:a662057362da180165dc48a64ea587ef2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6dab11626bf714970655b26f664633e2"><td class="memItemLeft" align="right" valign="top">uint32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1assets_1_1_texture_header.html#a6dab11626bf714970655b26f664633e2">getNumberOfMIPLevels</a> () const </td></tr>
<tr class="memdesc:a6dab11626bf714970655b26f664633e2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the number of MIP-Map levels stored in this texture.  <a href="#a6dab11626bf714970655b26f664633e2">More...</a><br/></td></tr>
<tr class="separator:a6dab11626bf714970655b26f664633e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a13de3abeb9f05499edf3f635a394afdb"><td class="memItemLeft" align="right" valign="top">const <br class="typebreak"/>
<a class="el" href="classpvr_1_1assets_1_1_texture_meta_data.html#a4bbfa2daea50d56e7e0204480a32e054">TextureMetaData::AxisOrientation</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1assets_1_1_texture_header.html#a13de3abeb9f05499edf3f635a394afdb">getOrientation</a> (<a class="el" href="classpvr_1_1assets_1_1_texture_meta_data.html#a2954ea9a789f11bea12518d17dc1e531">TextureMetaData::Axis</a> axis) const </td></tr>
<tr class="separator:a13de3abeb9f05499edf3f635a394afdb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9e748c5efb17e0fdb06ccba080c808b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpvr_1_1_pixel_format.html">PixelFormat</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1assets_1_1_texture_header.html#ae9e748c5efb17e0fdb06ccba080c808b">getPixelFormat</a> () const </td></tr>
<tr class="separator:ae9e748c5efb17e0fdb06ccba080c808b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abef06635f92c93ac5454f106eb6bff88"><td class="memItemLeft" align="right" valign="top">uint32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1assets_1_1_texture_header.html#abef06635f92c93ac5454f106eb6bff88">getTextureSize</a> (int32 mipMapLevel=c_pvrTextureAllMIPMaps, bool allSurfaces=true, bool allFaces=true) const </td></tr>
<tr class="memdesc:abef06635f92c93ac5454f106eb6bff88"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the size in PIXELS of the texture, given various input parameters.  <a href="#abef06635f92c93ac5454f106eb6bff88">More...</a><br/></td></tr>
<tr class="separator:abef06635f92c93ac5454f106eb6bff88"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3470b5b2bedbac6e2b81fac6eb5ffb6c"><td class="memItemLeft" align="right" valign="top">uint32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1assets_1_1_texture_header.html#a3470b5b2bedbac6e2b81fac6eb5ffb6c">getWidth</a> (uint32 uiMipLevel=c_pvrTextureTopMIPMap) const </td></tr>
<tr class="memdesc:a3470b5b2bedbac6e2b81fac6eb5ffb6c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the width of the user specified MIP-Map level for the texture.  <a href="#a3470b5b2bedbac6e2b81fac6eb5ffb6c">More...</a><br/></td></tr>
<tr class="separator:a3470b5b2bedbac6e2b81fac6eb5ffb6c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a226504c6ded5e50ed813e5794b1bfac6"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1assets_1_1_texture_header.html#a226504c6ded5e50ed813e5794b1bfac6">isBumpMap</a> () const </td></tr>
<tr class="memdesc:a226504c6ded5e50ed813e5794b1bfac6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if this texture is bumpmap.  <a href="#a226504c6ded5e50ed813e5794b1bfac6">More...</a><br/></td></tr>
<tr class="separator:a226504c6ded5e50ed813e5794b1bfac6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a484af8a009d514d08a0bf28d7026bcb6"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1assets_1_1_texture_header.html#a484af8a009d514d08a0bf28d7026bcb6">isFileCompressed</a> () const </td></tr>
<tr class="memdesc:a484af8a009d514d08a0bf28d7026bcb6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether or not the texture is compressed using PVRTexLib's FILE compression - this is independent of any texture compression.  <a href="#a484af8a009d514d08a0bf28d7026bcb6">More...</a><br/></td></tr>
<tr class="separator:a484af8a009d514d08a0bf28d7026bcb6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a17594f44a41af29f5b46c7de200ccecc"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1assets_1_1_texture_header.html#a17594f44a41af29f5b46c7de200ccecc">isPreMultiplied</a> () const </td></tr>
<tr class="memdesc:a17594f44a41af29f5b46c7de200ccecc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check whether or not the texture's color has been pre-multiplied by the alpha values.  <a href="#a17594f44a41af29f5b46c7de200ccecc">More...</a><br/></td></tr>
<tr class="separator:a17594f44a41af29f5b46c7de200ccecc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8fd896afa82ca548fcd5ffdfb92b4208"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpvr_1_1assets_1_1_texture_header.html">TextureHeader</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1assets_1_1_texture_header.html#a8fd896afa82ca548fcd5ffdfb92b4208">operator=</a> (const <a class="el" href="classpvr_1_1assets_1_1_texture_header.html">TextureHeader</a> &amp;rhs)</td></tr>
<tr class="memdesc:a8fd896afa82ca548fcd5ffdfb92b4208"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy the contents and information of another header into this one.  <a href="#a8fd896afa82ca548fcd5ffdfb92b4208">More...</a><br/></td></tr>
<tr class="separator:a8fd896afa82ca548fcd5ffdfb92b4208"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ba224c54c9ed0096a15c50619c73f30"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1assets_1_1_texture_header.html#a7ba224c54c9ed0096a15c50619c73f30">setBumpMap</a> (float bumpScale, string bumpOrder)</td></tr>
<tr class="memdesc:a7ba224c54c9ed0096a15c50619c73f30"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets a texture's bump map data.  <a href="#a7ba224c54c9ed0096a15c50619c73f30">More...</a><br/></td></tr>
<tr class="separator:a7ba224c54c9ed0096a15c50619c73f30"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6cbe0cda182217c01335b521fd575e71"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1assets_1_1_texture_header.html#a6cbe0cda182217c01335b521fd575e71">setChannelType</a> (<a class="el" href="namespacepvr_1_1_variable_type.html#a82d3ceaf1b4b315cd1ab51824a78b632">VariableType::Enum</a> channelType)</td></tr>
<tr class="separator:a6cbe0cda182217c01335b521fd575e71"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac846f411c94e52c7c2dca99a1f984b10"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1assets_1_1_texture_header.html#ac846f411c94e52c7c2dca99a1f984b10">setColorSpace</a> (ColorSpace::Enum colorSpace)</td></tr>
<tr class="memdesc:ac846f411c94e52c7c2dca99a1f984b10"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the color space for this texture. Default is lRGB.  <a href="#ac846f411c94e52c7c2dca99a1f984b10">More...</a><br/></td></tr>
<tr class="separator:ac846f411c94e52c7c2dca99a1f984b10"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc34bc244c2473e322528a32151353db"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1assets_1_1_texture_header.html#adc34bc244c2473e322528a32151353db">setCubeMapOrder</a> (std::string cubeMapOrder)</td></tr>
<tr class="memdesc:adc34bc244c2473e322528a32151353db"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets a texture's bump map data.  <a href="#adc34bc244c2473e322528a32151353db">More...</a><br/></td></tr>
<tr class="separator:adc34bc244c2473e322528a32151353db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9516da4f0536585d043d775cfd08664a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1assets_1_1_texture_header.html#a9516da4f0536585d043d775cfd08664a">setDepth</a> (uint32 newDepth)</td></tr>
<tr class="memdesc:a9516da4f0536585d043d775cfd08664a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the texture depth.  <a href="#a9516da4f0536585d043d775cfd08664a">More...</a><br/></td></tr>
<tr class="separator:a9516da4f0536585d043d775cfd08664a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac08be5455d5daaafaa8813637cc25b87"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1assets_1_1_texture_header.html#ac08be5455d5daaafaa8813637cc25b87">setDirect3DFormat</a> (uint32 d3dFormat)</td></tr>
<tr class="memdesc:ac08be5455d5daaafaa8813637cc25b87"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the format of the texture to PVRTexLib's internal representation of the Direct3D format.  <a href="#ac08be5455d5daaafaa8813637cc25b87">More...</a><br/></td></tr>
<tr class="separator:ac08be5455d5daaafaa8813637cc25b87"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7958b0905c9106fedcbb8f26a19510a6"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1assets_1_1_texture_header.html#a7958b0905c9106fedcbb8f26a19510a6">setDirectXGIFormat</a> (uint32 dxgiFormat)</td></tr>
<tr class="memdesc:a7958b0905c9106fedcbb8f26a19510a6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the format of the texture to PVRTexLib's internal representation of the DirectXGI format.  <a href="#a7958b0905c9106fedcbb8f26a19510a6">More...</a><br/></td></tr>
<tr class="separator:a7958b0905c9106fedcbb8f26a19510a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a15cd6dd24a0fee62c5efeaeabe984c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1assets_1_1_texture_header.html#a4a15cd6dd24a0fee62c5efeaeabe984c">setHeight</a> (uint32 newHeight)</td></tr>
<tr class="memdesc:a4a15cd6dd24a0fee62c5efeaeabe984c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the texture height.  <a href="#a4a15cd6dd24a0fee62c5efeaeabe984c">More...</a><br/></td></tr>
<tr class="separator:a4a15cd6dd24a0fee62c5efeaeabe984c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b2445ef8364d0497ba378ea90799d1b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1assets_1_1_texture_header.html#a8b2445ef8364d0497ba378ea90799d1b">setIsFileCompressed</a> (bool <a class="el" href="classpvr_1_1assets_1_1_texture_header.html#a484af8a009d514d08a0bf28d7026bcb6">isFileCompressed</a>)</td></tr>
<tr class="memdesc:a8b2445ef8364d0497ba378ea90799d1b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets whether or not the texture is compressed using PVRTexLib's FILE compression - this is independent of any texture compression. Currently unsupported.  <a href="#a8b2445ef8364d0497ba378ea90799d1b">More...</a><br/></td></tr>
<tr class="separator:a8b2445ef8364d0497ba378ea90799d1b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae333a9827e889428750ba91407e6bbf5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1assets_1_1_texture_header.html#ae333a9827e889428750ba91407e6bbf5">setIsPreMultiplied</a> (bool <a class="el" href="classpvr_1_1assets_1_1_texture_header.html#a17594f44a41af29f5b46c7de200ccecc">isPreMultiplied</a>)</td></tr>
<tr class="memdesc:ae333a9827e889428750ba91407e6bbf5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets whether or not the texture's color has been pre-multiplied by the alpha values.  <a href="#ae333a9827e889428750ba91407e6bbf5">More...</a><br/></td></tr>
<tr class="separator:ae333a9827e889428750ba91407e6bbf5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2302e05c300604b050305bd1fdecc9b1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1assets_1_1_texture_header.html#a2302e05c300604b050305bd1fdecc9b1">setNumberOfArrayMembers</a> (uint32 newNumMembers)</td></tr>
<tr class="memdesc:a2302e05c300604b050305bd1fdecc9b1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the number of arrays in this texture.  <a href="#a2302e05c300604b050305bd1fdecc9b1">More...</a><br/></td></tr>
<tr class="separator:a2302e05c300604b050305bd1fdecc9b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1427ed97cbe92c30cd804dd8b6c384c4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1assets_1_1_texture_header.html#a1427ed97cbe92c30cd804dd8b6c384c4">setNumberOfFaces</a> (uint32 newNumFaces)</td></tr>
<tr class="memdesc:a1427ed97cbe92c30cd804dd8b6c384c4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the number of faces stored in this texture.  <a href="#a1427ed97cbe92c30cd804dd8b6c384c4">More...</a><br/></td></tr>
<tr class="separator:a1427ed97cbe92c30cd804dd8b6c384c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a75d07efd40f34f7554ddb71ce8a5a767"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1assets_1_1_texture_header.html#a75d07efd40f34f7554ddb71ce8a5a767">setNumberOfMIPLevels</a> (uint32 newNumMIPLevels)</td></tr>
<tr class="memdesc:a75d07efd40f34f7554ddb71ce8a5a767"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the number of MIP-Map levels in this texture.  <a href="#a75d07efd40f34f7554ddb71ce8a5a767">More...</a><br/></td></tr>
<tr class="separator:a75d07efd40f34f7554ddb71ce8a5a767"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f139b23301bc87c7de0656657fff151"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1assets_1_1_texture_header.html#a1f139b23301bc87c7de0656657fff151">setopenGLFormat</a> (uint32 glInternalFormat, uint32 glFormat, uint32 glType)</td></tr>
<tr class="memdesc:a1f139b23301bc87c7de0656657fff151"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the format of the texture to PVRTexLib's internal representation of the openGL/ES format. The internal format may be sized or unsized.  <a href="#a1f139b23301bc87c7de0656657fff151">More...</a><br/></td></tr>
<tr class="separator:a1f139b23301bc87c7de0656657fff151"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f2fc50e55c2c7a4dc3ab9f556f8c660"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1assets_1_1_texture_header.html#a2f2fc50e55c2c7a4dc3ab9f556f8c660">setOrientation</a> (<a class="el" href="classpvr_1_1assets_1_1_texture_meta_data.html#a4bbfa2daea50d56e7e0204480a32e054">TextureMetaData::AxisOrientation</a> axisOrientation)</td></tr>
<tr class="memdesc:a2f2fc50e55c2c7a4dc3ab9f556f8c660"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the data orientation for a given axis in this texture.  <a href="#a2f2fc50e55c2c7a4dc3ab9f556f8c660">More...</a><br/></td></tr>
<tr class="separator:a2f2fc50e55c2c7a4dc3ab9f556f8c660"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9fdc5a3e3f103f6235367369cbcb34e0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1assets_1_1_texture_header.html#a9fdc5a3e3f103f6235367369cbcb34e0">setPixelFormat</a> (<a class="el" href="classpvr_1_1_pixel_format.html">PixelFormat</a> uPixelFormat)</td></tr>
<tr class="memdesc:a9fdc5a3e3f103f6235367369cbcb34e0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the pixel format for this texture.  <a href="#a9fdc5a3e3f103f6235367369cbcb34e0">More...</a><br/></td></tr>
<tr class="separator:a9fdc5a3e3f103f6235367369cbcb34e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae7715d84189d6623b1278396a35755c0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1assets_1_1_texture_header.html#ae7715d84189d6623b1278396a35755c0">setWidth</a> (uint32 newWidth)</td></tr>
<tr class="memdesc:ae7715d84189d6623b1278396a35755c0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the texture width.  <a href="#ae7715d84189d6623b1278396a35755c0">More...</a><br/></td></tr>
<tr class="separator:ae7715d84189d6623b1278396a35755c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:a73c45bc6d3c4b5fd7648cd54702320f9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structpvr_1_1assets_1_1_texture_header_1_1_header.html">Header</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1assets_1_1_texture_header.html#a73c45bc6d3c4b5fd7648cd54702320f9">m_header</a></td></tr>
<tr class="separator:a73c45bc6d3c4b5fd7648cd54702320f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a162b50680ca226c470f7019b03f7350b"><td class="memItemLeft" align="right" valign="top">std::map&lt; uint32, std::map<br class="typebreak"/>
&lt; uint32, <a class="el" href="classpvr_1_1assets_1_1_texture_meta_data.html">TextureMetaData</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1assets_1_1_texture_header.html#a162b50680ca226c470f7019b03f7350b">m_metaDataMap</a></td></tr>
<tr class="separator:a162b50680ca226c470f7019b03f7350b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>A class mirroring the PVR <a class="el" href="classpvr_1_1assets_1_1_texture.html" title="A 2D Texture asset, together with Information, Metadata and actual Pixel data. Only represents the ac...">Texture</a> container format header, and which can in general represent any <a class="el" href="classpvr_1_1assets_1_1_texture.html" title="A 2D Texture asset, together with Information, Metadata and actual Pixel data. Only represents the ac...">Texture</a> asset. Contains accessors functions to facilitate using the <a class="el" href="classpvr_1_1assets_1_1_texture.html" title="A 2D Texture asset, together with Information, Metadata and actual Pixel data. Only represents the ac...">Texture</a> data in application code. </p>
<hr/>
 </div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a65c71b3903ebc6d5ef561ed68feca7b3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">pvr::assets::TextureHeader::TextureHeader </td>
          <td>(</td>
          <td class="paramname">)</td><td></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Default constructor for a <a class="el" href="classpvr_1_1assets_1_1_texture_header.html" title="A class mirroring the PVR Texture container format header, and which can in general represent any Tex...">TextureHeader</a>. Returns an empty header. </p>
<hr/>
 
</div>
</div>
<a class="anchor" id="abd5fec67b112e803290a5dbbae2f341a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">pvr::assets::TextureHeader::TextureHeader </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classpvr_1_1assets_1_1_texture_header.html">TextureHeader</a> &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>)</td><td></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copy constructor. </p>
<hr/>
 <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rhs</td><td>Copy from </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a14ad724d7cb3bb45741a31cd1676fc7c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">pvr::assets::TextureHeader::TextureHeader </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structpvr_1_1assets_1_1_texture_header_1_1_header.html">Header</a> &amp;&#160;</td>
          <td class="paramname"><em>header</em>)</td><td></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Construct this from the given file header. </p>
<hr/>
 <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">header</td><td>File <a class="el" href="structpvr_1_1assets_1_1_texture_header_1_1_header.html" title="This header stores everything that you would ever need to load (but not necessarily use) a texture&#39;s ...">Header</a> used to construct this </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ad798e9be66154840ce572e7a6c11523c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">pvr::assets::TextureHeader::TextureHeader </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structpvr_1_1assets_1_1_texture_header_1_1_header.html">Header</a>&#160;</td>
          <td class="paramname"><em>fileHeader</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32&#160;</td>
          <td class="paramname"><em>metaDataCount</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classpvr_1_1assets_1_1_texture_meta_data.html">TextureMetaData</a> *&#160;</td>
          <td class="paramname"><em>metaData</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Construct this from file header and meta data. </p>
<hr/>
 <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fileHeader</td><td>File header to construct from </td></tr>
    <tr><td class="paramname">metaDataCount</td><td>Number of meta data in the array </td></tr>
    <tr><td class="paramname">metaData</td><td>Array of meta data </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a5a898f6f25951b3b57a64d20e4828ebb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">pvr::assets::TextureHeader::TextureHeader </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classpvr_1_1_pixel_format.html">PixelFormat</a>&#160;</td>
          <td class="paramname"><em>pixelFormat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32&#160;</td>
          <td class="paramname"><em>width</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32&#160;</td>
          <td class="paramname"><em>height</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32&#160;</td>
          <td class="paramname"><em>depth</em> = <code>1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32&#160;</td>
          <td class="paramname"><em>mipMapCount</em> = <code>1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ColorSpace::Enum&#160;</td>
          <td class="paramname"><em>colorSpace</em> = <code>ColorSpace::lRGB</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacepvr_1_1_variable_type.html#a82d3ceaf1b4b315cd1ab51824a78b632">VariableType::Enum</a>&#160;</td>
          <td class="paramname"><em>channelType</em> = <code><a class="el" href="namespacepvr_1_1_variable_type.html#a82d3ceaf1b4b315cd1ab51824a78b632a984876a9a95310c1f27dbbc69512cb6b">VariableType::UnsignedByteNorm</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32&#160;</td>
          <td class="paramname"><em>numberOfSurfaces</em> = <code>1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32&#160;</td>
          <td class="paramname"><em>numberOfFaces</em> = <code>1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32&#160;</td>
          <td class="paramname"><em>flags</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classpvr_1_1assets_1_1_texture_meta_data.html">TextureMetaData</a> *&#160;</td>
          <td class="paramname"><em>metaData</em> = <code>NULL</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32&#160;</td>
          <td class="paramname"><em>metaDataSize</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constructor. </p>
<hr/>
 <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pixelFormat</td><td>Pixel format of the texture </td></tr>
    <tr><td class="paramname">width</td><td><a class="el" href="classpvr_1_1assets_1_1_texture.html" title="A 2D Texture asset, together with Information, Metadata and actual Pixel data. Only represents the ac...">Texture</a> width </td></tr>
    <tr><td class="paramname">height</td><td><a class="el" href="classpvr_1_1assets_1_1_texture.html" title="A 2D Texture asset, together with Information, Metadata and actual Pixel data. Only represents the ac...">Texture</a> height </td></tr>
    <tr><td class="paramname">depth</td><td><a class="el" href="classpvr_1_1assets_1_1_texture.html" title="A 2D Texture asset, together with Information, Metadata and actual Pixel data. Only represents the ac...">Texture</a> depth </td></tr>
    <tr><td class="paramname">mipMapCount</td><td>Number of mipmap in the texture </td></tr>
    <tr><td class="paramname">colorSpace</td><td><a class="el" href="classpvr_1_1assets_1_1_texture.html" title="A 2D Texture asset, together with Information, Metadata and actual Pixel data. Only represents the ac...">Texture</a> color space (e.g sRGB, lRGB) </td></tr>
    <tr><td class="paramname">channelType</td><td><a class="el" href="classpvr_1_1assets_1_1_texture.html" title="A 2D Texture asset, together with Information, Metadata and actual Pixel data. Only represents the ac...">Texture</a> channel type </td></tr>
    <tr><td class="paramname">numberOfSurfaces</td><td>Number of surfaces the texture has </td></tr>
    <tr><td class="paramname">numberOfFaces</td><td>Number of faces the texture has </td></tr>
    <tr><td class="paramname">flags</td><td>Additional provided flags </td></tr>
    <tr><td class="paramname">metaData</td><td><a class="el" href="classpvr_1_1assets_1_1_texture.html" title="A 2D Texture asset, together with Information, Metadata and actual Pixel data. Only represents the ac...">Texture</a> meta data </td></tr>
    <tr><td class="paramname">metaDataSize</td><td><a class="el" href="classpvr_1_1assets_1_1_texture.html" title="A 2D Texture asset, together with Information, Metadata and actual Pixel data. Only represents the ac...">Texture</a> meta data size </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="ad967120d23991f749b9b876f3ad36598"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pvr::assets::TextureHeader::addMetaData </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classpvr_1_1assets_1_1_texture_meta_data.html">TextureMetaData</a> &amp;&#160;</td>
          <td class="paramname"><em>metaData</em>)</td><td></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds an arbitrary piece of meta data. </p>
<hr/>
 <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">metaData</td><td>Meta data block to be added. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ad1b5489ed47de45d350ca786729d283b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32 pvr::assets::TextureHeader::getBitsPerPixel </td>
          <td>(</td>
          <td class="paramname">)</td><td></td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<hr/>
 <dl class="section return"><dt>Returns</dt><dd>Return number of bits per pixel </dd></dl>
<dl class="section user"><dt>Description:</dt><dd>Gets the bits per pixel of the texture format. </dd></dl>

</div>
</div>
<a class="anchor" id="afe2c0211848d38728a14154d76ca9325"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacepvr_1_1_variable_type.html#a82d3ceaf1b4b315cd1ab51824a78b632">VariableType::Enum</a> pvr::assets::TextureHeader::getChannelType </td>
          <td>(</td>
          <td class="paramname">)</td><td></td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the channel type that the texture's data is stored in. </p>
<hr/>
 <dl class="section return"><dt>Returns</dt><dd>Return the enum representing the type of the texture. </dd></dl>

</div>
</div>
<a class="anchor" id="abce36cfc298d5136b79fcaaeabd38fe3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ColorSpace::Enum pvr::assets::TextureHeader::getColorSpace </td>
          <td>(</td>
          <td class="paramname">)</td><td></td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the color space of the texture. </p>
<hr/>
 <dl class="section return"><dt>Returns</dt><dd>Return the ColorSpace::Enum enum representing color space. </dd></dl>

</div>
</div>
<a class="anchor" id="a5d1a894abf399bb3f3f3703f8a27beaf"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const std::string pvr::assets::TextureHeader::getCubeMapOrder </td>
          <td>(</td>
          <td class="paramname">)</td><td></td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the cube map face order. </p>
<hr/>
 <dl class="section return"><dt>Returns</dt><dd>Returns cube map order. </dd></dl>
<dl class="section user"><dt>Description:</dt><dd>Returned string will be in the form "ZzXxYy" with capitals representing positive and small letters representing negative. I.e. Z=Z-Positive, z=Z-Negative. </dd></dl>

</div>
</div>
<a class="anchor" id="a54643ce3775b8f342f6a2ad83106e3f4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ptrdiff_t pvr::assets::TextureHeader::getDataOffset </td>
          <td>(</td>
          <td class="paramtype">uint32&#160;</td>
          <td class="paramname"><em>mipMapLevel</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32&#160;</td>
          <td class="paramname"><em>arrayMember</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32&#160;</td>
          <td class="paramname"><em>face</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get a offset in the data. </p>
<hr/>
 <dl class="section return"><dt>Returns</dt><dd>Return data offset </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mipMapLevel</td><td>The mip map level of the offset </td></tr>
    <tr><td class="paramname">arrayMember</td><td>The array index of the offset </td></tr>
    <tr><td class="paramname">face</td><td>The face of the offset </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a42529af539b3570fbcc651c6a9c92238"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32 pvr::assets::TextureHeader::getDataSize </td>
          <td>(</td>
          <td class="paramtype">int32&#160;</td>
          <td class="paramname"><em>mipLevel</em> = <code>c_pvrTextureAllMIPMaps</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>allSurfaces</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>allFaces</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the size in BYTES of the texture, given various input parameters. </p>
<hr/>
 <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">mipLevel</td><td>Specifies a mip level to check, 'c_pvrTextureAllMIPMapLevels' can be passed to Get the size of all MIP levels. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">allSurfaces</td><td>The Size of all surfaces is calculated if true, only a single surface if false. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">allFaces</td><td>The Size of all faces is calculated if true, only a single face if false. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Return the size in BYTES of the specified texture area. </dd></dl>
<dl class="section user"><dt>Description:</dt><dd>User can retrieve the size of either all surfaces or a single surface, all faces or a single face and all MIP-Maps or a single specified MIP level. </dd></dl>

</div>
</div>
<a class="anchor" id="a4a5beec8e0059d71a8225c6773b96352"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32 pvr::assets::TextureHeader::getDepth </td>
          <td>(</td>
          <td class="paramtype">uint32&#160;</td>
          <td class="paramname"><em>mipLevel</em> = <code>c_pvrTextureTopMIPMap</code>)</td><td></td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<hr/>
 <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">mipLevel</td><td>MIP level that user is interested in. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Return the depth of the specified MIP-Map level. </dd></dl>
<dl class="section user"><dt>Description:</dt><dd>Gets the depth of the user specified MIP-Map level for the texture. </dd></dl>

</div>
</div>
<a class="anchor" id="a83693e94d6af18da907ef496903cff17"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool pvr::assets::TextureHeader::getDirect3DFormat </td>
          <td>(</td>
          <td class="paramtype">uint32 &amp;&#160;</td>
          <td class="paramname"><em>outD3dFormat</em>)</td><td></td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the Direct3D equivalent format enumeration for this texture. </p>
<hr/>
 <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">outD3dFormat</td><td>Returned d3d format </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Return true on success, returns false if it cannot find a suitable type </dd></dl>

</div>
</div>
<a class="anchor" id="aef946cf89b0730669b1ecb4b5003fbb0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool pvr::assets::TextureHeader::getDirectXGIFormat </td>
          <td>(</td>
          <td class="paramtype">uint32 &amp;&#160;</td>
          <td class="paramname"><em>outDxgiFormat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool &amp;&#160;</td>
          <td class="paramname"><em>notAlpha</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the DirectXGI equivalent format enumeration for this texture. </p>
<hr/>
 <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">notAlpha</td><td>Return whether the <code>outDxgiFormat</code> is has alpha or not. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">outDxgiFormat</td><td>Returned dxgi format </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Return true on success, returns false if it cannot find a suitable type </dd></dl>

</div>
</div>
<a class="anchor" id="ad1566dc62e49e5bc3dffce1d0ef1ce7b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structpvr_1_1assets_1_1_texture_header_1_1_header.html">Header</a> pvr::assets::TextureHeader::getFileHeader </td>
          <td>(</td>
          <td class="paramname">)</td><td></td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the file header structure. </p>
<hr/>
 <dl class="section return"><dt>Returns</dt><dd>Return the file header. </dd></dl>

</div>
</div>
<a class="anchor" id="a239c9927fb8f2ee7e8e74e8bea27117c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structpvr_1_1assets_1_1_texture_header_1_1_header.html">Header</a>&amp; pvr::assets::TextureHeader::getFileHeaderAccess </td>
          <td>(</td>
          <td class="paramname">)</td><td></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the file header access. </p>
<hr/>
 <dl class="section return"><dt>Returns</dt><dd>Return the file header. </dd></dl>

</div>
</div>
<a class="anchor" id="a8ed7376ba257c1e4c14ca4cb5b18169d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32 pvr::assets::TextureHeader::getHeight </td>
          <td>(</td>
          <td class="paramtype">uint32&#160;</td>
          <td class="paramname"><em>uiMipLevel</em> = <code>c_pvrTextureTopMIPMap</code>)</td><td></td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<hr/>
 <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">uiMipLevel</td><td>MIP level that user is interested in. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Return the Height of the specified MIP-Map level. </dd></dl>
<dl class="section user"><dt>Description:</dt><dd>Gets the height of the user specified MIP-Map level for the texture. </dd></dl>

</div>
</div>
<a class="anchor" id="a54aed1c9b68bc68ed126aee17e8a6b8c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const std::map&lt;uint32, std::map&lt;uint32, <a class="el" href="classpvr_1_1assets_1_1_texture_meta_data.html">TextureMetaData</a>&gt; &gt;* const pvr::assets::TextureHeader::getMetaDataMap </td>
          <td>(</td>
          <td class="paramname">)</td><td></td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get a pointer directly to the Meta Data Map, to allow users to read out data. </p>
<hr/>
 <dl class="section return"><dt>Returns</dt><dd>Return a direct pointer to the MetaData map. </dd></dl>

</div>
</div>
<a class="anchor" id="afae4e0671acd51eb785ef58804e7a05a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32 pvr::assets::TextureHeader::getMetaDataSize </td>
          <td>(</td>
          <td class="paramname">)</td><td></td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the total size of the meta data stored in the header. This includes the size of all information stored in all CPVRMetaDataBlocks. </p>
<hr/>
 <dl class="section return"><dt>Returns</dt><dd>Return the size, in bytes, of the meta data stored in the header. </dd></dl>

</div>
</div>
<a class="anchor" id="a40d9d589409abb8c2f3b66ad6d999641"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pvr::assets::TextureHeader::getMinDimensionsForFormat </td>
          <td>(</td>
          <td class="paramtype">uint32 &amp;&#160;</td>
          <td class="paramname"><em>minX</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32 &amp;&#160;</td>
          <td class="paramname"><em>minY</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32 &amp;&#160;</td>
          <td class="paramname"><em>minZ</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the minimum dimensions that the texture format of this header can be. </p>
<hr/>
 <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">minX</td><td>Minimum width of the texture format. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">minY</td><td>Minimum height of the texture format. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">minZ</td><td>Minimum depth of the texture format. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aeb4c82af8bcbb2cc4f757f7ffbfa69e3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32 pvr::assets::TextureHeader::getNumberOfArrayMembers </td>
          <td>(</td>
          <td class="paramname">)</td><td></td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the number of array members stored in this texture. </p>
<hr/>
 <dl class="section return"><dt>Returns</dt><dd>Return the number of array members in this texture. </dd></dl>

</div>
</div>
<a class="anchor" id="a662057362da180165dc48a64ea587ef2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32 pvr::assets::TextureHeader::getNumberOfFaces </td>
          <td>(</td>
          <td class="paramname">)</td><td></td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the number of faces stored in this texture. </p>
<hr/>
 <dl class="section return"><dt>Returns</dt><dd>Return the number of faces in this texture. </dd></dl>

</div>
</div>
<a class="anchor" id="a6dab11626bf714970655b26f664633e2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32 pvr::assets::TextureHeader::getNumberOfMIPLevels </td>
          <td>(</td>
          <td class="paramname">)</td><td></td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the number of MIP-Map levels stored in this texture. </p>
<hr/>
 <dl class="section return"><dt>Returns</dt><dd>Return the number of MIP-Map levels in this texture. </dd></dl>

</div>
</div>
<a class="anchor" id="a13de3abeb9f05499edf3f635a394afdb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classpvr_1_1assets_1_1_texture_meta_data.html#a4bbfa2daea50d56e7e0204480a32e054">TextureMetaData::AxisOrientation</a> pvr::assets::TextureHeader::getOrientation </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classpvr_1_1assets_1_1_texture_meta_data.html#a2954ea9a789f11bea12518d17dc1e531">TextureMetaData::Axis</a>&#160;</td>
          <td class="paramname"><em>axis</em>)</td><td></td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<hr/>
 <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">axis</td><td>The axis to examine. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Return the orientation of the axis. </dd></dl>
<dl class="section user"><dt>Description:</dt><dd>Gets the data orientation for this texture. </dd></dl>

</div>
</div>
<a class="anchor" id="ae9e748c5efb17e0fdb06ccba080c808b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpvr_1_1_pixel_format.html">PixelFormat</a> pvr::assets::TextureHeader::getPixelFormat </td>
          <td>(</td>
          <td class="paramname">)</td><td></td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<hr/>
 <dl class="section return"><dt>Returns</dt><dd>Return a 64-bit pixel type ID. </dd></dl>
<dl class="section user"><dt>Description:</dt><dd>Gets the pixel type ID of the texture. </dd></dl>

</div>
</div>
<a class="anchor" id="abef06635f92c93ac5454f106eb6bff88"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32 pvr::assets::TextureHeader::getTextureSize </td>
          <td>(</td>
          <td class="paramtype">int32&#160;</td>
          <td class="paramname"><em>mipMapLevel</em> = <code>c_pvrTextureAllMIPMaps</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>allSurfaces</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>allFaces</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the size in PIXELS of the texture, given various input parameters. </p>
<hr/>
 <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">mipMapLevel</td><td>Specifies a MIP level to check, 'c_pvrTextureAllMIPMapLevels' can be passed to Get the size of all MIP levels. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">allSurfaces</td><td>The Size of all surfaces is calculated if true, only a single surface if false. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">allFaces</td><td>The Size of all faces is calculated if true, only a single face if false. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Return the size in PIXELS of the specified texture area. </dd></dl>
<dl class="section user"><dt>Description:</dt><dd>User can retrieve the total size of either all surfaces or a single surface, all faces or a single face and all MIP-Maps or a single specified MIP level. All of these </dd></dl>

</div>
</div>
<a class="anchor" id="a3470b5b2bedbac6e2b81fac6eb5ffb6c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32 pvr::assets::TextureHeader::getWidth </td>
          <td>(</td>
          <td class="paramtype">uint32&#160;</td>
          <td class="paramname"><em>uiMipLevel</em> = <code>c_pvrTextureTopMIPMap</code>)</td><td></td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the width of the user specified MIP-Map level for the texture. </p>
<hr/>
 <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">uiMipLevel</td><td>MIP level that user is interested in. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Return the width of the specified MIP-Map level. </dd></dl>

</div>
</div>
<a class="anchor" id="a226504c6ded5e50ed813e5794b1bfac6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool pvr::assets::TextureHeader::isBumpMap </td>
          <td>(</td>
          <td class="paramname">)</td><td></td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check if this texture is bumpmap. </p>
<hr/>
 <dl class="section return"><dt>Returns</dt><dd>Return true if the texture is bumpmap </dd></dl>

</div>
</div>
<a class="anchor" id="a484af8a009d514d08a0bf28d7026bcb6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool pvr::assets::TextureHeader::isFileCompressed </td>
          <td>(</td>
          <td class="paramname">)</td><td></td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns whether or not the texture is compressed using PVRTexLib's FILE compression - this is independent of any texture compression. </p>
<hr/>
 <dl class="section return"><dt>Returns</dt><dd>Return true if it is file compressed. </dd></dl>

</div>
</div>
<a class="anchor" id="a17594f44a41af29f5b46c7de200ccecc"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool pvr::assets::TextureHeader::isPreMultiplied </td>
          <td>(</td>
          <td class="paramname">)</td><td></td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check whether or not the texture's color has been pre-multiplied by the alpha values. </p>
<hr/>
 <dl class="section return"><dt>Returns</dt><dd>Return true if texture is premultiplied. </dd></dl>

</div>
</div>
<a class="anchor" id="a8fd896afa82ca548fcd5ffdfb92b4208"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpvr_1_1assets_1_1_texture_header.html">TextureHeader</a>&amp; pvr::assets::TextureHeader::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classpvr_1_1assets_1_1_texture_header.html">TextureHeader</a> &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>)</td><td></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copy the contents and information of another header into this one. </p>
<hr/>
 <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">rhs</td><td>copy the information from </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Return this header. </dd></dl>

</div>
</div>
<a class="anchor" id="a7ba224c54c9ed0096a15c50619c73f30"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pvr::assets::TextureHeader::setBumpMap </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>bumpScale</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">string&#160;</td>
          <td class="paramname"><em>bumpOrder</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets a texture's bump map data. </p>
<hr/>
 <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">bumpScale</td><td>Floating point "height" value to scale the bump map. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">bumpOrder</td><td>Up to 4 character string, with values x,y,z,h in some combination. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Description:</dt><dd>For <code>bumpOrder</code> Not all values need to be present. Denotes channel order; x,y,z refer to the corresponding axes, h indicates presence of the original height map. It is possible to have only some of these values rather than all. For example if 'h' is present alone it will be considered a height map. The values should be presented in RGBA order, regardless of the texture format, so a zyxh order in a bgra texture should still be passed as 'xyzh'. Capitals are allowed. Any character stored here that is not one of x,y,z,h or a NULL character will be ignored when PVRTexLib reads the data, but will be preserved. This is useful if you wish to define a custom data channel for instance. In these instances PVRTexLib will assume it is simply color data. </dd></dl>

</div>
</div>
<a class="anchor" id="a6cbe0cda182217c01335b521fd575e71"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pvr::assets::TextureHeader::setChannelType </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacepvr_1_1_variable_type.html#a82d3ceaf1b4b315cd1ab51824a78b632">VariableType::Enum</a>&#160;</td>
          <td class="paramname"><em>channelType</em>)</td><td></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<hr/>
 <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">channelType</td><td><a class="el" href="classpvr_1_1assets_1_1_texture.html" title="A 2D Texture asset, together with Information, Metadata and actual Pixel data. Only represents the ac...">Texture</a>'s channel type </td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Description:</dt><dd>Sets the channel type of this texture. </dd></dl>

</div>
</div>
<a class="anchor" id="ac846f411c94e52c7c2dca99a1f984b10"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pvr::assets::TextureHeader::setColorSpace </td>
          <td>(</td>
          <td class="paramtype">ColorSpace::Enum&#160;</td>
          <td class="paramname"><em>colorSpace</em>)</td><td></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the color space for this texture. Default is lRGB. </p>
<hr/>
 <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">colorSpace</td><td>A color space of the texture. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="adc34bc244c2473e322528a32151353db"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pvr::assets::TextureHeader::setCubeMapOrder </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>cubeMapOrder</em>)</td><td></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets a texture's bump map data. </p>
<hr/>
 <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">cubeMapOrder</td><td>Up to 6 character string, with values x,X,y,Y,z,Z in some combination. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Description:</dt><dd>for <code>cubmapOrder</code> Not all values need to be present. Denotes face order; Capitals refer to positive axis positions and small letters refer to negative axis positions. E.g. x=X-Negative, X=X-Positive. It is possible to have only some of these values rather than all, as long as they are NULL terminated. NB: Values past the 6th character are not read. </dd></dl>

</div>
</div>
<a class="anchor" id="a9516da4f0536585d043d775cfd08664a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pvr::assets::TextureHeader::setDepth </td>
          <td>(</td>
          <td class="paramtype">uint32&#160;</td>
          <td class="paramname"><em>newDepth</em>)</td><td></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the texture depth. </p>
<hr/>
 <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">newDepth</td><td>The new depth. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ac08be5455d5daaafaa8813637cc25b87"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool pvr::assets::TextureHeader::setDirect3DFormat </td>
          <td>(</td>
          <td class="paramtype">uint32&#160;</td>
          <td class="paramname"><em>d3dFormat</em>)</td><td></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the format of the texture to PVRTexLib's internal representation of the Direct3D format. </p>
<hr/>
 <dl class="section return"><dt>Returns</dt><dd>Return true if the format is valid or not. </dd></dl>

</div>
</div>
<a class="anchor" id="a7958b0905c9106fedcbb8f26a19510a6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool pvr::assets::TextureHeader::setDirectXGIFormat </td>
          <td>(</td>
          <td class="paramtype">uint32&#160;</td>
          <td class="paramname"><em>dxgiFormat</em>)</td><td></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the format of the texture to PVRTexLib's internal representation of the DirectXGI format. </p>
<hr/>
 <dl class="section return"><dt>Returns</dt><dd>Return true if the format is valid or not. </dd></dl>

</div>
</div>
<a class="anchor" id="a4a15cd6dd24a0fee62c5efeaeabe984c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pvr::assets::TextureHeader::setHeight </td>
          <td>(</td>
          <td class="paramtype">uint32&#160;</td>
          <td class="paramname"><em>newHeight</em>)</td><td></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the texture height. </p>
<hr/>
 <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">newHeight</td><td>The new height. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a8b2445ef8364d0497ba378ea90799d1b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pvr::assets::TextureHeader::setIsFileCompressed </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>isFileCompressed</em>)</td><td></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets whether or not the texture is compressed using PVRTexLib's FILE compression - this is independent of any texture compression. Currently unsupported. </p>
<hr/>
 <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">isFileCompressed</td><td>Sets file compression to true/false. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ae333a9827e889428750ba91407e6bbf5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pvr::assets::TextureHeader::setIsPreMultiplied </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>isPreMultiplied</em>)</td><td></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets whether or not the texture's color has been pre-multiplied by the alpha values. </p>
<hr/>
 <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">isPreMultiplied</td><td>Sets if texture is premultiplied. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a2302e05c300604b050305bd1fdecc9b1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pvr::assets::TextureHeader::setNumberOfArrayMembers </td>
          <td>(</td>
          <td class="paramtype">uint32&#160;</td>
          <td class="paramname"><em>newNumMembers</em>)</td><td></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the number of arrays in this texture. </p>
<hr/>
 <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">newNumMembers</td><td>The new number of members in this array. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a1427ed97cbe92c30cd804dd8b6c384c4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pvr::assets::TextureHeader::setNumberOfFaces </td>
          <td>(</td>
          <td class="paramtype">uint32&#160;</td>
          <td class="paramname"><em>newNumFaces</em>)</td><td></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the number of faces stored in this texture. </p>
<hr/>
 <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">newNumFaces</td><td>New number of faces for this texture. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a75d07efd40f34f7554ddb71ce8a5a767"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pvr::assets::TextureHeader::setNumberOfMIPLevels </td>
          <td>(</td>
          <td class="paramtype">uint32&#160;</td>
          <td class="paramname"><em>newNumMIPLevels</em>)</td><td></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the number of MIP-Map levels in this texture. </p>
<hr/>
 <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">newNumMIPLevels</td><td>New number of MIP-Map levels. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a1f139b23301bc87c7de0656657fff151"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool pvr::assets::TextureHeader::setopenGLFormat </td>
          <td>(</td>
          <td class="paramtype">uint32&#160;</td>
          <td class="paramname"><em>glInternalFormat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32&#160;</td>
          <td class="paramname"><em>glFormat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32&#160;</td>
          <td class="paramname"><em>glType</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the format of the texture to PVRTexLib's internal representation of the openGL/ES format. The internal format may be sized or unsized. </p>
<hr/>
 <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">glInternalFormat</td><td>Opengl internal format </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">glFormat</td><td>Opengl format </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">glType</td><td>Opengl type </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Return true if the format is valid. </dd></dl>

</div>
</div>
<a class="anchor" id="a2f2fc50e55c2c7a4dc3ab9f556f8c660"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pvr::assets::TextureHeader::setOrientation </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classpvr_1_1assets_1_1_texture_meta_data.html#a4bbfa2daea50d56e7e0204480a32e054">TextureMetaData::AxisOrientation</a>&#160;</td>
          <td class="paramname"><em>axisOrientation</em>)</td><td></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the data orientation for a given axis in this texture. </p>
<hr/>
 <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">axisOrientation</td><td>Specifying axis and orientation. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a9fdc5a3e3f103f6235367369cbcb34e0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pvr::assets::TextureHeader::setPixelFormat </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classpvr_1_1_pixel_format.html">PixelFormat</a>&#160;</td>
          <td class="paramname"><em>uPixelFormat</em>)</td><td></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the pixel format for this texture. </p>
<hr/>
 <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">uPixelFormat</td><td>The format of the pixel. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ae7715d84189d6623b1278396a35755c0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pvr::assets::TextureHeader::setWidth </td>
          <td>(</td>
          <td class="paramtype">uint32&#160;</td>
          <td class="paramname"><em>newWidth</em>)</td><td></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the texture width. </p>
<hr/>
 <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">newWidth</td><td>The new width. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a class="anchor" id="a73c45bc6d3c4b5fd7648cd54702320f9"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structpvr_1_1assets_1_1_texture_header_1_1_header.html">Header</a> pvr::assets::TextureHeader::m_header</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a162b50680ca226c470f7019b03f7350b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::map&lt;uint32, std::map&lt;uint32, <a class="el" href="classpvr_1_1assets_1_1_texture_meta_data.html">TextureMetaData</a>&gt; &gt; pvr::assets::TextureHeader::m_metaDataMap</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>C:/dev/buildxl/buildroot/sdk/branch/Framework/PVRAssets/Texture/<a class="el" href="_texture_header_8h_source.html">TextureHeader.h</a></li>
</ul>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.8.4-->
<!-- start footer part (NON TREEVIEW ONLY!!) -->
<!--BEGIN GENERATE_TREEVIEW-->
<div id="FooterMainContainer">
	<div id="FooterContainer">
		<div class="footerlogo">
			<a href="http://www.imgtec.com" target="_blank"><img src="img-footer-logo-grey.png" width="100%" height="100%" border="none" /></a>
		</div>
		<div class="copyright"><p>&copy; Imagination Technologies Limited<br> All rights reserved</p></div>
	</div>
</div>
</body>
</html>
