<!-- HTML header for doxygen 1.8.4-->
<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="generator" content="Doxygen 1.8.6"/>
<title>PVRVk: pvrvk::impl::SecondaryCommandBuffer_ Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="IMGdoxygen.css" rel="stylesheet" type="text/css"/>
<link rel="shortcut icon" href="http://www.imgtec.com/images/img.ico">
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
  <div class="headercontent">
    <div class="PVRlogo">
      <a href="http://www.powervrinsider.com" target="_blank"><img src="PVRlogo.png" width="40%" height="40%"  border="none" /></a>
    </div>
    <a class="SiteTitle"><span id="projectname">PVRVk</span> Documentation</a>
   <tbody>
  </div>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.6 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="inherits.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Macros</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(10)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacepvrvk.html">pvrvk</a></li><li class="navelem"><a class="el" href="namespacepvrvk_1_1impl.html">impl</a></li><li class="navelem"><a class="el" href="classpvrvk_1_1impl_1_1_secondary_command_buffer__.html">SecondaryCommandBuffer_</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> &#124;
<a href="classpvrvk_1_1impl_1_1_secondary_command_buffer__-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">pvrvk::impl::SecondaryCommandBuffer_ Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Contains all the commands and states that need to be submitted to the gpu, including pipeline, texture, and samplers. Virtually everything that needs to happen on the GPU is submitted to the CommandBuffer.  
 <a href="classpvrvk_1_1impl_1_1_secondary_command_buffer__.html#details">More...</a></p>
<div class="dynheader">
Inheritance diagram for pvrvk::impl::SecondaryCommandBuffer_:</div>
<div class="dyncontent">
<div class="center"><img src="classpvrvk_1_1impl_1_1_secondary_command_buffer____inherit__graph.png" border="0" usemap="#pvrvk_1_1impl_1_1_secondary_command_buffer___inherit__map" alt="Inheritance graph"/></div>
<map name="pvrvk_1_1impl_1_1_secondary_command_buffer___inherit__map" id="pvrvk_1_1impl_1_1_secondary_command_buffer___inherit__map">
<area shape="rect" id="node2" href="classpvrvk_1_1impl_1_1_command_buffer_base__.html" title="Contains all the commands and states that need to be recorded for later submission to the gpu includi..." alt="" coords="531,38,720,79"/><area shape="rect" id="node3" href="classpvrvk_1_1impl_1_1_device_object_handle.html" title="pvrvk::impl::DeviceObject\lHandle\&lt; VkCommandBuffer \&gt;" alt="" coords="255,5,454,46"/><area shape="rect" id="node4" href="classpvrvk_1_1impl_1_1_object_handle.html" title="pvrvk::impl::ObjectHandle\l\&lt; VkCommandBuffer \&gt;" alt="" coords="5,5,179,46"/><area shape="rect" id="node5" href="classpvrvk_1_1impl_1_1_device_object_debug_marker.html" title="pvrvk::impl::DeviceObject\lDebugMarker\&lt; CommandBufferBase_ \&gt;" alt="" coords="227,70,483,111"/></map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a6d449edb8cf90b9c237f940f0b561a9c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvrvk_1_1impl_1_1_command_buffer_base__.html#a6d449edb8cf90b9c237f940f0b561a9c">begin</a> (const CommandBufferUsageFlags flags=CommandBufferUsageFlags(0))</td></tr>
<tr class="memdesc:a6d449edb8cf90b9c237f940f0b561a9c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Call this function before beginning to record commands. <a href="#a6d449edb8cf90b9c237f940f0b561a9c">More...</a><br/></td></tr>
<tr class="separator:a6d449edb8cf90b9c237f940f0b561a9c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09d9e885485c1753a0b13f9ab07a78f6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvrvk_1_1impl_1_1_secondary_command_buffer__.html#a09d9e885485c1753a0b13f9ab07a78f6">begin</a> (const <a class="el" href="namespacepvrvk.html#a55f833c5feaaa65f3aaed3a08a7a55e6">RenderPass</a> &amp;renderpass, uint32_t subpass=0, const CommandBufferUsageFlags flags=CommandBufferUsageFlags::e_RENDER_PASS_CONTINUE_BIT)</td></tr>
<tr class="memdesc:a09d9e885485c1753a0b13f9ab07a78f6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Call this function before beginning to record commands. If the Framebuffer object is known, prefer the Framebuffer overload as it may offer better performance. <a href="#a09d9e885485c1753a0b13f9ab07a78f6">More...</a><br/></td></tr>
<tr class="separator:a09d9e885485c1753a0b13f9ab07a78f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a574e16f7068cd5d978b627c9582ac7b9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvrvk_1_1impl_1_1_secondary_command_buffer__.html#a574e16f7068cd5d978b627c9582ac7b9">begin</a> (const <a class="el" href="namespacepvrvk.html#a7639515cddb57ed4370a5ce02287988a">Framebuffer</a> &amp;framebuffer, uint32_t subpass=0, const CommandBufferUsageFlags flags=CommandBufferUsageFlags::e_RENDER_PASS_CONTINUE_BIT)</td></tr>
<tr class="memdesc:a574e16f7068cd5d978b627c9582ac7b9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Call this function before beginning to record commands. <a href="#a574e16f7068cd5d978b627c9582ac7b9">More...</a><br/></td></tr>
<tr class="separator:a574e16f7068cd5d978b627c9582ac7b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a862a03340dc1812389fca32ceaffa881"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvrvk_1_1impl_1_1_command_buffer_base__.html#a862a03340dc1812389fca32ceaffa881">beginQuery</a> (<a class="el" href="namespacepvrvk.html#a9775dff694169a1bafd336a1a64508f7">QueryPool</a> &amp;queryPool, uint32_t queryIndex, QueryControlFlags flags=QueryControlFlags(0))</td></tr>
<tr class="memdesc:a862a03340dc1812389fca32ceaffa881"><td class="mdescLeft">&#160;</td><td class="mdescRight">Begins a query for a particular QueryPool. <a href="#a862a03340dc1812389fca32ceaffa881">More...</a><br/></td></tr>
<tr class="separator:a862a03340dc1812389fca32ceaffa881"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a37e81e963a89f7b2b16112acb4c01d54"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvrvk_1_1impl_1_1_command_buffer_base__.html#a37e81e963a89f7b2b16112acb4c01d54">bindDescriptorSet</a> (PipelineBindPoint bindingPoint, const <a class="el" href="namespacepvrvk.html#a34bb21497524a13e145b1398450989d0">PipelineLayout</a> &amp;pipelineLayout, uint32_t firstSet, const <a class="el" href="namespacepvrvk.html#afaa5d3390eb48fd21197430158a7d5ac">DescriptorSet</a> set, const uint32_t *dynamicOffsets=nullptr, uint32_t numDynamicOffsets=0)</td></tr>
<tr class="memdesc:a37e81e963a89f7b2b16112acb4c01d54"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bind descriptorset <a href="#a37e81e963a89f7b2b16112acb4c01d54">More...</a><br/></td></tr>
<tr class="separator:a37e81e963a89f7b2b16112acb4c01d54"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5d43d0aee637c66a1137e0e32d1c09f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvrvk_1_1impl_1_1_command_buffer_base__.html#af5d43d0aee637c66a1137e0e32d1c09f">bindDescriptorSets</a> (PipelineBindPoint bindingPoint, const <a class="el" href="namespacepvrvk.html#a34bb21497524a13e145b1398450989d0">PipelineLayout</a> &amp;pipelineLayout, uint32_t firstSet, const <a class="el" href="namespacepvrvk.html#afaa5d3390eb48fd21197430158a7d5ac">DescriptorSet</a> *sets, uint32_t numDescriptorSets, const uint32_t *dynamicOffsets=nullptr, uint32_t numDynamicOffsets=0)</td></tr>
<tr class="memdesc:af5d43d0aee637c66a1137e0e32d1c09f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bind descriptorsets <a href="#af5d43d0aee637c66a1137e0e32d1c09f">More...</a><br/></td></tr>
<tr class="separator:af5d43d0aee637c66a1137e0e32d1c09f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa66ee757605ffa9afa68bf95ab9c7adf"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvrvk_1_1impl_1_1_command_buffer_base__.html#aa66ee757605ffa9afa68bf95ab9c7adf">bindIndexBuffer</a> (const <a class="el" href="namespacepvrvk.html#a2a117db0aab25382d050908b2bfa4c8b">Buffer</a> &amp;buffer, uint32_t offset, IndexType indexType)</td></tr>
<tr class="memdesc:aa66ee757605ffa9afa68bf95ab9c7adf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bind index bufer <a href="#aa66ee757605ffa9afa68bf95ab9c7adf">More...</a><br/></td></tr>
<tr class="separator:aa66ee757605ffa9afa68bf95ab9c7adf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adfc394932317683fb0582841423527b2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvrvk_1_1impl_1_1_command_buffer_base__.html#adfc394932317683fb0582841423527b2">bindPipeline</a> (const <a class="el" href="namespacepvrvk.html#aa2443b681960df638797cf93bbf33fb7">GraphicsPipeline</a> &amp;pipeline)</td></tr>
<tr class="memdesc:adfc394932317683fb0582841423527b2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bind a graphics pipeline. <a href="#adfc394932317683fb0582841423527b2">More...</a><br/></td></tr>
<tr class="separator:adfc394932317683fb0582841423527b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a79d2f3d38f2aad3fa3ba4b7b793d1421"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvrvk_1_1impl_1_1_command_buffer_base__.html#a79d2f3d38f2aad3fa3ba4b7b793d1421">bindPipeline</a> (<a class="el" href="namespacepvrvk.html#a946a7145c9e18b9a797fa714ce677f32">ComputePipeline</a> &amp;pipeline)</td></tr>
<tr class="memdesc:a79d2f3d38f2aad3fa3ba4b7b793d1421"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bind a compute pipeline <a href="#a79d2f3d38f2aad3fa3ba4b7b793d1421">More...</a><br/></td></tr>
<tr class="separator:a79d2f3d38f2aad3fa3ba4b7b793d1421"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2382fc789d3e96d50693f9e5483ff0b0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvrvk_1_1impl_1_1_command_buffer_base__.html#a2382fc789d3e96d50693f9e5483ff0b0">bindVertexBuffer</a> (const <a class="el" href="namespacepvrvk.html#a2a117db0aab25382d050908b2bfa4c8b">Buffer</a> &amp;buffer, uint32_t offset, uint16_t bindingIndex)</td></tr>
<tr class="memdesc:a2382fc789d3e96d50693f9e5483ff0b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bind vertex buffer <a href="#a2382fc789d3e96d50693f9e5483ff0b0">More...</a><br/></td></tr>
<tr class="separator:a2382fc789d3e96d50693f9e5483ff0b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2853f758e9e70e100e3140405fc8e03c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvrvk_1_1impl_1_1_command_buffer_base__.html#a2853f758e9e70e100e3140405fc8e03c">bindVertexBuffer</a> (<a class="el" href="namespacepvrvk.html#a2a117db0aab25382d050908b2bfa4c8b">Buffer</a> const *buffers, uint32_t *offsets, uint16_t numBuffers, uint16_t startBinding, uint16_t numBindings)</td></tr>
<tr class="memdesc:a2853f758e9e70e100e3140405fc8e03c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bind vertex buffer <a href="#a2853f758e9e70e100e3140405fc8e03c">More...</a><br/></td></tr>
<tr class="separator:a2853f758e9e70e100e3140405fc8e03c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a88093ef10da31dcaa3846beb36617bbb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvrvk_1_1impl_1_1_command_buffer_base__.html#a88093ef10da31dcaa3846beb36617bbb">blitImage</a> (const <a class="el" href="namespacepvrvk.html#a0dde8112e297d1089979fbdbdcbbe0f4">Image</a> &amp;srcImage, <a class="el" href="namespacepvrvk.html#a0dde8112e297d1089979fbdbdcbbe0f4">Image</a> &amp;dstImage, const ImageBlit *regions, uint32_t numRegions, Filter filter, ImageLayout srcLayout, ImageLayout dstLayout)</td></tr>
<tr class="memdesc:a88093ef10da31dcaa3846beb36617bbb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies regions of a src image into a dst image, potentially also performing format conversions, aritrary scaling and filtering. <a href="#a88093ef10da31dcaa3846beb36617bbb">More...</a><br/></td></tr>
<tr class="separator:a88093ef10da31dcaa3846beb36617bbb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a26d8498fee836c63989072eb483d8938"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvrvk_1_1impl_1_1_command_buffer_base__.html#a26d8498fee836c63989072eb483d8938">clearAttachment</a> (const <a class="el" href="structpvrvk_1_1_clear_attachment.html">ClearAttachment</a> &amp;clearAttachment, const ClearRect &amp;clearRectangle)</td></tr>
<tr class="memdesc:a26d8498fee836c63989072eb483d8938"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clears a particular attachment using a provided region whilst inside of a renderpass. <a href="#a26d8498fee836c63989072eb483d8938">More...</a><br/></td></tr>
<tr class="separator:a26d8498fee836c63989072eb483d8938"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac681c14ddfb7b443d318e695633571b5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvrvk_1_1impl_1_1_command_buffer_base__.html#ac681c14ddfb7b443d318e695633571b5">clearAttachments</a> (const uint32_t numAttachments, const <a class="el" href="structpvrvk_1_1_clear_attachment.html">ClearAttachment</a> *clearAttachments, uint32_t numRectangles, const ClearRect *clearRectangles)</td></tr>
<tr class="memdesc:ac681c14ddfb7b443d318e695633571b5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clear a set of attacments using a number of regions for each selected attachment to clear whilst inside a renderpass. <a href="#ac681c14ddfb7b443d318e695633571b5">More...</a><br/></td></tr>
<tr class="separator:ac681c14ddfb7b443d318e695633571b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b76e94f5959d34d1fd15be43a9d0b6e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvrvk_1_1impl_1_1_command_buffer_base__.html#a0b76e94f5959d34d1fd15be43a9d0b6e">clearColorImage</a> (<a class="el" href="namespacepvrvk.html#ad4da214c95fffe4edccb14eb2c270f07">ImageView</a> &amp;image, const <a class="el" href="structpvrvk_1_1_clear_color_value.html">ClearColorValue</a> &amp;clearColor, ImageLayout currentLayout, const uint32_t baseMipLevel=0, const uint32_t numLevels=1, const uint32_t baseArrayLayer=0, const uint32_t numLayers=1)</td></tr>
<tr class="memdesc:a0b76e94f5959d34d1fd15be43a9d0b6e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clears a color image outside of a renderpass instance. <a href="#a0b76e94f5959d34d1fd15be43a9d0b6e">More...</a><br/></td></tr>
<tr class="separator:a0b76e94f5959d34d1fd15be43a9d0b6e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a57c9d24c5b0f0486c9ab5602269edf4a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvrvk_1_1impl_1_1_command_buffer_base__.html#a57c9d24c5b0f0486c9ab5602269edf4a">clearColorImage</a> (<a class="el" href="namespacepvrvk.html#ad4da214c95fffe4edccb14eb2c270f07">ImageView</a> &amp;image, const <a class="el" href="structpvrvk_1_1_clear_color_value.html">ClearColorValue</a> &amp;clearColor, ImageLayout currentLayout, const uint32_t *baseMipLevels, const uint32_t *numLevels, const uint32_t *baseArrayLayers, const uint32_t *numLayers, uint32_t numRanges)</td></tr>
<tr class="memdesc:a57c9d24c5b0f0486c9ab5602269edf4a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clears a color image outside of a renderpass instance using a number of ranges. <a href="#a57c9d24c5b0f0486c9ab5602269edf4a">More...</a><br/></td></tr>
<tr class="separator:a57c9d24c5b0f0486c9ab5602269edf4a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a77fa9538ba0fcb3c2dc77f5e58a90e55"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvrvk_1_1impl_1_1_command_buffer_base__.html#a77fa9538ba0fcb3c2dc77f5e58a90e55">clearDepthImage</a> (<a class="el" href="namespacepvrvk.html#a0dde8112e297d1089979fbdbdcbbe0f4">Image</a> &amp;image, float clearDepth, const uint32_t baseMipLevel, const uint32_t numLevels, const uint32_t baseArrayLayer, const uint32_t numLayers, ImageLayout layout)</td></tr>
<tr class="memdesc:a77fa9538ba0fcb3c2dc77f5e58a90e55"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clear depth image outside of a renderpass instance. <a href="#a77fa9538ba0fcb3c2dc77f5e58a90e55">More...</a><br/></td></tr>
<tr class="separator:a77fa9538ba0fcb3c2dc77f5e58a90e55"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e669f8997f42c5d9ae85222efa53c5a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvrvk_1_1impl_1_1_command_buffer_base__.html#a7e669f8997f42c5d9ae85222efa53c5a">clearDepthImage</a> (<a class="el" href="namespacepvrvk.html#a0dde8112e297d1089979fbdbdcbbe0f4">Image</a> &amp;image, float clearDepth, const uint32_t *baseMipLevels, const uint32_t *numLevels, const uint32_t *baseArrayLayers, const uint32_t *numLayers, uint32_t numRanges, ImageLayout layout)</td></tr>
<tr class="memdesc:a7e669f8997f42c5d9ae85222efa53c5a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clears the depth image outside of a renderpass instance using a number of ranges. <a href="#a7e669f8997f42c5d9ae85222efa53c5a">More...</a><br/></td></tr>
<tr class="separator:a7e669f8997f42c5d9ae85222efa53c5a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c4d7f8b6ddcd8f4a22adea5c0474bc9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvrvk_1_1impl_1_1_command_buffer_base__.html#a0c4d7f8b6ddcd8f4a22adea5c0474bc9">clearDepthStencilImage</a> (<a class="el" href="namespacepvrvk.html#a0dde8112e297d1089979fbdbdcbbe0f4">Image</a> &amp;image, float clearDepth, uint32_t clearStencil, const uint32_t baseMipLevel, const uint32_t numLevels, const uint32_t baseArrayLayer, const uint32_t numLayers, ImageLayout layout)</td></tr>
<tr class="memdesc:a0c4d7f8b6ddcd8f4a22adea5c0474bc9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clear depth stencil image outside of a renderpass instance. <a href="#a0c4d7f8b6ddcd8f4a22adea5c0474bc9">More...</a><br/></td></tr>
<tr class="separator:a0c4d7f8b6ddcd8f4a22adea5c0474bc9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aadc22a2bd68016cfcb03a4eba0adb3f4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvrvk_1_1impl_1_1_command_buffer_base__.html#aadc22a2bd68016cfcb03a4eba0adb3f4">clearDepthStencilImage</a> (<a class="el" href="namespacepvrvk.html#a0dde8112e297d1089979fbdbdcbbe0f4">Image</a> &amp;image, float clearDepth, uint32_t clearStencil, const uint32_t *baseMipLevels, const uint32_t *numLevels, const uint32_t *baseArrayLayers, const uint32_t *numLayers, uint32_t numRanges, ImageLayout layout)</td></tr>
<tr class="memdesc:aadc22a2bd68016cfcb03a4eba0adb3f4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clear depth stencil image outside of a renderpass instance using a number of ranges. <a href="#aadc22a2bd68016cfcb03a4eba0adb3f4">More...</a><br/></td></tr>
<tr class="separator:aadc22a2bd68016cfcb03a4eba0adb3f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a300280c8edf7996f94fba4e634f56a18"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvrvk_1_1impl_1_1_command_buffer_base__.html#a300280c8edf7996f94fba4e634f56a18">clearStencilImage</a> (<a class="el" href="namespacepvrvk.html#a0dde8112e297d1089979fbdbdcbbe0f4">Image</a> &amp;image, uint32_t clearStencil, const uint32_t baseMipLevel, const uint32_t numLevels, const uint32_t baseArrayLayer, const uint32_t numLayers, ImageLayout layout)</td></tr>
<tr class="memdesc:a300280c8edf7996f94fba4e634f56a18"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clears a stencil image outside of a renderpass instance. <a href="#a300280c8edf7996f94fba4e634f56a18">More...</a><br/></td></tr>
<tr class="separator:a300280c8edf7996f94fba4e634f56a18"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4fafdc0e9a578950eaf38bc83931aaba"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvrvk_1_1impl_1_1_command_buffer_base__.html#a4fafdc0e9a578950eaf38bc83931aaba">clearStencilImage</a> (<a class="el" href="namespacepvrvk.html#a0dde8112e297d1089979fbdbdcbbe0f4">Image</a> &amp;image, uint32_t clearStencil, const uint32_t *baseMipLevels, const uint32_t *numLevels, const uint32_t *baseArrayLayers, const uint32_t *numLayers, uint32_t numRanges, ImageLayout layout)</td></tr>
<tr class="memdesc:a4fafdc0e9a578950eaf38bc83931aaba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clear stencil image outside of a renderpass instance using a number of ranges. <a href="#a4fafdc0e9a578950eaf38bc83931aaba">More...</a><br/></td></tr>
<tr class="separator:a4fafdc0e9a578950eaf38bc83931aaba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a900d1651d2366f7c5db896d9ddf4b73f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvrvk_1_1impl_1_1_command_buffer_base__.html#a900d1651d2366f7c5db896d9ddf4b73f">copyBuffer</a> (<a class="el" href="namespacepvrvk.html#a2a117db0aab25382d050908b2bfa4c8b">Buffer</a> srcBuffer, <a class="el" href="namespacepvrvk.html#a2a117db0aab25382d050908b2bfa4c8b">Buffer</a> dstBuffer, uint32_t numRegions, const BufferCopy *regions)</td></tr>
<tr class="memdesc:a900d1651d2366f7c5db896d9ddf4b73f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy Buffer <a href="#a900d1651d2366f7c5db896d9ddf4b73f">More...</a><br/></td></tr>
<tr class="separator:a900d1651d2366f7c5db896d9ddf4b73f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb34b2defee7acc83aaaa82f23c16b88"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvrvk_1_1impl_1_1_command_buffer_base__.html#adb34b2defee7acc83aaaa82f23c16b88">copyBufferToImage</a> (const <a class="el" href="namespacepvrvk.html#a2a117db0aab25382d050908b2bfa4c8b">Buffer</a> &amp;buffer, <a class="el" href="namespacepvrvk.html#a0dde8112e297d1089979fbdbdcbbe0f4">Image</a> &amp;image, ImageLayout dstImageLayout, uint32_t regionsCount, const BufferImageCopy *regions)</td></tr>
<tr class="memdesc:adb34b2defee7acc83aaaa82f23c16b88"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy buffer to image <a href="#adb34b2defee7acc83aaaa82f23c16b88">More...</a><br/></td></tr>
<tr class="separator:adb34b2defee7acc83aaaa82f23c16b88"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adaf1fb46af6d7186a1b631f26b31914a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvrvk_1_1impl_1_1_command_buffer_base__.html#adaf1fb46af6d7186a1b631f26b31914a">copyImage</a> (<a class="el" href="namespacepvrvk.html#a0dde8112e297d1089979fbdbdcbbe0f4">Image</a> &amp;srcImage, <a class="el" href="namespacepvrvk.html#a0dde8112e297d1089979fbdbdcbbe0f4">Image</a> &amp;dstImage, ImageLayout srcImageLayout, ImageLayout dstImageLayout, uint32_t numRegions, const ImageCopy *regions)</td></tr>
<tr class="memdesc:adaf1fb46af6d7186a1b631f26b31914a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy data between Images <a href="#adaf1fb46af6d7186a1b631f26b31914a">More...</a><br/></td></tr>
<tr class="separator:adaf1fb46af6d7186a1b631f26b31914a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a664eb3e79ee7a405f8daf3425db77d2d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvrvk_1_1impl_1_1_command_buffer_base__.html#a664eb3e79ee7a405f8daf3425db77d2d">copyImageToBuffer</a> (<a class="el" href="namespacepvrvk.html#a0dde8112e297d1089979fbdbdcbbe0f4">Image</a> &amp;srcImage, ImageLayout srcImageLayout, <a class="el" href="namespacepvrvk.html#a2a117db0aab25382d050908b2bfa4c8b">Buffer</a> &amp;dstBuffer, const BufferImageCopy *regions, uint32_t numRegions)</td></tr>
<tr class="memdesc:a664eb3e79ee7a405f8daf3425db77d2d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy image to buffer <a href="#a664eb3e79ee7a405f8daf3425db77d2d">More...</a><br/></td></tr>
<tr class="separator:a664eb3e79ee7a405f8daf3425db77d2d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae7b0c98a25f798bb0af566f3f1238c3c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvrvk_1_1impl_1_1_command_buffer_base__.html#ae7b0c98a25f798bb0af566f3f1238c3c">copyQueryPoolResults</a> (<a class="el" href="namespacepvrvk.html#a9775dff694169a1bafd336a1a64508f7">QueryPool</a> &amp;queryPool, uint32_t firstQuery, uint32_t queryCount, <a class="el" href="namespacepvrvk.html#a2a117db0aab25382d050908b2bfa4c8b">Buffer</a> &amp;dstBuffer, VkDeviceSize offset, VkDeviceSize stride, QueryResultFlags flags)</td></tr>
<tr class="memdesc:ae7b0c98a25f798bb0af566f3f1238c3c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies the query statuses and numerical results directly to buffer memory. <a href="#ae7b0c98a25f798bb0af566f3f1238c3c">More...</a><br/></td></tr>
<tr class="separator:ae7b0c98a25f798bb0af566f3f1238c3c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa3feee42a09e91b84646875891a628e2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvrvk_1_1impl_1_1_command_buffer_base__.html#aa3feee42a09e91b84646875891a628e2">debugMarkerBeginEXT</a> (const std::string markerName, float r=183.0f/255.0f, float g=26.0f/255.0f, float b=139.0f/255.0f, float a=1.0f)</td></tr>
<tr class="memdesc:aa3feee42a09e91b84646875891a628e2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Begins a debug marked region. <a href="#aa3feee42a09e91b84646875891a628e2">More...</a><br/></td></tr>
<tr class="separator:aa3feee42a09e91b84646875891a628e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a029a7feee509f14715a509ef1de45b26"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvrvk_1_1impl_1_1_command_buffer_base__.html#a029a7feee509f14715a509ef1de45b26">debugMarkerEndEXT</a> ()</td></tr>
<tr class="memdesc:a029a7feee509f14715a509ef1de45b26"><td class="mdescLeft">&#160;</td><td class="mdescRight">Ends a debug marked region. <a href="#a029a7feee509f14715a509ef1de45b26">More...</a><br/></td></tr>
<tr class="separator:a029a7feee509f14715a509ef1de45b26"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad0cb3933b9ca7e276728bf0691d31d1d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvrvk_1_1impl_1_1_command_buffer_base__.html#ad0cb3933b9ca7e276728bf0691d31d1d">debugMarkerInsertEXT</a> (const std::string markerName, float r=183.0f/255.0f, float g=26.0f/255.0f, float b=139.0f/255.0f, float a=1.0f)</td></tr>
<tr class="memdesc:ad0cb3933b9ca7e276728bf0691d31d1d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts a debug marker. <a href="#ad0cb3933b9ca7e276728bf0691d31d1d">More...</a><br/></td></tr>
<tr class="separator:ad0cb3933b9ca7e276728bf0691d31d1d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a96aeb9ef8d82603dfeac45d2ff177ba2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvrvk_1_1impl_1_1_command_buffer_base__.html#a96aeb9ef8d82603dfeac45d2ff177ba2">dispatch</a> (uint32_t numGroupX, uint32_t numGroupY, uint32_t numGroupZ)</td></tr>
<tr class="memdesc:a96aeb9ef8d82603dfeac45d2ff177ba2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dispatching work provokes work in a compute pipeline. A compute pipeline must be bound to the command buffer before any dispatch commands are recorded. <a href="#a96aeb9ef8d82603dfeac45d2ff177ba2">More...</a><br/></td></tr>
<tr class="separator:a96aeb9ef8d82603dfeac45d2ff177ba2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb78b08d16568eeb47ffed3294d3f6e2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvrvk_1_1impl_1_1_command_buffer_base__.html#acb78b08d16568eeb47ffed3294d3f6e2">dispatchIndirect</a> (<a class="el" href="namespacepvrvk.html#a2a117db0aab25382d050908b2bfa4c8b">Buffer</a> &amp;buffer, uint32_t offset)</td></tr>
<tr class="memdesc:acb78b08d16568eeb47ffed3294d3f6e2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dispatching work provokes work in a compute pipeline. A compute pipeline must be bound to the command buffer before any dispatch commands are recorded. dispatchIndirect behaves similarly to dispatch except that the parameters are read by the device from a buffer during execution. The parameters of the dispatch are encoded in a DispatchIndirectCommand structure taken from buffer starting at offset <a href="#acb78b08d16568eeb47ffed3294d3f6e2">More...</a><br/></td></tr>
<tr class="separator:acb78b08d16568eeb47ffed3294d3f6e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a38f7566ddeb086f6aa546ee3311288"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvrvk_1_1impl_1_1_command_buffer_base__.html#a4a38f7566ddeb086f6aa546ee3311288">draw</a> (uint32_t firstVertex, uint32_t numVertices, uint32_t firstInstance=0, uint32_t numInstances=1)</td></tr>
<tr class="memdesc:a4a38f7566ddeb086f6aa546ee3311288"><td class="mdescLeft">&#160;</td><td class="mdescRight">Non-indexed drawing command. <a href="#a4a38f7566ddeb086f6aa546ee3311288">More...</a><br/></td></tr>
<tr class="separator:a4a38f7566ddeb086f6aa546ee3311288"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d0dd5fece38c2da3f474f302f70eba8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvrvk_1_1impl_1_1_command_buffer_base__.html#a9d0dd5fece38c2da3f474f302f70eba8">drawIndexed</a> (uint32_t firstIndex, uint32_t numIndices, uint32_t vertexOffset=0, uint32_t firstInstance=0, uint32_t numInstances=1)</td></tr>
<tr class="memdesc:a9d0dd5fece38c2da3f474f302f70eba8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Indexed drawing command. <a href="#a9d0dd5fece38c2da3f474f302f70eba8">More...</a><br/></td></tr>
<tr class="separator:a9d0dd5fece38c2da3f474f302f70eba8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2da4e6e18ae17379fd66ae6a7e3d3eb7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvrvk_1_1impl_1_1_command_buffer_base__.html#a2da4e6e18ae17379fd66ae6a7e3d3eb7">drawIndexedIndirect</a> (<a class="el" href="namespacepvrvk.html#a2a117db0aab25382d050908b2bfa4c8b">Buffer</a> &amp;buffer, uint32_t offset, uint32_t count, uint32_t stride)</td></tr>
<tr class="memdesc:a2da4e6e18ae17379fd66ae6a7e3d3eb7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Non-indexed indirect drawing command. <a href="#a2da4e6e18ae17379fd66ae6a7e3d3eb7">More...</a><br/></td></tr>
<tr class="separator:a2da4e6e18ae17379fd66ae6a7e3d3eb7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a38db7b68a0aafa77bc03b5f199843b6c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvrvk_1_1impl_1_1_command_buffer_base__.html#a38db7b68a0aafa77bc03b5f199843b6c">drawIndirect</a> (<a class="el" href="namespacepvrvk.html#a2a117db0aab25382d050908b2bfa4c8b">Buffer</a> &amp;buffer, uint32_t offset, uint32_t count, uint32_t stride)</td></tr>
<tr class="memdesc:a38db7b68a0aafa77bc03b5f199843b6c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Non-indexed indirect drawing command. <a href="#a38db7b68a0aafa77bc03b5f199843b6c">More...</a><br/></td></tr>
<tr class="separator:a38db7b68a0aafa77bc03b5f199843b6c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a571250974bf01a908011ca732dbb74d7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvrvk_1_1impl_1_1_command_buffer_base__.html#a571250974bf01a908011ca732dbb74d7">end</a> ()</td></tr>
<tr class="memdesc:a571250974bf01a908011ca732dbb74d7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Call this function when you are done recording commands. BeginRecording must be called first.  <a href="#a571250974bf01a908011ca732dbb74d7">More...</a><br/></td></tr>
<tr class="separator:a571250974bf01a908011ca732dbb74d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac1bc81278e124ac66d23eac1fe2dc6cd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvrvk_1_1impl_1_1_command_buffer_base__.html#ac1bc81278e124ac66d23eac1fe2dc6cd">endQuery</a> (<a class="el" href="namespacepvrvk.html#a9775dff694169a1bafd336a1a64508f7">QueryPool</a> &amp;queryPool, uint32_t queryIndex)</td></tr>
<tr class="memdesc:ac1bc81278e124ac66d23eac1fe2dc6cd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Ends a query for a particular QueryPool. <a href="#ac1bc81278e124ac66d23eac1fe2dc6cd">More...</a><br/></td></tr>
<tr class="separator:ac1bc81278e124ac66d23eac1fe2dc6cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a56e3f2184eeb8f9aadaa631c1338179b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvrvk_1_1impl_1_1_command_buffer_base__.html#a56e3f2184eeb8f9aadaa631c1338179b">fillBuffer</a> (<a class="el" href="namespacepvrvk.html#a2a117db0aab25382d050908b2bfa4c8b">Buffer</a> dstBuffer, uint32_t dstOffset, uint32_t data, uint64_t size=VK_WHOLE_SIZE)</td></tr>
<tr class="memdesc:a56e3f2184eeb8f9aadaa631c1338179b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clear buffer data <a href="#a56e3f2184eeb8f9aadaa631c1338179b">More...</a><br/></td></tr>
<tr class="separator:a56e3f2184eeb8f9aadaa631c1338179b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afbec4fbcfddbaff8fa39c6abf03f21f8"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="namespacepvrvk.html#ac9949394db8b3d968a7402b837567f87">CommandPool</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvrvk_1_1impl_1_1_command_buffer_base__.html#afbec4fbcfddbaff8fa39c6abf03f21f8">getCommandPool</a> () const </td></tr>
<tr class="memdesc:afbec4fbcfddbaff8fa39c6abf03f21f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Const getter for the command pool used to allocate this command buffer. <a href="#afbec4fbcfddbaff8fa39c6abf03f21f8">More...</a><br/></td></tr>
<tr class="separator:afbec4fbcfddbaff8fa39c6abf03f21f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a29d79599ff2851f03e72df701b411fd1"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="namespacepvrvk.html#a8dd5932a80187b088ce6b591712dc2c2">DeviceWeakPtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvrvk_1_1impl_1_1_device_object_handle.html#a29d79599ff2851f03e72df701b411fd1">getDevice</a> () const</td></tr>
<tr class="memdesc:a29d79599ff2851f03e72df701b411fd1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get Device (const) <a href="#a29d79599ff2851f03e72df701b411fd1">More...</a><br/></td></tr>
<tr class="separator:a29d79599ff2851f03e72df701b411fd1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa78f66f58571440f57204a645383c279"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacepvrvk.html#a8dd5932a80187b088ce6b591712dc2c2">DeviceWeakPtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvrvk_1_1impl_1_1_device_object_handle.html#aa78f66f58571440f57204a645383c279">getDevice</a> ()</td></tr>
<tr class="memdesc:aa78f66f58571440f57204a645383c279"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get Device <a href="#aa78f66f58571440f57204a645383c279">More...</a><br/></td></tr>
<tr class="separator:aa78f66f58571440f57204a645383c279"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f27eddb1090fc657f3af1966d353e0b"><td class="memItemLeft" align="right" valign="top">const VkCommandBuffer &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvrvk_1_1impl_1_1_object_handle.html#a4f27eddb1090fc657f3af1966d353e0b">getVkHandle</a> () const</td></tr>
<tr class="memdesc:a4f27eddb1090fc657f3af1966d353e0b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get vulkan object (const) <a href="#a4f27eddb1090fc657f3af1966d353e0b">More...</a><br/></td></tr>
<tr class="separator:a4f27eddb1090fc657f3af1966d353e0b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f32e4b0b8899d01ff783456befcb5b9"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvrvk_1_1impl_1_1_command_buffer_base__.html#a0f32e4b0b8899d01ff783456befcb5b9">isRecording</a> ()</td></tr>
<tr class="memdesc:a0f32e4b0b8899d01ff783456befcb5b9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Queries if a command buffer is in the recording state <a href="#a0f32e4b0b8899d01ff783456befcb5b9">More...</a><br/></td></tr>
<tr class="separator:a0f32e4b0b8899d01ff783456befcb5b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f27bf1f81f790997dca75aa747ddaf2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvrvk_1_1impl_1_1_command_buffer_base__.html#a7f27bf1f81f790997dca75aa747ddaf2">pipelineBarrier</a> (PipelineStageFlags srcStage, PipelineStageFlags dstStage, const <a class="el" href="classpvrvk_1_1_memory_barrier_set.html">MemoryBarrierSet</a> &amp;barriers, bool dependencyByRegion=true)</td></tr>
<tr class="memdesc:a7f27bf1f81f790997dca75aa747ddaf2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a memory barrier to the command stream, forcing preceeding commands to be written before succeeding commands are executed. <a href="#a7f27bf1f81f790997dca75aa747ddaf2">More...</a><br/></td></tr>
<tr class="separator:a7f27bf1f81f790997dca75aa747ddaf2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a723ace2575665407b309eb3a397c180d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvrvk_1_1impl_1_1_command_buffer_base__.html#a723ace2575665407b309eb3a397c180d">pushConstants</a> (const <a class="el" href="namespacepvrvk.html#a34bb21497524a13e145b1398450989d0">PipelineLayout</a> &amp;pipelineLayout, ShaderStageFlags stageFlags, uint32_t offset, uint32_t size, const void *data)</td></tr>
<tr class="memdesc:a723ace2575665407b309eb3a397c180d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Updates the value of shader push constants at the offset specified. <a href="#a723ace2575665407b309eb3a397c180d">More...</a><br/></td></tr>
<tr class="separator:a723ace2575665407b309eb3a397c180d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abcd9b6cfd2182af00c2b8e0da8667b77"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="abcd9b6cfd2182af00c2b8e0da8667b77"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvrvk_1_1impl_1_1_command_buffer_base__.html#abcd9b6cfd2182af00c2b8e0da8667b77">reset</a> (CommandBufferResetFlags resetFlags)</td></tr>
<tr class="memdesc:abcd9b6cfd2182af00c2b8e0da8667b77"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clears this CommandBuffer discarding any previously recorded commands and puts the command buffer in the initial state. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">resetFlags</td><td>Is a bitmask of CommandBufferResetFlagBits controlling the reset operation.</td></tr>
  </table>
  </dd>
</dl>
<br/></td></tr>
<tr class="separator:abcd9b6cfd2182af00c2b8e0da8667b77"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa4cea12c65ab4bbd82d0916a47e44437"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvrvk_1_1impl_1_1_command_buffer_base__.html#aa4cea12c65ab4bbd82d0916a47e44437">resetEvent</a> (<a class="el" href="namespacepvrvk.html#a6696a17453f99f2b221a28bb05e4934b">Event</a> &amp;event, PipelineStageFlags pipelineStageFlags=PipelineStageFlags::e_ALL_COMMANDS_BIT)</td></tr>
<tr class="memdesc:aa4cea12c65ab4bbd82d0916a47e44437"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defines an execution dependency on commands that were submitted before it, and defines an event unsignal operation which resets the event to the unsignaled state. <a href="#aa4cea12c65ab4bbd82d0916a47e44437">More...</a><br/></td></tr>
<tr class="separator:aa4cea12c65ab4bbd82d0916a47e44437"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d5fc2fba19956e2923f87641cd3811e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvrvk_1_1impl_1_1_device_object_debug_marker.html#a0d5fc2fba19956e2923f87641cd3811e">resetObjectName</a> ()</td></tr>
<tr class="memdesc:a0d5fc2fba19956e2923f87641cd3811e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resets the name of a specified object using the extension VK_EXT_debug_marker. <a href="#a0d5fc2fba19956e2923f87641cd3811e">More...</a><br/></td></tr>
<tr class="separator:a0d5fc2fba19956e2923f87641cd3811e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d37c209b0ef644c8f069a70be5bf156"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvrvk_1_1impl_1_1_command_buffer_base__.html#a7d37c209b0ef644c8f069a70be5bf156">resetQueryPool</a> (<a class="el" href="namespacepvrvk.html#a9775dff694169a1bafd336a1a64508f7">QueryPool</a> &amp;queryPool, uint32_t firstQuery, uint32_t queryCount)</td></tr>
<tr class="memdesc:a7d37c209b0ef644c8f069a70be5bf156"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resets a particular range of queries for a particular QueryPool and sets their status' to unavailable which also makes their numerical results undefined. <a href="#a7d37c209b0ef644c8f069a70be5bf156">More...</a><br/></td></tr>
<tr class="separator:a7d37c209b0ef644c8f069a70be5bf156"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8148425c603008468c0a25e84c486b1d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvrvk_1_1impl_1_1_command_buffer_base__.html#a8148425c603008468c0a25e84c486b1d">resetQueryPool</a> (<a class="el" href="namespacepvrvk.html#a9775dff694169a1bafd336a1a64508f7">QueryPool</a> &amp;queryPool, uint32_t queryIndex)</td></tr>
<tr class="memdesc:a8148425c603008468c0a25e84c486b1d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resets a particular range of queries for a particular QueryPool and sets their status' to unavailable which also makes their numerical results undefined. <a href="#a8148425c603008468c0a25e84c486b1d">More...</a><br/></td></tr>
<tr class="separator:a8148425c603008468c0a25e84c486b1d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf5c74a05c61018eef6ac794c10d2938"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvrvk_1_1impl_1_1_command_buffer_base__.html#abf5c74a05c61018eef6ac794c10d2938">resolveImage</a> (<a class="el" href="namespacepvrvk.html#a0dde8112e297d1089979fbdbdcbbe0f4">Image</a> &amp;srcImage, <a class="el" href="namespacepvrvk.html#a0dde8112e297d1089979fbdbdcbbe0f4">Image</a> &amp;dstImage, const ImageResolve *regions, uint32_t numRegions, ImageLayout srcLayout, ImageLayout dstLayout)</td></tr>
<tr class="memdesc:abf5c74a05c61018eef6ac794c10d2938"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies regions of a src image into a dst image, potentially also performing format conversions, aritrary scaling and filtering. <a href="#abf5c74a05c61018eef6ac794c10d2938">More...</a><br/></td></tr>
<tr class="separator:abf5c74a05c61018eef6ac794c10d2938"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ce2c215aa9814e5e8aa02f679f9fa24"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvrvk_1_1impl_1_1_command_buffer_base__.html#a9ce2c215aa9814e5e8aa02f679f9fa24">setBlendConstants</a> (float rgba[4])</td></tr>
<tr class="memdesc:a9ce2c215aa9814e5e8aa02f679f9fa24"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the dynamic blend constant bias state affecting pipeline objects created with VK_DYNAMIC_STATE_BLEND_CONSTANTS enabled. <a href="#a9ce2c215aa9814e5e8aa02f679f9fa24">More...</a><br/></td></tr>
<tr class="separator:a9ce2c215aa9814e5e8aa02f679f9fa24"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a486a9d46e8f693398db0dc03fede5fb6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvrvk_1_1impl_1_1_command_buffer_base__.html#a486a9d46e8f693398db0dc03fede5fb6">setDepthBias</a> (float constantFactor, float clamp, float slopeFactor)</td></tr>
<tr class="memdesc:a486a9d46e8f693398db0dc03fede5fb6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the dynamic depth bias state affecting pipeline objects created where depthBiasEnable is enabled. <a href="#a486a9d46e8f693398db0dc03fede5fb6">More...</a><br/></td></tr>
<tr class="separator:a486a9d46e8f693398db0dc03fede5fb6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae41e1a87d69f9f3476ea6e20037b9b00"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvrvk_1_1impl_1_1_command_buffer_base__.html#ae41e1a87d69f9f3476ea6e20037b9b00">setDepthBounds</a> (float min, float max)</td></tr>
<tr class="memdesc:ae41e1a87d69f9f3476ea6e20037b9b00"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the dynamic depth bounds state affecting pipeline objects created with VK_DYNAMIC_STATE_DEPTH_BOUNDS enabled. <a href="#ae41e1a87d69f9f3476ea6e20037b9b00">More...</a><br/></td></tr>
<tr class="separator:ae41e1a87d69f9f3476ea6e20037b9b00"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad2c47766d3ed0ef1aa2dc0ea6819162c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvrvk_1_1impl_1_1_command_buffer_base__.html#ad2c47766d3ed0ef1aa2dc0ea6819162c">setEvent</a> (<a class="el" href="namespacepvrvk.html#a6696a17453f99f2b221a28bb05e4934b">Event</a> &amp;event, PipelineStageFlags pipelineStageFlags=PipelineStageFlags::e_ALL_COMMANDS_BIT)</td></tr>
<tr class="memdesc:ad2c47766d3ed0ef1aa2dc0ea6819162c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defines an execution dependency on commands that were submitted before it, and defines an event signal operation which sets the event to the signaled state. <a href="#ad2c47766d3ed0ef1aa2dc0ea6819162c">More...</a><br/></td></tr>
<tr class="separator:ad2c47766d3ed0ef1aa2dc0ea6819162c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e36ba62ffb95e3a6fd71aa415542391"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvrvk_1_1impl_1_1_command_buffer_base__.html#a6e36ba62ffb95e3a6fd71aa415542391">setLineWidth</a> (float lineWidth)</td></tr>
<tr class="memdesc:a6e36ba62ffb95e3a6fd71aa415542391"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the dynamic line width state affecting pipeline objects created with VK_DYNAMIC_STATE_LINE_WIDTH enabled. <a href="#a6e36ba62ffb95e3a6fd71aa415542391">More...</a><br/></td></tr>
<tr class="separator:a6e36ba62ffb95e3a6fd71aa415542391"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae323b1f0833e0e90489612e897c78821"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvrvk_1_1impl_1_1_device_object_debug_marker.html#ae323b1f0833e0e90489612e897c78821">setObjectName</a> (const std::string &amp;objectName)</td></tr>
<tr class="memdesc:ae323b1f0833e0e90489612e897c78821"><td class="mdescLeft">&#160;</td><td class="mdescRight">Makes use of the extension VK_EXT_debug_marker to provide a name for a specified object. <a href="#ae323b1f0833e0e90489612e897c78821">More...</a><br/></td></tr>
<tr class="separator:ae323b1f0833e0e90489612e897c78821"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a90a2912d1e2fb065219b50eb55fbfd34"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvrvk_1_1impl_1_1_device_object_debug_marker.html#a90a2912d1e2fb065219b50eb55fbfd34">setObjectTag</a> (uint64_t tagName, size_t tagSize, const void *tag)</td></tr>
<tr class="memdesc:a90a2912d1e2fb065219b50eb55fbfd34"><td class="mdescLeft">&#160;</td><td class="mdescRight">Makes use of the extension VK_EXT_debug_marker to provide a tag for a specified object. <a href="#a90a2912d1e2fb065219b50eb55fbfd34">More...</a><br/></td></tr>
<tr class="separator:a90a2912d1e2fb065219b50eb55fbfd34"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a73ee4dbcda7a265e6b5898a1a9d052d2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvrvk_1_1impl_1_1_command_buffer_base__.html#a73ee4dbcda7a265e6b5898a1a9d052d2">setScissor</a> (uint32_t firstScissor, uint32_t numScissors, const Rect2D *scissors)</td></tr>
<tr class="memdesc:a73ee4dbcda7a265e6b5898a1a9d052d2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the dynamic scissor state affecting pipeline objects created with VK_DYNAMIC_STATE_SCISSOR enabled. <a href="#a73ee4dbcda7a265e6b5898a1a9d052d2">More...</a><br/></td></tr>
<tr class="separator:a73ee4dbcda7a265e6b5898a1a9d052d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acef9f36e3f5383594c1f561fa800aff7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvrvk_1_1impl_1_1_command_buffer_base__.html#acef9f36e3f5383594c1f561fa800aff7">setStencilCompareMask</a> (StencilFaceFlags face, uint32_t compareMask)</td></tr>
<tr class="memdesc:acef9f36e3f5383594c1f561fa800aff7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the dynamic stencil compare mask state affecting pipeline objects created with VK_DYNAMIC_STATE_STENCIL_COMPARE_MASK enabled. <a href="#acef9f36e3f5383594c1f561fa800aff7">More...</a><br/></td></tr>
<tr class="separator:acef9f36e3f5383594c1f561fa800aff7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc42ff2f511f268d68d0901b6281326d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvrvk_1_1impl_1_1_command_buffer_base__.html#adc42ff2f511f268d68d0901b6281326d">setStencilReference</a> (StencilFaceFlags face, uint32_t reference)</td></tr>
<tr class="memdesc:adc42ff2f511f268d68d0901b6281326d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the dynamic stencil reference mask state affecting pipeline objects created with VK_DYNAMIC_STATE_STENCIL_REFERENCE enabled. <a href="#adc42ff2f511f268d68d0901b6281326d">More...</a><br/></td></tr>
<tr class="separator:adc42ff2f511f268d68d0901b6281326d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3837e03b54149248c01087d7f77dd9f8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvrvk_1_1impl_1_1_command_buffer_base__.html#a3837e03b54149248c01087d7f77dd9f8">setStencilWriteMask</a> (StencilFaceFlags face, uint32_t writeMask)</td></tr>
<tr class="memdesc:a3837e03b54149248c01087d7f77dd9f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the dynamic stencil write mask state affecting pipeline objects created with VK_DYNAMIC_STATE_STENCIL_WRITE_MASK enabled. <a href="#a3837e03b54149248c01087d7f77dd9f8">More...</a><br/></td></tr>
<tr class="separator:a3837e03b54149248c01087d7f77dd9f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b850bccfeda750ecb9e2c98c8c2b018"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvrvk_1_1impl_1_1_command_buffer_base__.html#a8b850bccfeda750ecb9e2c98c8c2b018">setViewport</a> (const Viewport &amp;viewport)</td></tr>
<tr class="memdesc:a8b850bccfeda750ecb9e2c98c8c2b018"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set viewport <a href="#a8b850bccfeda750ecb9e2c98c8c2b018">More...</a><br/></td></tr>
<tr class="separator:a8b850bccfeda750ecb9e2c98c8c2b018"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ec18d08b6609a9078a081fa31f3ce77"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvrvk_1_1impl_1_1_command_buffer_base__.html#a9ec18d08b6609a9078a081fa31f3ce77">updateBuffer</a> (<a class="el" href="namespacepvrvk.html#a2a117db0aab25382d050908b2bfa4c8b">Buffer</a> &amp;buffer, const void *data, uint32_t offset, uint32_t length)</td></tr>
<tr class="memdesc:a9ec18d08b6609a9078a081fa31f3ce77"><td class="mdescLeft">&#160;</td><td class="mdescRight">Updates buffer data inline in a command buffer. The update is only allowed outside of a renderpass and is treated as a transfer operation for the purposes of syncrhonization. <a href="#a9ec18d08b6609a9078a081fa31f3ce77">More...</a><br/></td></tr>
<tr class="separator:a9ec18d08b6609a9078a081fa31f3ce77"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff7cfaed7300edd34cd1de176278e516"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvrvk_1_1impl_1_1_command_buffer_base__.html#aff7cfaed7300edd34cd1de176278e516">waitForEvent</a> (const <a class="el" href="namespacepvrvk.html#a6696a17453f99f2b221a28bb05e4934b">Event</a> &amp;event, PipelineStageFlags srcStage, PipelineStageFlags dstStage, const <a class="el" href="classpvrvk_1_1_memory_barrier_set.html">MemoryBarrierSet</a> &amp;barriers)</td></tr>
<tr class="memdesc:aff7cfaed7300edd34cd1de176278e516"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defines a memory dependency between prior event signal operations and subsequent commands. <a href="#aff7cfaed7300edd34cd1de176278e516">More...</a><br/></td></tr>
<tr class="separator:aff7cfaed7300edd34cd1de176278e516"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b7063f61ca8234126f81ec9625153e7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvrvk_1_1impl_1_1_command_buffer_base__.html#a8b7063f61ca8234126f81ec9625153e7">waitForEvents</a> (const <a class="el" href="namespacepvrvk.html#a6696a17453f99f2b221a28bb05e4934b">Event</a> *events, uint32_t numEvents, PipelineStageFlags srcStage, PipelineStageFlags dstStage, const <a class="el" href="classpvrvk_1_1_memory_barrier_set.html">MemoryBarrierSet</a> &amp;barriers)</td></tr>
<tr class="memdesc:a8b7063f61ca8234126f81ec9625153e7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defines a set of memory dependencies between prior event signal operations and subsequent commands. <a href="#a8b7063f61ca8234126f81ec9625153e7">More...</a><br/></td></tr>
<tr class="separator:a8b7063f61ca8234126f81ec9625153e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09fc5e0ce68a45bfda286a3a02fec71b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvrvk_1_1impl_1_1_command_buffer_base__.html#a09fc5e0ce68a45bfda286a3a02fec71b">writeTimestamp</a> (<a class="el" href="namespacepvrvk.html#a9775dff694169a1bafd336a1a64508f7">QueryPool</a> &amp;queryPool, uint32_t queryIndex, PipelineStageFlags pipelineStage)</td></tr>
<tr class="memdesc:a09fc5e0ce68a45bfda286a3a02fec71b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Requests a timestamp for a particular QueryPool to be written to the query. <a href="#a09fc5e0ce68a45bfda286a3a02fec71b">More...</a><br/></td></tr>
<tr class="separator:a09fc5e0ce68a45bfda286a3a02fec71b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:aa6ff16a7e0728a785f1367dfb33d6099"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacepvrvk.html#a8dd5932a80187b088ce6b591712dc2c2">DeviceWeakPtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvrvk_1_1impl_1_1_device_object_handle.html#aa6ff16a7e0728a785f1367dfb33d6099">_device</a></td></tr>
<tr class="memdesc:aa6ff16a7e0728a785f1367dfb33d6099"><td class="mdescLeft">&#160;</td><td class="mdescRight">The device which was used to create this DeviceObject <a href="#aa6ff16a7e0728a785f1367dfb33d6099">More...</a><br/></td></tr>
<tr class="separator:aa6ff16a7e0728a785f1367dfb33d6099"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a759e4e7ca81cb8812048075ddcf274d6"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvrvk_1_1impl_1_1_command_buffer_base__.html#a759e4e7ca81cb8812048075ddcf274d6">_isRecording</a></td></tr>
<tr class="memdesc:a759e4e7ca81cb8812048075ddcf274d6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specifies whether the command buffer is currently in the recording state which is controlled via calling the begin function. <a href="#a759e4e7ca81cb8812048075ddcf274d6">More...</a><br/></td></tr>
<tr class="separator:a759e4e7ca81cb8812048075ddcf274d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a943d27103dec9450a0966c8352aef979"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacepvrvk.html#a946a7145c9e18b9a797fa714ce677f32">ComputePipeline</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvrvk_1_1impl_1_1_command_buffer_base__.html#a943d27103dec9450a0966c8352aef979">_lastBoundComputePipe</a></td></tr>
<tr class="memdesc:a943d27103dec9450a0966c8352aef979"><td class="mdescLeft">&#160;</td><td class="mdescRight">Holds a reference to the last bound compute pipeline. This can then be used for optimising binding the same compute pipeline repeatedly. <a href="#a943d27103dec9450a0966c8352aef979">More...</a><br/></td></tr>
<tr class="separator:a943d27103dec9450a0966c8352aef979"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa0f1be52e5e2affe2a3f57ea68a8d036"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacepvrvk.html#aa2443b681960df638797cf93bbf33fb7">GraphicsPipeline</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvrvk_1_1impl_1_1_command_buffer_base__.html#aa0f1be52e5e2affe2a3f57ea68a8d036">_lastBoundGraphicsPipe</a></td></tr>
<tr class="memdesc:aa0f1be52e5e2affe2a3f57ea68a8d036"><td class="mdescLeft">&#160;</td><td class="mdescRight">Holds a reference to the last bound graphics pipeline. This can be used for optimising binding the same graphics pipeline repeatedly. <a href="#aa0f1be52e5e2affe2a3f57ea68a8d036">More...</a><br/></td></tr>
<tr class="separator:aa0f1be52e5e2affe2a3f57ea68a8d036"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a402866281f61adadea66db94a0e25794"><td class="memItemLeft" align="right" valign="top">std::vector<br class="typebreak"/>
&lt; EmbeddedRefCountedResource<br class="typebreak"/>
&lt; void &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvrvk_1_1impl_1_1_command_buffer_base__.html#a402866281f61adadea66db94a0e25794">_objectReferences</a></td></tr>
<tr class="memdesc:a402866281f61adadea66db94a0e25794"><td class="mdescLeft">&#160;</td><td class="mdescRight">Holds a list of references to the objects currently in use by this command buffer. This ensures that objects are kept alive through reference counting until the command buffer is finished with them. <a href="#a402866281f61adadea66db94a0e25794">More...</a><br/></td></tr>
<tr class="separator:a402866281f61adadea66db94a0e25794"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb4cc024978587b241ae65a8541d5815"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacepvrvk.html#ac9949394db8b3d968a7402b837567f87">CommandPool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvrvk_1_1impl_1_1_command_buffer_base__.html#adb4cc024978587b241ae65a8541d5815">_pool</a></td></tr>
<tr class="memdesc:adb4cc024978587b241ae65a8541d5815"><td class="mdescLeft">&#160;</td><td class="mdescRight">The command pool from which this command buffer was allocated. <a href="#adb4cc024978587b241ae65a8541d5815">More...</a><br/></td></tr>
<tr class="separator:adb4cc024978587b241ae65a8541d5815"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41f43268ad1a7d2d3bde2a228fbcac03"><td class="memItemLeft" align="right" valign="top">VkCommandBuffer&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvrvk_1_1impl_1_1_object_handle.html#a41f43268ad1a7d2d3bde2a228fbcac03">_vkHandle</a></td></tr>
<tr class="memdesc:a41f43268ad1a7d2d3bde2a228fbcac03"><td class="mdescLeft">&#160;</td><td class="mdescRight">The Vulkan object handle representing the Vulkan object at an API level. <a href="#a41f43268ad1a7d2d3bde2a228fbcac03">More...</a><br/></td></tr>
<tr class="separator:a41f43268ad1a7d2d3bde2a228fbcac03"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Contains all the commands and states that need to be submitted to the gpu, including pipeline, texture, and samplers. Virtually everything that needs to happen on the GPU is submitted to the CommandBuffer. </p>
<p>Secondary command buffers cannot contain RenderPasses, and cannot be submitted to the GPU. SecondaryCommandBuffers can be submitted to the primaryCommandBuffer -It is invalid to submit commands to a command buffer while it is not being recorded. -It is invalid to reset a command buffer while it is being recorded. -It is invalid to submit a command buffer more than once if it is one time submit command buffer -Draw commands must be between a BeginRenderpass and an EndRenderpass command</p>
</div><h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="a6d449edb8cf90b9c237f940f0b561a9c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void pvrvk::impl::CommandBufferBase_::begin </td>
          <td>(</td>
          <td class="paramtype">const CommandBufferUsageFlags&#160;</td>
          <td class="paramname"><em>flags</em> = <code>CommandBufferUsageFlags(0)</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Call this function before beginning to record commands.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">flags</td><td>Flags is a bitmask of CommandBufferUsageFlags specifying usage behavior for the command buffer.</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a09d9e885485c1753a0b13f9ab07a78f6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pvrvk::impl::SecondaryCommandBuffer_::begin </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacepvrvk.html#a55f833c5feaaa65f3aaed3a08a7a55e6">RenderPass</a> &amp;&#160;</td>
          <td class="paramname"><em>renderpass</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>subpass</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const CommandBufferUsageFlags&#160;</td>
          <td class="paramname"><em>flags</em> = <code>CommandBufferUsageFlags::e_RENDER_PASS_CONTINUE_BIT</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Call this function before beginning to record commands. If the Framebuffer object is known, prefer the Framebuffer overload as it may offer better performance.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">renderpass</td><td>A RenderPass object defining which render passes this SecondaryCommandBuffer will be compatible with and can be executed within.</td></tr>
    <tr><td class="paramname">subpass</td><td>The index of the subpass within the render pass instance that this CommandBuffer will be executed within.</td></tr>
    <tr><td class="paramname">flags</td><td>Flags is a bitmask of CommandBufferUsageFlagBits specifying usage behavior for the command buffer.</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a574e16f7068cd5d978b627c9582ac7b9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pvrvk::impl::SecondaryCommandBuffer_::begin </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacepvrvk.html#a7639515cddb57ed4370a5ce02287988a">Framebuffer</a> &amp;&#160;</td>
          <td class="paramname"><em>framebuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>subpass</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const CommandBufferUsageFlags&#160;</td>
          <td class="paramname"><em>flags</em> = <code>CommandBufferUsageFlags::e_RENDER_PASS_CONTINUE_BIT</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Call this function before beginning to record commands.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">framebuffer</td><td>Refers to an Framebuffer object that this CommandBuffer will be rendering to if it is executed within a render pass instance.</td></tr>
    <tr><td class="paramname">subpass</td><td>The index of the subpass within the render pass instance that this CommandBuffer will be executed within.</td></tr>
    <tr><td class="paramname">flags</td><td>Flags is a bitmask of CommandBufferUsageFlagBits specifying usage behavior for the command buffer.</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a862a03340dc1812389fca32ceaffa881"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void pvrvk::impl::CommandBufferBase_::beginQuery </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacepvrvk.html#a9775dff694169a1bafd336a1a64508f7">QueryPool</a> &amp;&#160;</td>
          <td class="paramname"><em>queryPool</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>queryIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">QueryControlFlags&#160;</td>
          <td class="paramname"><em>flags</em> = <code>QueryControlFlags(0)</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Begins a query for a particular QueryPool.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">queryPool</td><td>Specifies the query pool which will manage the results of the query.</td></tr>
    <tr><td class="paramname">queryIndex</td><td>The query index within the QueryPool which will contain the results.</td></tr>
    <tr><td class="paramname">flags</td><td>Specifies the Query Control Flag bits which provide constraints on the type of queries that can be performed.</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a37e81e963a89f7b2b16112acb4c01d54"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void pvrvk::impl::CommandBufferBase_::bindDescriptorSet </td>
          <td>(</td>
          <td class="paramtype">PipelineBindPoint&#160;</td>
          <td class="paramname"><em>bindingPoint</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacepvrvk.html#a34bb21497524a13e145b1398450989d0">PipelineLayout</a> &amp;&#160;</td>
          <td class="paramname"><em>pipelineLayout</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>firstSet</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacepvrvk.html#afaa5d3390eb48fd21197430158a7d5ac">DescriptorSet</a>&#160;</td>
          <td class="paramname"><em>set</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint32_t *&#160;</td>
          <td class="paramname"><em>dynamicOffsets</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>numDynamicOffsets</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Bind descriptorset</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bindingPoint</td><td><a class="el" href="classpvrvk_1_1impl_1_1_pipeline.html" title="A Graphics Pipeline is a PVRVk adapter to a Vulkan Pipeline to a pipeline created for VK_PIPELINE_BIN...">Pipeline</a> binding point</td></tr>
    <tr><td class="paramname">pipelineLayout</td><td><a class="el" href="classpvrvk_1_1impl_1_1_pipeline.html" title="A Graphics Pipeline is a PVRVk adapter to a Vulkan Pipeline to a pipeline created for VK_PIPELINE_BIN...">Pipeline</a> layout</td></tr>
    <tr><td class="paramname">firstSet</td><td>The set number of the first descriptor set to be bound</td></tr>
    <tr><td class="paramname">set</td><td>Descriptor set to be bound</td></tr>
    <tr><td class="paramname">dynamicOffsets</td><td>Pointer to an array of uint</td></tr>
  </table>
  </dd>
</dl>
<p>32_t values specifying dynamic offsets </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">numDynamicOffsets</td><td>Number of dynamic offsets</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="af5d43d0aee637c66a1137e0e32d1c09f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void pvrvk::impl::CommandBufferBase_::bindDescriptorSets </td>
          <td>(</td>
          <td class="paramtype">PipelineBindPoint&#160;</td>
          <td class="paramname"><em>bindingPoint</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacepvrvk.html#a34bb21497524a13e145b1398450989d0">PipelineLayout</a> &amp;&#160;</td>
          <td class="paramname"><em>pipelineLayout</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>firstSet</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacepvrvk.html#afaa5d3390eb48fd21197430158a7d5ac">DescriptorSet</a> *&#160;</td>
          <td class="paramname"><em>sets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>numDescriptorSets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint32_t *&#160;</td>
          <td class="paramname"><em>dynamicOffsets</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>numDynamicOffsets</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Bind descriptorsets</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bindingPoint</td><td><a class="el" href="classpvrvk_1_1impl_1_1_pipeline.html" title="A Graphics Pipeline is a PVRVk adapter to a Vulkan Pipeline to a pipeline created for VK_PIPELINE_BIN...">Pipeline</a> binding point</td></tr>
    <tr><td class="paramname">pipelineLayout</td><td><a class="el" href="classpvrvk_1_1impl_1_1_pipeline.html" title="A Graphics Pipeline is a PVRVk adapter to a Vulkan Pipeline to a pipeline created for VK_PIPELINE_BIN...">Pipeline</a> layout</td></tr>
    <tr><td class="paramname">firstSet</td><td>The set number of the first descriptor set to be bound</td></tr>
    <tr><td class="paramname">sets</td><td>Pointer to the descriptor sets to be bound</td></tr>
    <tr><td class="paramname">numDescriptorSets</td><td>Number of descriptor sets</td></tr>
    <tr><td class="paramname">dynamicOffsets</td><td>Pointer to an array of uint</td></tr>
  </table>
  </dd>
</dl>
<p>32_t values specifying dynamic offsets </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">numDynamicOffsets</td><td>Number of dynamic offsets</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aa66ee757605ffa9afa68bf95ab9c7adf"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void pvrvk::impl::CommandBufferBase_::bindIndexBuffer </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacepvrvk.html#a2a117db0aab25382d050908b2bfa4c8b">Buffer</a> &amp;&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IndexType&#160;</td>
          <td class="paramname"><em>indexType</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Bind index bufer</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buffer</td><td>Imdex buffer</td></tr>
    <tr><td class="paramname">offset</td><td>Buffer offset</td></tr>
    <tr><td class="paramname">indexType</td><td>IndexType</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="adfc394932317683fb0582841423527b2"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void pvrvk::impl::CommandBufferBase_::bindPipeline </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacepvrvk.html#aa2443b681960df638797cf93bbf33fb7">GraphicsPipeline</a> &amp;&#160;</td>
          <td class="paramname"><em>pipeline</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Bind a graphics pipeline.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pipeline</td><td>The GraphicsPipeline to bind.</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a79d2f3d38f2aad3fa3ba4b7b793d1421"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void pvrvk::impl::CommandBufferBase_::bindPipeline </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacepvrvk.html#a946a7145c9e18b9a797fa714ce677f32">ComputePipeline</a> &amp;&#160;</td>
          <td class="paramname"><em>pipeline</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Bind a compute pipeline</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pipeline</td><td>The ComputePipeline to bind</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a2382fc789d3e96d50693f9e5483ff0b0"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void pvrvk::impl::CommandBufferBase_::bindVertexBuffer </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacepvrvk.html#a2a117db0aab25382d050908b2bfa4c8b">Buffer</a> &amp;&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>bindingIndex</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Bind vertex buffer</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buffer</td><td>Buffer</td></tr>
    <tr><td class="paramname">offset</td><td>Buffer offset</td></tr>
    <tr><td class="paramname">bindingIndex</td><td>The index of the vertex input binding whose state is updated by the command. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a2853f758e9e70e100e3140405fc8e03c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void pvrvk::impl::CommandBufferBase_::bindVertexBuffer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacepvrvk.html#a2a117db0aab25382d050908b2bfa4c8b">Buffer</a> const *&#160;</td>
          <td class="paramname"><em>buffers</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>offsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>numBuffers</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>startBinding</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>numBindings</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Bind vertex buffer</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buffers</td><td>Buffers to be bound</td></tr>
    <tr><td class="paramname">offsets</td><td>Pointer to an array of buffer offsets.</td></tr>
    <tr><td class="paramname">numBuffers</td><td>number of buffers</td></tr>
    <tr><td class="paramname">startBinding</td><td>The indices of the first vertex input binding whose state is updated by the command.</td></tr>
    <tr><td class="paramname">numBindings</td><td>Number of bindings</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a88093ef10da31dcaa3846beb36617bbb"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void pvrvk::impl::CommandBufferBase_::blitImage </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacepvrvk.html#a0dde8112e297d1089979fbdbdcbbe0f4">Image</a> &amp;&#160;</td>
          <td class="paramname"><em>srcImage</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacepvrvk.html#a0dde8112e297d1089979fbdbdcbbe0f4">Image</a> &amp;&#160;</td>
          <td class="paramname"><em>dstImage</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ImageBlit *&#160;</td>
          <td class="paramname"><em>regions</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>numRegions</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Filter&#160;</td>
          <td class="paramname"><em>filter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ImageLayout&#160;</td>
          <td class="paramname"><em>srcLayout</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ImageLayout&#160;</td>
          <td class="paramname"><em>dstLayout</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copies regions of a src image into a dst image, potentially also performing format conversions, aritrary scaling and filtering.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">srcImage</td><td>The src Image in the copy.</td></tr>
    <tr><td class="paramname">dstImage</td><td>The dst image.</td></tr>
    <tr><td class="paramname">regions</td><td>A pointer to an array of ImageBlitRange structures specifying the regions to blit.</td></tr>
    <tr><td class="paramname">numRegions</td><td>The number of regions to blit.</td></tr>
    <tr><td class="paramname">filter</td><td>A Filter specifying the filter to apply if the blits require scaling</td></tr>
    <tr><td class="paramname">srcLayout</td><td>The layout of the src image subresrcs for the blit.</td></tr>
    <tr><td class="paramname">dstLayout</td><td>The layout of the dst image subresrcs for the blit.</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a26d8498fee836c63989072eb483d8938"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void pvrvk::impl::CommandBufferBase_::clearAttachment </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structpvrvk_1_1_clear_attachment.html">ClearAttachment</a> &amp;&#160;</td>
          <td class="paramname"><em>clearAttachment</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ClearRect &amp;&#160;</td>
          <td class="paramname"><em>clearRectangle</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Clears a particular attachment using a provided region whilst inside of a renderpass.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">clearAttachment</td><td>A single <a class="el" href="structpvrvk_1_1_clear_attachment.html" title="ClearAttachment structures defining the attachments to clear and the clear values to use...">ClearAttachment</a> structure defining the attachment to clear and the clear value to use</td></tr>
    <tr><td class="paramname">clearRectangle</td><td>A ClearRect structure defining a region within the attachment to clear</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ac681c14ddfb7b443d318e695633571b5"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void pvrvk::impl::CommandBufferBase_::clearAttachments </td>
          <td>(</td>
          <td class="paramtype">const uint32_t&#160;</td>
          <td class="paramname"><em>numAttachments</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structpvrvk_1_1_clear_attachment.html">ClearAttachment</a> *&#160;</td>
          <td class="paramname"><em>clearAttachments</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>numRectangles</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ClearRect *&#160;</td>
          <td class="paramname"><em>clearRectangles</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Clear a set of attacments using a number of regions for each selected attachment to clear whilst inside a renderpass.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">numAttachments</td><td>The number of entries in the clearAttachments array.</td></tr>
    <tr><td class="paramname">clearAttachments</td><td>Is a pointer to an array of <a class="el" href="structpvrvk_1_1_clear_attachment.html" title="ClearAttachment structures defining the attachments to clear and the clear values to use...">ClearAttachment</a> structures which defines the attachments to clear and the clear values to use.</td></tr>
    <tr><td class="paramname">numRectangles</td><td>Is the number of entries in the clearRects array.</td></tr>
    <tr><td class="paramname">clearRectangles</td><td>Points to an array of ClearRect structures defining regions within each selected attachment to clear.</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a0b76e94f5959d34d1fd15be43a9d0b6e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void pvrvk::impl::CommandBufferBase_::clearColorImage </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacepvrvk.html#ad4da214c95fffe4edccb14eb2c270f07">ImageView</a> &amp;&#160;</td>
          <td class="paramname"><em>image</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structpvrvk_1_1_clear_color_value.html">ClearColorValue</a> &amp;&#160;</td>
          <td class="paramname"><em>clearColor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ImageLayout&#160;</td>
          <td class="paramname"><em>currentLayout</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint32_t&#160;</td>
          <td class="paramname"><em>baseMipLevel</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint32_t&#160;</td>
          <td class="paramname"><em>numLevels</em> = <code>1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint32_t&#160;</td>
          <td class="paramname"><em>baseArrayLayer</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint32_t&#160;</td>
          <td class="paramname"><em>numLayers</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Clears a color image outside of a renderpass instance.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">image</td><td>Image to clear</td></tr>
    <tr><td class="paramname">clearColor</td><td>Clear color value</td></tr>
    <tr><td class="paramname">currentLayout</td><td>Image current layout</td></tr>
    <tr><td class="paramname">baseMipLevel</td><td>Base mip map level to clear</td></tr>
    <tr><td class="paramname">numLevels</td><td>Number of mipmap levels to clear</td></tr>
    <tr><td class="paramname">baseArrayLayer</td><td>Base array layer to clear</td></tr>
    <tr><td class="paramname">numLayers</td><td>Number of array layers to clear</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a57c9d24c5b0f0486c9ab5602269edf4a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void pvrvk::impl::CommandBufferBase_::clearColorImage </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacepvrvk.html#ad4da214c95fffe4edccb14eb2c270f07">ImageView</a> &amp;&#160;</td>
          <td class="paramname"><em>image</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structpvrvk_1_1_clear_color_value.html">ClearColorValue</a> &amp;&#160;</td>
          <td class="paramname"><em>clearColor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ImageLayout&#160;</td>
          <td class="paramname"><em>currentLayout</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint32_t *&#160;</td>
          <td class="paramname"><em>baseMipLevels</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint32_t *&#160;</td>
          <td class="paramname"><em>numLevels</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint32_t *&#160;</td>
          <td class="paramname"><em>baseArrayLayers</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint32_t *&#160;</td>
          <td class="paramname"><em>numLayers</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>numRanges</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Clears a color image outside of a renderpass instance using a number of ranges.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">image</td><td>Image to clear.</td></tr>
    <tr><td class="paramname">clearColor</td><td>Clear color value.</td></tr>
    <tr><td class="paramname">currentLayout</td><td>Image current layout.</td></tr>
    <tr><td class="paramname">baseMipLevels</td><td>Base mip map level to clear.</td></tr>
    <tr><td class="paramname">numLevels</td><td>A pointer to an array of a number of mipmap levels to clear.</td></tr>
    <tr><td class="paramname">baseArrayLayers</td><td>A pointer to an array of base array layers to clear.</td></tr>
    <tr><td class="paramname">numLayers</td><td>A pointer to an array array layers to clear.</td></tr>
    <tr><td class="paramname">numRanges</td><td>The number of elements in the baseMipLevel, numLevels, baseArrayLayers and numLayers arrays.</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a77fa9538ba0fcb3c2dc77f5e58a90e55"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void pvrvk::impl::CommandBufferBase_::clearDepthImage </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacepvrvk.html#a0dde8112e297d1089979fbdbdcbbe0f4">Image</a> &amp;&#160;</td>
          <td class="paramname"><em>image</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>clearDepth</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint32_t&#160;</td>
          <td class="paramname"><em>baseMipLevel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint32_t&#160;</td>
          <td class="paramname"><em>numLevels</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint32_t&#160;</td>
          <td class="paramname"><em>baseArrayLayer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint32_t&#160;</td>
          <td class="paramname"><em>numLayers</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ImageLayout&#160;</td>
          <td class="paramname"><em>layout</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Clear depth image outside of a renderpass instance.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">image</td><td>Image to clear</td></tr>
    <tr><td class="paramname">clearDepth</td><td>Clear value</td></tr>
    <tr><td class="paramname">baseMipLevel</td><td>Base mip map level to clear </td></tr>
    <tr><td class="paramname">numLevels</td><td>Number of mipmap levels to clear</td></tr>
    <tr><td class="paramname">baseArrayLayer</td><td>Base arraylayer to clear</td></tr>
    <tr><td class="paramname">numLayers</td><td>Number of array layers to clear</td></tr>
    <tr><td class="paramname">layout</td><td>Current layout of the image</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a7e669f8997f42c5d9ae85222efa53c5a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void pvrvk::impl::CommandBufferBase_::clearDepthImage </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacepvrvk.html#a0dde8112e297d1089979fbdbdcbbe0f4">Image</a> &amp;&#160;</td>
          <td class="paramname"><em>image</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>clearDepth</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint32_t *&#160;</td>
          <td class="paramname"><em>baseMipLevels</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint32_t *&#160;</td>
          <td class="paramname"><em>numLevels</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint32_t *&#160;</td>
          <td class="paramname"><em>baseArrayLayers</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint32_t *&#160;</td>
          <td class="paramname"><em>numLayers</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>numRanges</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ImageLayout&#160;</td>
          <td class="paramname"><em>layout</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Clears the depth image outside of a renderpass instance using a number of ranges.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">image</td><td>Image to clear</td></tr>
    <tr><td class="paramname">clearDepth</td><td>Clear depth value</td></tr>
    <tr><td class="paramname">baseMipLevels</td><td>A pointer to an array of base mip map levels to clear</td></tr>
    <tr><td class="paramname">numLevels</td><td>A pointer to an array of the number of mipmap levels to clear</td></tr>
    <tr><td class="paramname">baseArrayLayers</td><td>A pointer to an array of base array layers to clear</td></tr>
    <tr><td class="paramname">numLayers</td><td>A pointer to an array of the number of layers to clear</td></tr>
    <tr><td class="paramname">numRanges</td><td>A number of ranges of the stencil image to clear. This number will be used as the number of array elements in the arrays passed to baseMipLevels, numLevels, baseArrayLayers and numLayers</td></tr>
    <tr><td class="paramname">layout</td><td>Image current layout</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a0c4d7f8b6ddcd8f4a22adea5c0474bc9"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void pvrvk::impl::CommandBufferBase_::clearDepthStencilImage </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacepvrvk.html#a0dde8112e297d1089979fbdbdcbbe0f4">Image</a> &amp;&#160;</td>
          <td class="paramname"><em>image</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>clearDepth</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>clearStencil</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint32_t&#160;</td>
          <td class="paramname"><em>baseMipLevel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint32_t&#160;</td>
          <td class="paramname"><em>numLevels</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint32_t&#160;</td>
          <td class="paramname"><em>baseArrayLayer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint32_t&#160;</td>
          <td class="paramname"><em>numLayers</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ImageLayout&#160;</td>
          <td class="paramname"><em>layout</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Clear depth stencil image outside of a renderpass instance.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">image</td><td>Image to clear</td></tr>
    <tr><td class="paramname">clearDepth</td><td>Clear depth value</td></tr>
    <tr><td class="paramname">clearStencil</td><td>Clear stencil value</td></tr>
    <tr><td class="paramname">baseMipLevel</td><td>Base mip map level to clear</td></tr>
    <tr><td class="paramname">numLevels</td><td>Number of mipmap levels to clear</td></tr>
    <tr><td class="paramname">baseArrayLayer</td><td>Base array layer to clear</td></tr>
    <tr><td class="paramname">numLayers</td><td>Number of array layers to clear</td></tr>
    <tr><td class="paramname">layout</td><td>Image current layout</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aadc22a2bd68016cfcb03a4eba0adb3f4"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void pvrvk::impl::CommandBufferBase_::clearDepthStencilImage </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacepvrvk.html#a0dde8112e297d1089979fbdbdcbbe0f4">Image</a> &amp;&#160;</td>
          <td class="paramname"><em>image</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>clearDepth</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>clearStencil</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint32_t *&#160;</td>
          <td class="paramname"><em>baseMipLevels</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint32_t *&#160;</td>
          <td class="paramname"><em>numLevels</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint32_t *&#160;</td>
          <td class="paramname"><em>baseArrayLayers</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint32_t *&#160;</td>
          <td class="paramname"><em>numLayers</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>numRanges</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ImageLayout&#160;</td>
          <td class="paramname"><em>layout</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Clear depth stencil image outside of a renderpass instance using a number of ranges.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">image</td><td>Image to clear</td></tr>
    <tr><td class="paramname">clearDepth</td><td>Clear depth value</td></tr>
    <tr><td class="paramname">clearStencil</td><td>Clear stencil value</td></tr>
    <tr><td class="paramname">baseMipLevels</td><td>A pointer to an array of base mip map levels to clear</td></tr>
    <tr><td class="paramname">numLevels</td><td>A pointer to an array of the number of mipmap levels to clear</td></tr>
    <tr><td class="paramname">baseArrayLayers</td><td>A pointer to an array of base array layers to clear</td></tr>
    <tr><td class="paramname">numLayers</td><td>A pointer to an array of the number of layers to clear</td></tr>
    <tr><td class="paramname">numRanges</td><td>A number of ranges of the depth stencil image to clear. This number will be used as the number of array elements in the arrays passed to baseMipLevels, numLevels, baseArrayLayers and numLayers</td></tr>
    <tr><td class="paramname">layout</td><td>Image current layout</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a300280c8edf7996f94fba4e634f56a18"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void pvrvk::impl::CommandBufferBase_::clearStencilImage </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacepvrvk.html#a0dde8112e297d1089979fbdbdcbbe0f4">Image</a> &amp;&#160;</td>
          <td class="paramname"><em>image</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>clearStencil</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint32_t&#160;</td>
          <td class="paramname"><em>baseMipLevel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint32_t&#160;</td>
          <td class="paramname"><em>numLevels</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint32_t&#160;</td>
          <td class="paramname"><em>baseArrayLayer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint32_t&#160;</td>
          <td class="paramname"><em>numLayers</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ImageLayout&#160;</td>
          <td class="paramname"><em>layout</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Clears a stencil image outside of a renderpass instance.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">image</td><td>Image to clear</td></tr>
    <tr><td class="paramname">clearStencil</td><td>Clear stencil value</td></tr>
    <tr><td class="paramname">baseMipLevel</td><td>Base mip map level to clear</td></tr>
    <tr><td class="paramname">numLevels</td><td>Number of mipmap levels to clear</td></tr>
    <tr><td class="paramname">baseArrayLayer</td><td>Base array layer to clear</td></tr>
    <tr><td class="paramname">numLayers</td><td>Number of array layers to clear</td></tr>
    <tr><td class="paramname">layout</td><td>Image current layout</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a4fafdc0e9a578950eaf38bc83931aaba"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void pvrvk::impl::CommandBufferBase_::clearStencilImage </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacepvrvk.html#a0dde8112e297d1089979fbdbdcbbe0f4">Image</a> &amp;&#160;</td>
          <td class="paramname"><em>image</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>clearStencil</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint32_t *&#160;</td>
          <td class="paramname"><em>baseMipLevels</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint32_t *&#160;</td>
          <td class="paramname"><em>numLevels</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint32_t *&#160;</td>
          <td class="paramname"><em>baseArrayLayers</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint32_t *&#160;</td>
          <td class="paramname"><em>numLayers</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>numRanges</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ImageLayout&#160;</td>
          <td class="paramname"><em>layout</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Clear stencil image outside of a renderpass instance using a number of ranges.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">image</td><td>Image to clear</td></tr>
    <tr><td class="paramname">clearStencil</td><td>Clear stencil value</td></tr>
    <tr><td class="paramname">baseMipLevels</td><td>A pointer to an array of base mip map levels to clear</td></tr>
    <tr><td class="paramname">numLevels</td><td>A pointer to an array of the number of mipmap levels to clear</td></tr>
    <tr><td class="paramname">baseArrayLayers</td><td>A pointer to an array of base array layers to clear</td></tr>
    <tr><td class="paramname">numLayers</td><td>A pointer to an array of the number of layers to clear</td></tr>
    <tr><td class="paramname">numRanges</td><td>A number of ranges of the stencil image to clear. This number will be used as the number of array elements in the arrays passed to baseMipLevels, numLevels, baseArrayLayers and numLayers</td></tr>
    <tr><td class="paramname">layout</td><td>Image current layout</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a900d1651d2366f7c5db896d9ddf4b73f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void pvrvk::impl::CommandBufferBase_::copyBuffer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacepvrvk.html#a2a117db0aab25382d050908b2bfa4c8b">Buffer</a>&#160;</td>
          <td class="paramname"><em>srcBuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacepvrvk.html#a2a117db0aab25382d050908b2bfa4c8b">Buffer</a>&#160;</td>
          <td class="paramname"><em>dstBuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>numRegions</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const BufferCopy *&#160;</td>
          <td class="paramname"><em>regions</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy Buffer</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">srcBuffer</td><td>Source buffer</td></tr>
    <tr><td class="paramname">dstBuffer</td><td>Destination buffer</td></tr>
    <tr><td class="paramname">numRegions</td><td>Number of regions to copy</td></tr>
    <tr><td class="paramname">regions</td><td>Pointer to an array of BufferCopy structures specifying the regions to copy. Each region in pRegions is copied from the source buffer to the same region of the destination buffer. srcBuffer and dstBuffer can be the same buffer or alias the same memory, but the result is undefined if the copy regions overlap in memory. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="adb34b2defee7acc83aaaa82f23c16b88"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void pvrvk::impl::CommandBufferBase_::copyBufferToImage </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacepvrvk.html#a2a117db0aab25382d050908b2bfa4c8b">Buffer</a> &amp;&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacepvrvk.html#a0dde8112e297d1089979fbdbdcbbe0f4">Image</a> &amp;&#160;</td>
          <td class="paramname"><em>image</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ImageLayout&#160;</td>
          <td class="paramname"><em>dstImageLayout</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>regionsCount</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const BufferImageCopy *&#160;</td>
          <td class="paramname"><em>regions</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy buffer to image</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buffer</td><td>Source Buffer </td></tr>
    <tr><td class="paramname">image</td><td>Destination image</td></tr>
    <tr><td class="paramname">dstImageLayout</td><td>Destination image's current layout</td></tr>
    <tr><td class="paramname">regionsCount</td><td>Copy regions</td></tr>
    <tr><td class="paramname">regions</td><td>Number of regions</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="adaf1fb46af6d7186a1b631f26b31914a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void pvrvk::impl::CommandBufferBase_::copyImage </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacepvrvk.html#a0dde8112e297d1089979fbdbdcbbe0f4">Image</a> &amp;&#160;</td>
          <td class="paramname"><em>srcImage</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacepvrvk.html#a0dde8112e297d1089979fbdbdcbbe0f4">Image</a> &amp;&#160;</td>
          <td class="paramname"><em>dstImage</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ImageLayout&#160;</td>
          <td class="paramname"><em>srcImageLayout</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ImageLayout&#160;</td>
          <td class="paramname"><em>dstImageLayout</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>numRegions</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ImageCopy *&#160;</td>
          <td class="paramname"><em>regions</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy data between Images</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">srcImage</td><td>Source image</td></tr>
    <tr><td class="paramname">dstImage</td><td>Destination image</td></tr>
    <tr><td class="paramname">srcImageLayout</td><td>Source image layout</td></tr>
    <tr><td class="paramname">dstImageLayout</td><td>Destination image layout</td></tr>
    <tr><td class="paramname">regions</td><td>Regions to copy</td></tr>
    <tr><td class="paramname">numRegions</td><td>Number of regions</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a664eb3e79ee7a405f8daf3425db77d2d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void pvrvk::impl::CommandBufferBase_::copyImageToBuffer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacepvrvk.html#a0dde8112e297d1089979fbdbdcbbe0f4">Image</a> &amp;&#160;</td>
          <td class="paramname"><em>srcImage</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ImageLayout&#160;</td>
          <td class="paramname"><em>srcImageLayout</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacepvrvk.html#a2a117db0aab25382d050908b2bfa4c8b">Buffer</a> &amp;&#160;</td>
          <td class="paramname"><em>dstBuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const BufferImageCopy *&#160;</td>
          <td class="paramname"><em>regions</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>numRegions</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy image to buffer</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">srcImage</td><td>Source image to copy from</td></tr>
    <tr><td class="paramname">srcImageLayout</td><td>Current src image layout</td></tr>
    <tr><td class="paramname">dstBuffer</td><td>Destination buffer</td></tr>
    <tr><td class="paramname">regions</td><td>Regions to copy</td></tr>
    <tr><td class="paramname">numRegions</td><td>Number of regions</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ae7b0c98a25f798bb0af566f3f1238c3c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void pvrvk::impl::CommandBufferBase_::copyQueryPoolResults </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacepvrvk.html#a9775dff694169a1bafd336a1a64508f7">QueryPool</a> &amp;&#160;</td>
          <td class="paramname"><em>queryPool</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>firstQuery</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>queryCount</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacepvrvk.html#a2a117db0aab25382d050908b2bfa4c8b">Buffer</a> &amp;&#160;</td>
          <td class="paramname"><em>dstBuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VkDeviceSize&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VkDeviceSize&#160;</td>
          <td class="paramname"><em>stride</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">QueryResultFlags&#160;</td>
          <td class="paramname"><em>flags</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copies the query statuses and numerical results directly to buffer memory.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">queryPool</td><td>Specifies the query pool which will manage the results of the query.</td></tr>
    <tr><td class="paramname">firstQuery</td><td>The first query index within the QueryPool which will contain the results.</td></tr>
    <tr><td class="paramname">queryCount</td><td>The number of queries.</td></tr>
    <tr><td class="paramname">dstBuffer</td><td>A buffer object which will receive the results of the copy command.</td></tr>
    <tr><td class="paramname">offset</td><td>An offset into dstBuffer.</td></tr>
    <tr><td class="paramname">stride</td><td>The stride in bytes between results for individual queries within dstBuffer.</td></tr>
    <tr><td class="paramname">flags</td><td>Specifies how and when the results are returned.</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aa3feee42a09e91b84646875891a628e2"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void pvrvk::impl::CommandBufferBase_::debugMarkerBeginEXT </td>
          <td>(</td>
          <td class="paramtype">const std::string&#160;</td>
          <td class="paramname"><em>markerName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>r</em> = <code>183.0f&#160;/&#160;255.0f</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>g</em> = <code>26.0f&#160;/&#160;255.0f</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>b</em> = <code>139.0f&#160;/&#160;255.0f</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>a</em> = <code>1.0f</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Begins a debug marked region.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">markerName</td><td>Specifies a name to use for a particular marked region.</td></tr>
    <tr><td class="paramname">r</td><td>The r value to use for the colored marked region.</td></tr>
    <tr><td class="paramname">g</td><td>The g value to use for the colored marked region.</td></tr>
    <tr><td class="paramname">b</td><td>The b value to use for the colored marked region.</td></tr>
    <tr><td class="paramname">a</td><td>The a value to use for the colored marked region.</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a029a7feee509f14715a509ef1de45b26"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void pvrvk::impl::CommandBufferBase_::debugMarkerEndEXT </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Ends a debug marked region.</p>

</div>
</div>
<a class="anchor" id="ad0cb3933b9ca7e276728bf0691d31d1d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void pvrvk::impl::CommandBufferBase_::debugMarkerInsertEXT </td>
          <td>(</td>
          <td class="paramtype">const std::string&#160;</td>
          <td class="paramname"><em>markerName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>r</em> = <code>183.0f&#160;/&#160;255.0f</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>g</em> = <code>26.0f&#160;/&#160;255.0f</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>b</em> = <code>139.0f&#160;/&#160;255.0f</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>a</em> = <code>1.0f</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inserts a debug marker.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">markerName</td><td>Specifies a name to use for a particular marker.</td></tr>
    <tr><td class="paramname">r</td><td>The r value to use for the colored marker.</td></tr>
    <tr><td class="paramname">g</td><td>The g value to use for the colored marker.</td></tr>
    <tr><td class="paramname">b</td><td>The b value to use for the colored marker.</td></tr>
    <tr><td class="paramname">a</td><td>The a value to use for the colored marker.</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a96aeb9ef8d82603dfeac45d2ff177ba2"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void pvrvk::impl::CommandBufferBase_::dispatch </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>numGroupX</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>numGroupY</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>numGroupZ</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Dispatching work provokes work in a compute pipeline. A compute pipeline must be bound to the command buffer before any dispatch commands are recorded.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">numGroupX</td><td>The number of local workgroups to dispatch in the X dimension.</td></tr>
    <tr><td class="paramname">numGroupY</td><td>The number of local workgroups to dispatch in the Y dimension.</td></tr>
    <tr><td class="paramname">numGroupZ</td><td>The number of local workgroups to dispatch in the Z dimension.</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="acb78b08d16568eeb47ffed3294d3f6e2"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void pvrvk::impl::CommandBufferBase_::dispatchIndirect </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacepvrvk.html#a2a117db0aab25382d050908b2bfa4c8b">Buffer</a> &amp;&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>offset</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Dispatching work provokes work in a compute pipeline. A compute pipeline must be bound to the command buffer before any dispatch commands are recorded. dispatchIndirect behaves similarly to dispatch except that the parameters are read by the device from a buffer during execution. The parameters of the dispatch are encoded in a DispatchIndirectCommand structure taken from buffer starting at offset</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buffer</td><td>The buffer containing dispatch parameters.</td></tr>
    <tr><td class="paramname">offset</td><td>The byte offset into buffer where parameters begin.</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a4a38f7566ddeb086f6aa546ee3311288"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void pvrvk::impl::CommandBufferBase_::draw </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>firstVertex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>numVertices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>firstInstance</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>numInstances</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Non-indexed drawing command.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">firstVertex</td><td>The index of the first vertex to draw.</td></tr>
    <tr><td class="paramname">numVertices</td><td>The number of vertices to draw.</td></tr>
    <tr><td class="paramname">firstInstance</td><td>The instance ID of the first instance to draw.</td></tr>
    <tr><td class="paramname">numInstances</td><td>The number of instances to draw.</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a9d0dd5fece38c2da3f474f302f70eba8"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void pvrvk::impl::CommandBufferBase_::drawIndexed </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>firstIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>numIndices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>vertexOffset</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>firstInstance</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>numInstances</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Indexed drawing command.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">firstIndex</td><td>The base index within the index buffer.</td></tr>
    <tr><td class="paramname">numIndices</td><td>The number of vertices to draw.</td></tr>
    <tr><td class="paramname">vertexOffset</td><td>The value added to the vertex index before indexining into the vertex buffer.</td></tr>
    <tr><td class="paramname">firstInstance</td><td>The instance ID of the first instance to draw.</td></tr>
    <tr><td class="paramname">numInstances</td><td>The number of instances to draw.</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a2da4e6e18ae17379fd66ae6a7e3d3eb7"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void pvrvk::impl::CommandBufferBase_::drawIndexedIndirect </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacepvrvk.html#a2a117db0aab25382d050908b2bfa4c8b">Buffer</a> &amp;&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>stride</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Non-indexed indirect drawing command.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buffer</td><td>The buffer containing draw parameters.</td></tr>
    <tr><td class="paramname">offset</td><td>The byte offset into buffer where parameters begin.</td></tr>
    <tr><td class="paramname">count</td><td>The number of draws to execute.</td></tr>
    <tr><td class="paramname">stride</td><td>The byte stride between successive sets of draw commands.</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a38db7b68a0aafa77bc03b5f199843b6c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void pvrvk::impl::CommandBufferBase_::drawIndirect </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacepvrvk.html#a2a117db0aab25382d050908b2bfa4c8b">Buffer</a> &amp;&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>stride</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Non-indexed indirect drawing command.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buffer</td><td>The buffer containing draw parameters.</td></tr>
    <tr><td class="paramname">offset</td><td>The byte offset into buffer where parameters begin.</td></tr>
    <tr><td class="paramname">count</td><td>The number of draws to execute.</td></tr>
    <tr><td class="paramname">stride</td><td>The byte stride between successive sets of draw commands.</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a571250974bf01a908011ca732dbb74d7"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void pvrvk::impl::CommandBufferBase_::end </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Call this function when you are done recording commands. BeginRecording must be called first. </p>

</div>
</div>
<a class="anchor" id="ac1bc81278e124ac66d23eac1fe2dc6cd"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void pvrvk::impl::CommandBufferBase_::endQuery </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacepvrvk.html#a9775dff694169a1bafd336a1a64508f7">QueryPool</a> &amp;&#160;</td>
          <td class="paramname"><em>queryPool</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>queryIndex</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Ends a query for a particular QueryPool.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">queryPool</td><td>Specifies the query pool which will manage the results of the query.</td></tr>
    <tr><td class="paramname">queryIndex</td><td>The query index within the QueryPool which will contain the results.</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a56e3f2184eeb8f9aadaa631c1338179b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void pvrvk::impl::CommandBufferBase_::fillBuffer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacepvrvk.html#a2a117db0aab25382d050908b2bfa4c8b">Buffer</a>&#160;</td>
          <td class="paramname"><em>dstBuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>dstOffset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>size</em> = <code>VK_WHOLE_SIZE</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Clear buffer data</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dstBuffer</td><td>Destination buffer to be filled</td></tr>
    <tr><td class="paramname">dstOffset</td><td>The byte offset into the buffer at which to start filling.</td></tr>
    <tr><td class="paramname">data</td><td>A 4-byte word written repeatedly to the buffer to fill size bytes of data. The data word is written to memory according to the host endianness.</td></tr>
    <tr><td class="paramname">size</td><td>The number of bytes to fill, and must be either a multiple of 4, or VK_WHOLE_SIZE to fill the range from offset to the end of the buffer</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="afbec4fbcfddbaff8fa39c6abf03f21f8"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="namespacepvrvk.html#ac9949394db8b3d968a7402b837567f87">CommandPool</a>&amp; pvrvk::impl::CommandBufferBase_::getCommandPool </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Const getter for the command pool used to allocate this command buffer.</p>
<dl class="section return"><dt>Returns</dt><dd>The command pool used to allocate this command buffer.</dd></dl>

</div>
</div>
<a class="anchor" id="a29d79599ff2851f03e72df701b411fd1"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="namespacepvrvk.html#a8dd5932a80187b088ce6b591712dc2c2">DeviceWeakPtr</a> <a class="el" href="classpvrvk_1_1impl_1_1_device_object_handle.html">pvrvk::impl::DeviceObjectHandle</a>&lt; VkCommandBuffer  &gt;::getDevice </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get Device (const)</p>
<dl class="section return"><dt>Returns</dt><dd>DeviceWeakPtr</dd></dl>

</div>
</div>
<a class="anchor" id="aa78f66f58571440f57204a645383c279"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacepvrvk.html#a8dd5932a80187b088ce6b591712dc2c2">DeviceWeakPtr</a> <a class="el" href="classpvrvk_1_1impl_1_1_device_object_handle.html">pvrvk::impl::DeviceObjectHandle</a>&lt; VkCommandBuffer  &gt;::getDevice </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get Device</p>
<dl class="section return"><dt>Returns</dt><dd>DeviceWeakPtr</dd></dl>

</div>
</div>
<a class="anchor" id="a4f27eddb1090fc657f3af1966d353e0b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const VkCommandBuffer &amp; <a class="el" href="classpvrvk_1_1impl_1_1_object_handle.html">pvrvk::impl::ObjectHandle</a>&lt; VkCommandBuffer  &gt;::getVkHandle </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get vulkan object (const)</p>
<dl class="section return"><dt>Returns</dt><dd>Returns the templated 'HandleType'</dd></dl>

</div>
</div>
<a class="anchor" id="a0f32e4b0b8899d01ff783456befcb5b9"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool pvrvk::impl::CommandBufferBase_::isRecording </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Queries if a command buffer is in the recording state</p>
<dl class="section return"><dt>Returns</dt><dd>True if recording, false otherwise</dd></dl>

</div>
</div>
<a class="anchor" id="a7f27bf1f81f790997dca75aa747ddaf2"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void pvrvk::impl::CommandBufferBase_::pipelineBarrier </td>
          <td>(</td>
          <td class="paramtype">PipelineStageFlags&#160;</td>
          <td class="paramname"><em>srcStage</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PipelineStageFlags&#160;</td>
          <td class="paramname"><em>dstStage</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classpvrvk_1_1_memory_barrier_set.html">MemoryBarrierSet</a> &amp;&#160;</td>
          <td class="paramname"><em>barriers</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>dependencyByRegion</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Add a memory barrier to the command stream, forcing preceeding commands to be written before succeeding commands are executed.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">srcStage</td><td>A bitmask of PipelineStageFlags specifying the src stage mask.</td></tr>
    <tr><td class="paramname">dstStage</td><td>A bitmask of PipelineStageFlags specifying the dst stage mask.</td></tr>
    <tr><td class="paramname">barriers</td><td>A set of memory barriers to be used in the pipeline barrier.</td></tr>
    <tr><td class="paramname">dependencyByRegion</td><td>A Specifes whether the dependencies in terms of how the execution and memory dependencies are formed.</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a723ace2575665407b309eb3a397c180d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void pvrvk::impl::CommandBufferBase_::pushConstants </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacepvrvk.html#a34bb21497524a13e145b1398450989d0">PipelineLayout</a> &amp;&#160;</td>
          <td class="paramname"><em>pipelineLayout</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ShaderStageFlags&#160;</td>
          <td class="paramname"><em>stageFlags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Updates the value of shader push constants at the offset specified.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pipelineLayout</td><td>The pipeline layout used to program the push constant updates.</td></tr>
    <tr><td class="paramname">stageFlags</td><td>A bitmask of ShaderStageFlag specifying the shader stages that will use the push constants in the updated range.</td></tr>
    <tr><td class="paramname">offset</td><td>The start offset of the push constant range to update, in units of bytes.</td></tr>
    <tr><td class="paramname">size</td><td>The size of the push constant range to update, in units of bytes.</td></tr>
    <tr><td class="paramname">data</td><td>An array of size bytes containing the new push constant values.</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aa4cea12c65ab4bbd82d0916a47e44437"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void pvrvk::impl::CommandBufferBase_::resetEvent </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacepvrvk.html#a6696a17453f99f2b221a28bb05e4934b">Event</a> &amp;&#160;</td>
          <td class="paramname"><em>event</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PipelineStageFlags&#160;</td>
          <td class="paramname"><em>pipelineStageFlags</em> = <code>PipelineStageFlags::e_ALL_COMMANDS_BIT</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Defines an execution dependency on commands that were submitted before it, and defines an event unsignal operation which resets the event to the unsignaled state.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">event</td><td>The event object that will be unsignaled.</td></tr>
    <tr><td class="paramname">pipelineStageFlags</td><td>Is a bitmask of PipelineStageFlags specifying the src stage mask used to determine when the event is unsignaled.</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a0d5fc2fba19956e2923f87641cd3811e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classpvrvk_1_1impl_1_1_device_object_debug_marker.html">pvrvk::impl::DeviceObjectDebugMarker</a>&lt; <a class="el" href="classpvrvk_1_1impl_1_1_command_buffer_base__.html">CommandBufferBase_</a>  &gt;::resetObjectName </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Resets the name of a specified object using the extension VK_EXT_debug_marker.</p>

</div>
</div>
<a class="anchor" id="a7d37c209b0ef644c8f069a70be5bf156"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void pvrvk::impl::CommandBufferBase_::resetQueryPool </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacepvrvk.html#a9775dff694169a1bafd336a1a64508f7">QueryPool</a> &amp;&#160;</td>
          <td class="paramname"><em>queryPool</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>firstQuery</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>queryCount</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Resets a particular range of queries for a particular QueryPool and sets their status' to unavailable which also makes their numerical results undefined.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">queryPool</td><td>Specifies the query pool managing the queries being reset.</td></tr>
    <tr><td class="paramname">firstQuery</td><td>The first query index to reset.</td></tr>
    <tr><td class="paramname">queryCount</td><td>The number of queries to reset.</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a8148425c603008468c0a25e84c486b1d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void pvrvk::impl::CommandBufferBase_::resetQueryPool </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacepvrvk.html#a9775dff694169a1bafd336a1a64508f7">QueryPool</a> &amp;&#160;</td>
          <td class="paramname"><em>queryPool</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>queryIndex</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Resets a particular range of queries for a particular QueryPool and sets their status' to unavailable which also makes their numerical results undefined.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">queryPool</td><td>Specifies the query pool managing the queries being reset.</td></tr>
    <tr><td class="paramname">queryIndex</td><td>The query to reset.</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="abf5c74a05c61018eef6ac794c10d2938"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void pvrvk::impl::CommandBufferBase_::resolveImage </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacepvrvk.html#a0dde8112e297d1089979fbdbdcbbe0f4">Image</a> &amp;&#160;</td>
          <td class="paramname"><em>srcImage</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacepvrvk.html#a0dde8112e297d1089979fbdbdcbbe0f4">Image</a> &amp;&#160;</td>
          <td class="paramname"><em>dstImage</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ImageResolve *&#160;</td>
          <td class="paramname"><em>regions</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>numRegions</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ImageLayout&#160;</td>
          <td class="paramname"><em>srcLayout</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ImageLayout&#160;</td>
          <td class="paramname"><em>dstLayout</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copies regions of a src image into a dst image, potentially also performing format conversions, aritrary scaling and filtering.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">srcImage</td><td>The src Image in the copy.</td></tr>
    <tr><td class="paramname">dstImage</td><td>The dst image.</td></tr>
    <tr><td class="paramname">regions</td><td>A pointer to an array of ImageBlitRange structures specifying the regions to blit.</td></tr>
    <tr><td class="paramname">numRegions</td><td>The number of regions to blit.</td></tr>
    <tr><td class="paramname">srcLayout</td><td>The layout of the src image subresrcs for the blit.</td></tr>
    <tr><td class="paramname">dstLayout</td><td>The layout of the dst image subresrcs for the blit.</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a9ce2c215aa9814e5e8aa02f679f9fa24"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void pvrvk::impl::CommandBufferBase_::setBlendConstants </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>rgba</em>[4]</td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the dynamic blend constant bias state affecting pipeline objects created with VK_DYNAMIC_STATE_BLEND_CONSTANTS enabled.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rgba</td><td>An array of four values specifying the R, G, B, and A components of the blend constant color used in blending, depending on the blend factor</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a486a9d46e8f693398db0dc03fede5fb6"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void pvrvk::impl::CommandBufferBase_::setDepthBias </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>constantFactor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>clamp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>slopeFactor</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the dynamic depth bias state affecting pipeline objects created where depthBiasEnable is enabled.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">constantFactor</td><td>A scalar factor controlling the constant depth value added to each fragment.</td></tr>
    <tr><td class="paramname">clamp</td><td>The maximum (or minimum) depth bias of a fragment.</td></tr>
    <tr><td class="paramname">slopeFactor</td><td>A scalar factor applied to a fragments slope in depth bias calculations.</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ae41e1a87d69f9f3476ea6e20037b9b00"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void pvrvk::impl::CommandBufferBase_::setDepthBounds </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>min</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>max</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the dynamic depth bounds state affecting pipeline objects created with VK_DYNAMIC_STATE_DEPTH_BOUNDS enabled.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">min</td><td>The lower bound of the range of depth values used in the depth bounds test.</td></tr>
    <tr><td class="paramname">max</td><td>The upper bound of the range.</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ad2c47766d3ed0ef1aa2dc0ea6819162c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void pvrvk::impl::CommandBufferBase_::setEvent </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacepvrvk.html#a6696a17453f99f2b221a28bb05e4934b">Event</a> &amp;&#160;</td>
          <td class="paramname"><em>event</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PipelineStageFlags&#160;</td>
          <td class="paramname"><em>pipelineStageFlags</em> = <code>PipelineStageFlags::e_ALL_COMMANDS_BIT</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Defines an execution dependency on commands that were submitted before it, and defines an event signal operation which sets the event to the signaled state.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">event</td><td>The event object that will be signaled.</td></tr>
    <tr><td class="paramname">pipelineStageFlags</td><td>Specifies the src stage mask used to determine when the event is signaled.</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a6e36ba62ffb95e3a6fd71aa415542391"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void pvrvk::impl::CommandBufferBase_::setLineWidth </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>lineWidth</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the dynamic line width state affecting pipeline objects created with VK_DYNAMIC_STATE_LINE_WIDTH enabled.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lineWidth</td><td>The width of rasterized line segments.</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ae323b1f0833e0e90489612e897c78821"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classpvrvk_1_1impl_1_1_device_object_debug_marker.html">pvrvk::impl::DeviceObjectDebugMarker</a>&lt; <a class="el" href="classpvrvk_1_1impl_1_1_command_buffer_base__.html">CommandBufferBase_</a>  &gt;::setObjectName </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>objectName</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Makes use of the extension VK_EXT_debug_marker to provide a name for a specified object.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">objectName</td><td>The name to use for the object</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a90a2912d1e2fb065219b50eb55fbfd34"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classpvrvk_1_1impl_1_1_device_object_debug_marker.html">pvrvk::impl::DeviceObjectDebugMarker</a>&lt; <a class="el" href="classpvrvk_1_1impl_1_1_command_buffer_base__.html">CommandBufferBase_</a>  &gt;::setObjectTag </td>
          <td>(</td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>tagName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>tagSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>tag</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Makes use of the extension VK_EXT_debug_marker to provide a tag for a specified object.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tagName</td><td>A numerical identifier of the tag for the object</td></tr>
    <tr><td class="paramname">tagSize</td><td>The number of bytes of data to attach to the object.</td></tr>
    <tr><td class="paramname">tag</td><td>An array of tagSize bytes containing the data to be associated with the object.</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a73ee4dbcda7a265e6b5898a1a9d052d2"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void pvrvk::impl::CommandBufferBase_::setScissor </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>firstScissor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>numScissors</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Rect2D *&#160;</td>
          <td class="paramname"><em>scissors</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the dynamic scissor state affecting pipeline objects created with VK_DYNAMIC_STATE_SCISSOR enabled.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">firstScissor</td><td>The index of the first scissor whose state is updated.</td></tr>
    <tr><td class="paramname">numScissors</td><td>The number of scissors whose rectangles are updated.</td></tr>
    <tr><td class="paramname">scissors</td><td>A pointer to an array of Rect2Di structures defining scissor rectangles.</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="acef9f36e3f5383594c1f561fa800aff7"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void pvrvk::impl::CommandBufferBase_::setStencilCompareMask </td>
          <td>(</td>
          <td class="paramtype">StencilFaceFlags&#160;</td>
          <td class="paramname"><em>face</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>compareMask</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the dynamic stencil compare mask state affecting pipeline objects created with VK_DYNAMIC_STATE_STENCIL_COMPARE_MASK enabled.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">face</td><td>A bitmask of StencilFaceFlags specifying the set of stencil state for which to update the compare mask.</td></tr>
    <tr><td class="paramname">compareMask</td><td>The new value to use as the stencil compare value.</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="adc42ff2f511f268d68d0901b6281326d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void pvrvk::impl::CommandBufferBase_::setStencilReference </td>
          <td>(</td>
          <td class="paramtype">StencilFaceFlags&#160;</td>
          <td class="paramname"><em>face</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>reference</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the dynamic stencil reference mask state affecting pipeline objects created with VK_DYNAMIC_STATE_STENCIL_REFERENCE enabled.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">face</td><td>A bitmask of StencilFaceFlags specifying the set of stencil state for which to update the reference value.</td></tr>
    <tr><td class="paramname">reference</td><td>The new value to use as the stencil reference value.</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a3837e03b54149248c01087d7f77dd9f8"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void pvrvk::impl::CommandBufferBase_::setStencilWriteMask </td>
          <td>(</td>
          <td class="paramtype">StencilFaceFlags&#160;</td>
          <td class="paramname"><em>face</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>writeMask</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the dynamic stencil write mask state affecting pipeline objects created with VK_DYNAMIC_STATE_STENCIL_WRITE_MASK enabled.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">face</td><td>A bitmask of StencilFaceFlags specifying the set of stencil state for which to update the write mask.</td></tr>
    <tr><td class="paramname">writeMask</td><td>The new value to use as the stencil write mask</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a8b850bccfeda750ecb9e2c98c8c2b018"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void pvrvk::impl::CommandBufferBase_::setViewport </td>
          <td>(</td>
          <td class="paramtype">const Viewport &amp;&#160;</td>
          <td class="paramname"><em>viewport</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set viewport</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">viewport</td><td>Viewport</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a9ec18d08b6609a9078a081fa31f3ce77"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void pvrvk::impl::CommandBufferBase_::updateBuffer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacepvrvk.html#a2a117db0aab25382d050908b2bfa4c8b">Buffer</a> &amp;&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Updates buffer data inline in a command buffer. The update is only allowed outside of a renderpass and is treated as a transfer operation for the purposes of syncrhonization.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buffer</td><td>The buffer to be updated.</td></tr>
    <tr><td class="paramname">data</td><td>A pointer to the src data for the buffer update. The data must be at least length bytes in size.</td></tr>
    <tr><td class="paramname">offset</td><td>The byte offset into the buffer to start updating, and must be a multiple of 4.</td></tr>
    <tr><td class="paramname">length</td><td>The number of bytes to update, and must be a multiple of 4.</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aff7cfaed7300edd34cd1de176278e516"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void pvrvk::impl::CommandBufferBase_::waitForEvent </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacepvrvk.html#a6696a17453f99f2b221a28bb05e4934b">Event</a> &amp;&#160;</td>
          <td class="paramname"><em>event</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PipelineStageFlags&#160;</td>
          <td class="paramname"><em>srcStage</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PipelineStageFlags&#160;</td>
          <td class="paramname"><em>dstStage</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classpvrvk_1_1_memory_barrier_set.html">MemoryBarrierSet</a> &amp;&#160;</td>
          <td class="paramname"><em>barriers</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Defines a memory dependency between prior event signal operations and subsequent commands.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">event</td><td>The event object to wait on.</td></tr>
    <tr><td class="paramname">srcStage</td><td>A bitmask of PipelineStageFlags specifying the src stage mask.</td></tr>
    <tr><td class="paramname">dstStage</td><td>A bitmask of PipelineStageFlags specifying the dst stage mask.</td></tr>
    <tr><td class="paramname">barriers</td><td>A set of memory barriers to be used in the pipeline barrier.</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a8b7063f61ca8234126f81ec9625153e7"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void pvrvk::impl::CommandBufferBase_::waitForEvents </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacepvrvk.html#a6696a17453f99f2b221a28bb05e4934b">Event</a> *&#160;</td>
          <td class="paramname"><em>events</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>numEvents</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PipelineStageFlags&#160;</td>
          <td class="paramname"><em>srcStage</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PipelineStageFlags&#160;</td>
          <td class="paramname"><em>dstStage</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classpvrvk_1_1_memory_barrier_set.html">MemoryBarrierSet</a> &amp;&#160;</td>
          <td class="paramname"><em>barriers</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Defines a set of memory dependencies between prior event signal operations and subsequent commands.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">events</td><td>A pointer to an array of Event objects to wait on.</td></tr>
    <tr><td class="paramname">numEvents</td><td>The number of event objects to wait on.</td></tr>
    <tr><td class="paramname">srcStage</td><td>A bitmask of PipelineStageFlags specifying the src stage mask.</td></tr>
    <tr><td class="paramname">dstStage</td><td>A bitmask of PipelineStageFlags specifying the dst stage mask.</td></tr>
    <tr><td class="paramname">barriers</td><td>A set of .</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a09fc5e0ce68a45bfda286a3a02fec71b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void pvrvk::impl::CommandBufferBase_::writeTimestamp </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacepvrvk.html#a9775dff694169a1bafd336a1a64508f7">QueryPool</a> &amp;&#160;</td>
          <td class="paramname"><em>queryPool</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>queryIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PipelineStageFlags&#160;</td>
          <td class="paramname"><em>pipelineStage</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Requests a timestamp for a particular QueryPool to be written to the query.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">queryPool</td><td>Specifies the query pool which will manage the results of the query.</td></tr>
    <tr><td class="paramname">queryIndex</td><td>The query index within the QueryPool which will contain the results.</td></tr>
    <tr><td class="paramname">pipelineStage</td><td>Specifies the stage of the pipeline to write a timestamp for.</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a class="anchor" id="aa6ff16a7e0728a785f1367dfb33d6099"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacepvrvk.html#a8dd5932a80187b088ce6b591712dc2c2">DeviceWeakPtr</a> <a class="el" href="classpvrvk_1_1impl_1_1_device_object_handle.html">pvrvk::impl::DeviceObjectHandle</a>&lt; VkCommandBuffer  &gt;::_device</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The device which was used to create this DeviceObject</p>

</div>
</div>
<a class="anchor" id="a759e4e7ca81cb8812048075ddcf274d6"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool pvrvk::impl::CommandBufferBase_::_isRecording</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Specifies whether the command buffer is currently in the recording state which is controlled via calling the begin function.</p>

</div>
</div>
<a class="anchor" id="a943d27103dec9450a0966c8352aef979"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacepvrvk.html#a946a7145c9e18b9a797fa714ce677f32">ComputePipeline</a> pvrvk::impl::CommandBufferBase_::_lastBoundComputePipe</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Holds a reference to the last bound compute pipeline. This can then be used for optimising binding the same compute pipeline repeatedly.</p>

</div>
</div>
<a class="anchor" id="aa0f1be52e5e2affe2a3f57ea68a8d036"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacepvrvk.html#aa2443b681960df638797cf93bbf33fb7">GraphicsPipeline</a> pvrvk::impl::CommandBufferBase_::_lastBoundGraphicsPipe</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Holds a reference to the last bound graphics pipeline. This can be used for optimising binding the same graphics pipeline repeatedly.</p>

</div>
</div>
<a class="anchor" id="a402866281f61adadea66db94a0e25794"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;EmbeddedRefCountedResource&lt;void&gt; &gt; pvrvk::impl::CommandBufferBase_::_objectReferences</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Holds a list of references to the objects currently in use by this command buffer. This ensures that objects are kept alive through reference counting until the command buffer is finished with them.</p>

</div>
</div>
<a class="anchor" id="adb4cc024978587b241ae65a8541d5815"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacepvrvk.html#ac9949394db8b3d968a7402b837567f87">CommandPool</a> pvrvk::impl::CommandBufferBase_::_pool</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The command pool from which this command buffer was allocated.</p>

</div>
</div>
<a class="anchor" id="a41f43268ad1a7d2d3bde2a228fbcac03"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">VkCommandBuffer  <a class="el" href="classpvrvk_1_1impl_1_1_object_handle.html">pvrvk::impl::ObjectHandle</a>&lt; VkCommandBuffer  &gt;::_vkHandle</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The Vulkan object handle representing the Vulkan object at an API level.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>/usr/buildxl/buildroot/sdk/branch/SDK/framework/PVRVk/<a class="el" href="_command_buffer_vk_8h_source.html">CommandBufferVk.h</a></li>
</ul>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.8.4-->
<!-- start footer part (NON TREEVIEW ONLY!!) -->
<!--BEGIN GENERATE_TREEVIEW-->
<div id="FooterMainContainer">
	<div id="FooterContainer">
		<div class="footerlogo">
			<a href="http://www.imgtec.com" target="_blank"><img src="img-footer-logo-grey.png" width="100%" height="100%" border="none" /></a>
		</div>
		<div class="copyright"><p>&copy; Imagination Technologies Limited<br> All rights reserved</p></div>
	</div>
</div>
</body>
</html>
