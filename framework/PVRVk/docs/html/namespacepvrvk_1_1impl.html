<!-- HTML header for doxygen 1.8.4-->
<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="generator" content="Doxygen 1.8.6"/>
<title>PVRVk: pvrvk::impl Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="IMGdoxygen.css" rel="stylesheet" type="text/css"/>
<link rel="shortcut icon" type="image/x-icon" href="img.ico">
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
  <div class="headercontent">
    <div class="PVRlogo">
      <a href="https://www.imgtec.com/developers/" target="_blank"><img src="PVRlogo.png" width="40%" height="40%"  border="none" /></a>
    </div>
    <a class="SiteTitle"><span id="projectname">PVRVk</span> Documentation</a>
   <tbody>
  </div>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.6 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="inherits.html"><span>Class&#160;Hierarchy</span></a></li>
      <li class="current"><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Macros</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(10)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacepvrvk.html">pvrvk</a></li><li class="navelem"><a class="el" href="namespacepvrvk_1_1impl.html">impl</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">pvrvk::impl Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Contains internal objects and wrapped versions of the PVRVk module 
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvrvk_1_1impl_1_1_buffer__.html">Buffer_</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vulkan implementation of the Buffer. <a href="classpvrvk_1_1impl_1_1_buffer__.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvrvk_1_1impl_1_1_buffer_view__.html">BufferView_</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">pvrvk implementation of a BufferView. <a href="classpvrvk_1_1impl_1_1_buffer_view__.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvrvk_1_1impl_1_1_command_buffer__.html">CommandBuffer_</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Contains all the commands and states that need to be recorded for later submission to the gpu including pipelines, textures, descriptor sets. Virtually everything that needs to happen on the GPU is submitted to the CommandBuffer. <a href="classpvrvk_1_1impl_1_1_command_buffer__.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvrvk_1_1impl_1_1_command_buffer_base__.html">CommandBufferBase_</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Contains all the commands and states that need to be recorded for later submission to the gpu including pipelines, textures, descriptor sets. Virtually everything that needs to happen on the GPU is submitted to the CommandBuffer. <a href="classpvrvk_1_1impl_1_1_command_buffer_base__.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvrvk_1_1impl_1_1_command_pool__.html">CommandPool_</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vulkan implementation of the Command Pool class. Destroying the commandpool will also destroys the commandbuffers allocated from this pool <a href="classpvrvk_1_1impl_1_1_command_pool__.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvrvk_1_1impl_1_1_compute_pipeline__.html">ComputePipeline_</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vulkan Computepipeline wrapper  <a href="classpvrvk_1_1impl_1_1_compute_pipeline__.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpvrvk_1_1impl_1_1_compute_pipeline_populate.html">ComputePipelinePopulate</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Contains everything needed to define a VkComputePipelineCreateInfo, with provision for all memory required <a href="structpvrvk_1_1impl_1_1_compute_pipeline_populate.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvrvk_1_1impl_1_1_debug_report_callback__.html">DebugReportCallback_</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vulkan DebugReportCallback wrapper <a href="classpvrvk_1_1impl_1_1_debug_report_callback__.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvrvk_1_1impl_1_1_debug_utils_messenger__.html">DebugUtilsMessenger_</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vulkan DebugUtilsMessenger wrapper <a href="classpvrvk_1_1impl_1_1_debug_utils_messenger__.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvrvk_1_1impl_1_1_descriptor_pool__.html">DescriptorPool_</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A descriptor pool - an object used to allocate (and recycle) Descriptor Sets. <a href="classpvrvk_1_1impl_1_1_descriptor_pool__.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvrvk_1_1impl_1_1_descriptor_set__.html">DescriptorSet_</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vulkan implementation of a DescriptorSet. <a href="classpvrvk_1_1impl_1_1_descriptor_set__.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvrvk_1_1impl_1_1_descriptor_set_layout__.html">DescriptorSetLayout_</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor. . Vulkan implementation of a DescriptorSet. <a href="classpvrvk_1_1impl_1_1_descriptor_set_layout__.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvrvk_1_1impl_1_1_descriptor_store.html">DescriptorStore</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Internal class <a href="classpvrvk_1_1impl_1_1_descriptor_store.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvrvk_1_1impl_1_1_device__.html">Device_</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">GpuDevice implementation that supports Vulkan <a href="classpvrvk_1_1impl_1_1_device__.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvrvk_1_1impl_1_1_device_debug_utils_impl.html">DeviceDebugUtilsImpl</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implementation for the Debug Marker wrapper for PVRVk objects. Handles the actual naming and tagging calls for the debug extensions "VK_EXT_debug_maker" or "VK_EXT_debug_utils" depending on thier support. <a href="classpvrvk_1_1impl_1_1_device_debug_utils_impl.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvrvk_1_1impl_1_1_device_memory__.html">DeviceMemory_</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">VkDeviceMemory wrapper <a href="classpvrvk_1_1impl_1_1_device_memory__.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvrvk_1_1impl_1_1_device_object_debug_utils.html">DeviceObjectDebugUtils</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A Debug Marker wrapper for PVRVk Device allocated objects. Handles naming and tagging calls for the extension "VK_EXT_debug_maker". <a href="classpvrvk_1_1impl_1_1_device_object_debug_utils.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvrvk_1_1impl_1_1_display__.html">Display_</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A display device can in some environments be used directly for Vulkan rendering without using intermediate windowing systems. <a href="classpvrvk_1_1impl_1_1_display__.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvrvk_1_1impl_1_1_display_mode__.html">DisplayMode_</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Each display has one or more supported modes associated with it by default. These are called the display modes. <a href="classpvrvk_1_1impl_1_1_display_mode__.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvrvk_1_1impl_1_1_display_plane_surface__.html">DisplayPlaneSurface_</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A DisplayPlane Surface. <a href="classpvrvk_1_1impl_1_1_display_plane_surface__.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvrvk_1_1impl_1_1_event__.html">Event_</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vulkan implementation of the Event class. Event can be used by the host to do fine-grained synchronization of commands, and it can be signalled either from the host (calling <a class="el" href="classpvrvk_1_1impl_1_1_event__.html#a33b573bfc2d376a6f91c7a2d1b9d949c" title="Set this event">set()</a>) or the device (submitting a setEvent() command). <a href="classpvrvk_1_1impl_1_1_event__.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvrvk_1_1impl_1_1_fence__.html">Fence_</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vulkan implementation of the Fence class Fence can be used by the host to determine completion of execution of subimmisions to queues. The host can be polled for the fence signal . <a href="classpvrvk_1_1impl_1_1_fence__.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvrvk_1_1impl_1_1_framebuffer__.html">Framebuffer_</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vulkan implementation of the Framebuffer (Framebuffer object) class. <a href="classpvrvk_1_1impl_1_1_framebuffer__.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvrvk_1_1impl_1_1_graphics_pipeline__.html">GraphicsPipeline_</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A Graphics <a class="el" href="classpvrvk_1_1impl_1_1_pipeline.html" title="A Graphics Pipeline is a PVRVk adapter to a Vulkan Pipeline to a pipeline created for VK_PIPELINE_BIN...">Pipeline</a> is a PVRVk adapter to a Vulkan <a class="el" href="classpvrvk_1_1impl_1_1_pipeline.html" title="A Graphics Pipeline is a PVRVk adapter to a Vulkan Pipeline to a pipeline created for VK_PIPELINE_BIN...">Pipeline</a> to a pipeline created for VK_PIPELINE_BINDING_POINT_COMPUTE, and as such only supports the part of Vulkan that is supported for Graphics pipelines. <a href="classpvrvk_1_1impl_1_1_graphics_pipeline__.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpvrvk_1_1impl_1_1_graphics_pipeline_populate.html">GraphicsPipelinePopulate</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Contains everything needed to define a VkGraphicsPipelineCreateInfo, with provision for all memory required <a href="structpvrvk_1_1impl_1_1_graphics_pipeline_populate.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvrvk_1_1impl_1_1_i_device_memory__.html">IDeviceMemory_</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">VkDeviceMemory wrapper <a href="classpvrvk_1_1impl_1_1_i_device_memory__.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvrvk_1_1impl_1_1_image__.html">Image_</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">ImageVk implementation that wraps the Vulkan Texture object <a href="classpvrvk_1_1impl_1_1_image__.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvrvk_1_1impl_1_1_image_view__.html">ImageView_</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="namespacepvrvk.html#adc4f5e5a2423045c3197ce383a53d910" title="Base class for the view of any kind of texture view.">pvrvk::ImageView</a> implementation of a Vulkan VkImageView <a href="classpvrvk_1_1impl_1_1_image_view__.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvrvk_1_1impl_1_1_instance__.html">Instance_</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The Instance is a system-wide vulkan "implementation", similar in concept to the "installation" of Vulkan libraries on a system. Contrast with the "Physical Device" which for example represents a particular driver implementing Vulkan for a specific Device. Conceptually, the Instance "Forwards" to the "Physical Device / Device" <a href="classpvrvk_1_1impl_1_1_instance__.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvrvk_1_1impl_1_1_physical_device__.html">PhysicalDevice_</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The representation of an entire actual, physical GPU device (as opposed to Device, which is a local, logical part of it). A Physical device is "determined", or "found", or "enumerated", (while a logical device is "created"). You can use the physical device to create logical Devices, determine Extensions etc. See Vulkan spec. <a href="classpvrvk_1_1impl_1_1_physical_device__.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvrvk_1_1impl_1_1_pipeline.html">Pipeline</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A Graphics <a class="el" href="classpvrvk_1_1impl_1_1_pipeline.html" title="A Graphics Pipeline is a PVRVk adapter to a Vulkan Pipeline to a pipeline created for VK_PIPELINE_BIN...">Pipeline</a> is a PVRVk adapter to a Vulkan <a class="el" href="classpvrvk_1_1impl_1_1_pipeline.html" title="A Graphics Pipeline is a PVRVk adapter to a Vulkan Pipeline to a pipeline created for VK_PIPELINE_BIN...">Pipeline</a> to a pipeline created for VK_PIPELINE_BINDING_POINT_COMPUTE, and as such only supports the part of Vulkan that is supported for Graphics pipelines. <a href="classpvrvk_1_1impl_1_1_pipeline.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvrvk_1_1impl_1_1_pipeline_cache__.html">PipelineCache_</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A PVRVk pipeline cache object which allows the result of pipeline construction to be reused between pipelines and between runs of an application <a href="classpvrvk_1_1impl_1_1_pipeline_cache__.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvrvk_1_1impl_1_1_pipeline_layout__.html">PipelineLayout_</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vulkan implementation of the PipelineLayout class. <a href="classpvrvk_1_1impl_1_1_pipeline_layout__.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvrvk_1_1impl_1_1_p_v_r_vk_device_object_base.html">PVRVkDeviceObjectBase</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defines a simple interface for a Vulkan object which holds a reference to a particular device. <a href="classpvrvk_1_1impl_1_1_p_v_r_vk_device_object_base.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvrvk_1_1impl_1_1_p_v_r_vk_instance_object_base.html">PVRVkInstanceObjectBase</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defines a simple interface for a Vulkan which holds a reference to a Vulkan instance. <a href="classpvrvk_1_1impl_1_1_p_v_r_vk_instance_object_base.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvrvk_1_1impl_1_1_p_v_r_vk_object_base.html">PVRVkObjectBase</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defines a simple interface for a Vulkan object. <a href="classpvrvk_1_1impl_1_1_p_v_r_vk_object_base.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvrvk_1_1impl_1_1_p_v_r_vk_physical_device_object_base.html">PVRVkPhysicalDeviceObjectBase</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defines a simple interface for a Vulkan which holds a reference to a Vulkan Physical Device. <a href="classpvrvk_1_1impl_1_1_p_v_r_vk_physical_device_object_base.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvrvk_1_1impl_1_1_query_pool__.html">QueryPool_</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vulkan implementation of the Query Pool class. Destroying the query pool will also destroy the queries allocated from this pool <a href="classpvrvk_1_1impl_1_1_query_pool__.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvrvk_1_1impl_1_1_queue__.html">Queue_</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wraps vulkan queue object. <a href="classpvrvk_1_1impl_1_1_queue__.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvrvk_1_1impl_1_1_render_pass__.html">RenderPass_</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vulkan implementation of the RenderPass class. Use through the Reference counted framework object pvrvk::api::RenderPass. RenderPass Compatibility: Framebuffers and graphics pipelines are created based on a specific render pass object. They must only be used with that render pass object, or one compatible with it. Two attachment references are compatible if they have matching format and sample count, Two arrays of attachment references are compatible if all corresponding pairs of attachments are compatible. If the arrays are of different lengths, attachment references not present in the smaller array are treated as unused. Two render passes that contain only a single subpass are compatible if their corresponding color, input, resolve, and depth/stencil attachment references are compatible. If two render passes contain more than one subpass, they are compatible if they are identical except for: - Initial and final image layout in attachment descriptions - Load and store operations in attachment descriptions - Image layout in attachment references A framebuffer is compatible with a render pass if it was created using the same render pass or a compatible render pass. <a href="classpvrvk_1_1impl_1_1_render_pass__.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvrvk_1_1impl_1_1_sampler__.html">Sampler_</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">SamplerVk_ implementation that wraps the vulkan sampler <a href="classpvrvk_1_1impl_1_1_sampler__.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvrvk_1_1impl_1_1_secondary_command_buffer__.html">SecondaryCommandBuffer_</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Contains all the commands and states that need to be submitted to the gpu, including pipeline, texture, and samplers. Virtually everything that needs to happen on the GPU is submitted to the CommandBuffer. <a href="classpvrvk_1_1impl_1_1_secondary_command_buffer__.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvrvk_1_1impl_1_1_semaphore__.html">Semaphore_</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vulkan implementation of the Semaphore class. Use to "serialize" access between CommandBuffer submissions and /Queues <a href="classpvrvk_1_1impl_1_1_semaphore__.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvrvk_1_1impl_1_1_shader_module__.html">ShaderModule_</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vulkan shader module wrapper <a href="classpvrvk_1_1impl_1_1_shader_module__.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvrvk_1_1impl_1_1_surface__.html">Surface_</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A surface represents a renderable part of the "screen", e.g. the inside part of the window. <a href="classpvrvk_1_1impl_1_1_surface__.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvrvk_1_1impl_1_1_swapchain__.html">Swapchain_</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The Swapchain is the object wrapping the on - screen rendering Framebuffer images (aka front/backbuffers) <a href="classpvrvk_1_1impl_1_1_swapchain__.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvrvk_1_1impl_1_1_swapchain_image__.html">SwapchainImage_</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The Specialized image for swapchain <a href="classpvrvk_1_1impl_1_1_swapchain_image__.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a275e540bd7cd31527e5956f07e1882d3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvrvk_1_1impl.html#a275e540bd7cd31527e5956f07e1882d3">convert</a> (VkVertexInputAttributeDescription &amp;vkva, const VertexInputAttributeDescription &amp;pvrva)</td></tr>
<tr class="memdesc:a275e540bd7cd31527e5956f07e1882d3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Populate vulkan input attribute description <a href="#a275e540bd7cd31527e5956f07e1882d3">More...</a><br/></td></tr>
<tr class="separator:a275e540bd7cd31527e5956f07e1882d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f4e33ffa07e1c7c996a5163af7a5982"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvrvk_1_1impl.html#a7f4e33ffa07e1c7c996a5163af7a5982">convert</a> (VkVertexInputBindingDescription &amp;vkvb, const VertexInputBindingDescription &amp;pvrvb)</td></tr>
<tr class="memdesc:a7f4e33ffa07e1c7c996a5163af7a5982"><td class="mdescLeft">&#160;</td><td class="mdescRight">Populate vulkan input binding description <a href="#a7f4e33ffa07e1c7c996a5163af7a5982">More...</a><br/></td></tr>
<tr class="separator:a7f4e33ffa07e1c7c996a5163af7a5982"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaea6074bfe807f4a4830049b6c487ed4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvrvk_1_1impl.html#aaea6074bfe807f4a4830049b6c487ed4">convert</a> (VkPipelineColorBlendAttachmentState &amp;vkcb, const PipelineColorBlendAttachmentState &amp;pvrcb)</td></tr>
<tr class="memdesc:aaea6074bfe807f4a4830049b6c487ed4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Populate vulkan pipeline color blend attachment state <a href="#aaea6074bfe807f4a4830049b6c487ed4">More...</a><br/></td></tr>
<tr class="separator:aaea6074bfe807f4a4830049b6c487ed4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b226163f8686e1f719831706117bf17"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvrvk_1_1impl.html#a4b226163f8686e1f719831706117bf17">convert</a> (VkStencilOpState &amp;vkStencilState, const StencilOpState &amp;stencilState)</td></tr>
<tr class="memdesc:a4b226163f8686e1f719831706117bf17"><td class="mdescLeft">&#160;</td><td class="mdescRight">Populate vulkan stencil state <a href="#a4b226163f8686e1f719831706117bf17">More...</a><br/></td></tr>
<tr class="separator:a4b226163f8686e1f719831706117bf17"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8c0049787dc05a9382fabee212b7db1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvrvk_1_1impl.html#ab8c0049787dc05a9382fabee212b7db1">convert</a> (VkViewport &amp;vkvp, const Viewport &amp;vp)</td></tr>
<tr class="memdesc:ab8c0049787dc05a9382fabee212b7db1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Populate vulkan viewport <a href="#ab8c0049787dc05a9382fabee212b7db1">More...</a><br/></td></tr>
<tr class="separator:ab8c0049787dc05a9382fabee212b7db1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ec485b811e8a26db7b53971018fef23"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvrvk_1_1impl.html#a9ec485b811e8a26db7b53971018fef23">populateShaderInfo</a> (const VkShaderModule &amp;shaderModule, pvrvk::ShaderStageFlags shaderStageFlags, const std::string &amp;entryPoint, const <a class="el" href="structpvrvk_1_1_shader_constant_info.html">ShaderConstantInfo</a> *shaderConsts, uint32_t shaderConstCount, VkSpecializationInfo &amp;specializationInfo, unsigned char *specializationInfoData, VkSpecializationMapEntry *mapEntries, VkPipelineShaderStageCreateInfo &amp;outShaderCreateInfo)</td></tr>
<tr class="memdesc:a9ec485b811e8a26db7b53971018fef23"><td class="mdescLeft">&#160;</td><td class="mdescRight">Populate a VkPipelineShaderStageCreateInfo <a href="#a9ec485b811e8a26db7b53971018fef23">More...</a><br/></td></tr>
<tr class="separator:a9ec485b811e8a26db7b53971018fef23"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Contains internal objects and wrapped versions of the PVRVk module</p>
</div><h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="a275e540bd7cd31527e5956f07e1882d3"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void pvrvk::impl::convert </td>
          <td>(</td>
          <td class="paramtype">VkVertexInputAttributeDescription &amp;&#160;</td>
          <td class="paramname"><em>vkva</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const VertexInputAttributeDescription &amp;&#160;</td>
          <td class="paramname"><em>pvrva</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Populate vulkan input attribute description</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vkva</td><td>Return populated VkVertexInputAttributeDescription</td></tr>
    <tr><td class="paramname">pvrva</td><td>A vertex attribute info to convert from</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a7f4e33ffa07e1c7c996a5163af7a5982"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void pvrvk::impl::convert </td>
          <td>(</td>
          <td class="paramtype">VkVertexInputBindingDescription &amp;&#160;</td>
          <td class="paramname"><em>vkvb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const VertexInputBindingDescription &amp;&#160;</td>
          <td class="paramname"><em>pvrvb</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Populate vulkan input binding description</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vkvb</td><td>Return populated VkVertexInputBindingDescription</td></tr>
    <tr><td class="paramname">pvrvb</td><td>A vertex input binding info to convert from</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aaea6074bfe807f4a4830049b6c487ed4"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void pvrvk::impl::convert </td>
          <td>(</td>
          <td class="paramtype">VkPipelineColorBlendAttachmentState &amp;&#160;</td>
          <td class="paramname"><em>vkcb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PipelineColorBlendAttachmentState &amp;&#160;</td>
          <td class="paramname"><em>pvrcb</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Populate vulkan pipeline color blend attachment state</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vkcb</td><td>Return populated VkPipelineColorBlendAttachmentState</td></tr>
    <tr><td class="paramname">pvrcb</td><td>A color blend attachment state to convert from</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a4b226163f8686e1f719831706117bf17"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void pvrvk::impl::convert </td>
          <td>(</td>
          <td class="paramtype">VkStencilOpState &amp;&#160;</td>
          <td class="paramname"><em>vkStencilState</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const StencilOpState &amp;&#160;</td>
          <td class="paramname"><em>stencilState</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Populate vulkan stencil state</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">stencilState</td><td>A stencil state state to convert from</td></tr>
    <tr><td class="paramname">vkStencilState</td><td>Return populated VkStencilOpState</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ab8c0049787dc05a9382fabee212b7db1"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void pvrvk::impl::convert </td>
          <td>(</td>
          <td class="paramtype">VkViewport &amp;&#160;</td>
          <td class="paramname"><em>vkvp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Viewport &amp;&#160;</td>
          <td class="paramname"><em>vp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Populate vulkan viewport</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vp</td><td>A viewport to convert from</td></tr>
    <tr><td class="paramname">vkvp</td><td>Return populated Viewport</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a9ec485b811e8a26db7b53971018fef23"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void pvrvk::impl::populateShaderInfo </td>
          <td>(</td>
          <td class="paramtype">const VkShaderModule &amp;&#160;</td>
          <td class="paramname"><em>shaderModule</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">pvrvk::ShaderStageFlags&#160;</td>
          <td class="paramname"><em>shaderStageFlags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>entryPoint</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ShaderConstantInfo *&#160;</td>
          <td class="paramname"><em>shaderConsts</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>shaderConstCount</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VkSpecializationInfo &amp;&#160;</td>
          <td class="paramname"><em>specializationInfo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned char *&#160;</td>
          <td class="paramname"><em>specializationInfoData</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VkSpecializationMapEntry *&#160;</td>
          <td class="paramname"><em>mapEntries</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VkPipelineShaderStageCreateInfo &amp;&#160;</td>
          <td class="paramname"><em>outShaderCreateInfo</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Populate a VkPipelineShaderStageCreateInfo</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">shaderModule</td><td>A shader module to use</td></tr>
    <tr><td class="paramname">shaderStageFlags</td><td>The shader stage flag bits</td></tr>
    <tr><td class="paramname">entryPoint</td><td>An std::string to use as the entry point for the pipeline shader stage</td></tr>
    <tr><td class="paramname">shaderConsts</td><td>A number of shader constants to use</td></tr>
    <tr><td class="paramname">shaderConstCount</td><td>The number of shader constants</td></tr>
    <tr><td class="paramname">specializationInfo</td><td>Memory backing for the specialization info structures</td></tr>
    <tr><td class="paramname">specializationInfoData</td><td>The memory backing for the specialization info</td></tr>
    <tr><td class="paramname">mapEntries</td><td>Memory backing for shaderConstCount number of VkSpecializationMapEntry structures</td></tr>
    <tr><td class="paramname">outShaderCreateInfo</td><td>The populated VkPipelineShaderStageCreateInfo</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.8.4-->
<!-- start footer part (NON TREEVIEW ONLY!!) -->
<!--BEGIN GENERATE_TREEVIEW-->
<div id="FooterMainContainer">
	<div id="FooterContainer">
		<div class="footerlogo">
			<a href="http://www.imgtec.com" target="_blank"><img src="img-footer-logo-grey.png" width="100%" height="100%" border="none" /></a>
		</div>
		<div class="copyright"><p>&copy; Imagination Technologies Limited<br> All rights reserved</p></div>
	</div>
</div>
</body>
</html>
