<!-- HTML header for doxygen 1.8.4-->
<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="generator" content="Doxygen 1.8.6"/>
<title>PVRAssets: pvr::ShadowVolume Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="IMGdoxygen.css" rel="stylesheet" type="text/css"/>
<link rel="shortcut icon" type="image/x-icon" href="img.ico">
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
  <div class="headercontent">
    <div class="PVRlogo">
      <a href="https://www.imgtec.com/developers/" target="_blank"><img src="PVRlogo.png" width="40%" height="40%"  border="none" /></a>
    </div>
    <a class="SiteTitle"><span id="projectname">PVRAssets</span> Documentation</a>
   <tbody>
  </div>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.6 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="inherits.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacepvr.html">pvr</a></li><li class="navelem"><a class="el" href="classpvr_1_1_shadow_volume.html">ShadowVolume</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> &#124;
<a href="classpvr_1_1_shadow_volume-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">pvr::ShadowVolume Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Represents data for handling Shadow volumes of a single Mesh. 
 <a href="classpvr_1_1_shadow_volume.html#details">More...</a></p>
<div class="dynheader">
Inheritance diagram for pvr::ShadowVolume:</div>
<div class="dyncontent">
<div class="center"><img src="classpvr_1_1_shadow_volume__inherit__graph.png" border="0" usemap="#pvr_1_1_shadow_volume_inherit__map" alt="Inheritance graph"/></div>
<map name="pvr_1_1_shadow_volume_inherit__map" id="pvr_1_1_shadow_volume_inherit__map">
<area shape="rect" id="node2" href="classpvr_1_1_volume.html" title="Represents data for handling volumes of a single Mesh." alt="" coords="29,5,120,32"/></map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a26e4418ab016fa8dd0e2d2cea9b5a52e"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1_shadow_volume.html#a26e4418ab016fa8dd0e2d2cea9b5a52e">Flags</a> { <a class="el" href="classpvr_1_1_shadow_volume.html#a26e4418ab016fa8dd0e2d2cea9b5a52eaeac5571bd351f6545e1ec4e9f48b62d6">Visible</a> = 0x01, 
<a class="el" href="classpvr_1_1_shadow_volume.html#a26e4418ab016fa8dd0e2d2cea9b5a52ea66e365df8866e60572a47d4599d601d6">Cap_front</a> = 0x02, 
<a class="el" href="classpvr_1_1_shadow_volume.html#a26e4418ab016fa8dd0e2d2cea9b5a52ea5ab4f380ff80f11066790c7010dcaf15">Cap_back</a> = 0x04, 
<a class="el" href="classpvr_1_1_shadow_volume.html#a26e4418ab016fa8dd0e2d2cea9b5a52ea4faec57b99c1df26718ef9992ac16529">Zfail</a> = 0x08
 }</td></tr>
<tr class="memdesc:a26e4418ab016fa8dd0e2d2cea9b5a52e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enumerates the different options for different kinds of Shadow volumes. <a href="classpvr_1_1_shadow_volume.html#a26e4418ab016fa8dd0e2d2cea9b5a52e">More...</a><br/></td></tr>
<tr class="separator:a26e4418ab016fa8dd0e2d2cea9b5a52e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:ad375982bd94062bf68af87ec39929c5a"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1_shadow_volume.html#ad375982bd94062bf68af87ec39929c5a">~ShadowVolume</a> ()</td></tr>
<tr class="memdesc:ad375982bd94062bf68af87ec39929c5a"><td class="mdescLeft">&#160;</td><td class="mdescRight">dtor, releases all resources held by the shadow volume. <a href="#ad375982bd94062bf68af87ec39929c5a">More...</a><br/></td></tr>
<tr class="separator:ad375982bd94062bf68af87ec39929c5a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acec04eaf1f74a913ec1ad952d411be1e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1_shadow_volume.html#acec04eaf1f74a913ec1ad952d411be1e">alllocateShadowVolume</a> (uint32_t volumeID)</td></tr>
<tr class="memdesc:acec04eaf1f74a913ec1ad952d411be1e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocate memory for a new shadow volume with the specified ID. <a href="#acec04eaf1f74a913ec1ad952d411be1e">More...</a><br/></td></tr>
<tr class="separator:acec04eaf1f74a913ec1ad952d411be1e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a894e9d0050d4fce44dd9903cc21d9cf3"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1_volume.html#a894e9d0050d4fce44dd9903cc21d9cf3">getIndexDataSize</a> ()</td></tr>
<tr class="memdesc:a894e9d0050d4fce44dd9903cc21d9cf3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the size of the Index data, in bytes. <a href="#a894e9d0050d4fce44dd9903cc21d9cf3">More...</a><br/></td></tr>
<tr class="separator:a894e9d0050d4fce44dd9903cc21d9cf3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a13a0ecadd29849f13633e8ef89a4dda2"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1_volume.html#a13a0ecadd29849f13633e8ef89a4dda2">getIndexDataStride</a> ()</td></tr>
<tr class="memdesc:a13a0ecadd29849f13633e8ef89a4dda2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the stride of the Index data, in bytes. Is sizeof(IndexType). <a href="#a13a0ecadd29849f13633e8ef89a4dda2">More...</a><br/></td></tr>
<tr class="separator:a13a0ecadd29849f13633e8ef89a4dda2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af851abc9cee9252ba9589f276cc7ca51"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1_shadow_volume.html#af851abc9cee9252ba9589f276cc7ca51">getIndices</a> (uint32_t volumeID)</td></tr>
<tr class="memdesc:af851abc9cee9252ba9589f276cc7ca51"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the indices of the specified shadow volume. <a href="#af851abc9cee9252ba9589f276cc7ca51">More...</a><br/></td></tr>
<tr class="separator:af851abc9cee9252ba9589f276cc7ca51"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afefb0d9bc8ad9149aa7bb4c6420927d3"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1_shadow_volume.html#afefb0d9bc8ad9149aa7bb4c6420927d3">getNumIndices</a> (uint32_t volumeID)</td></tr>
<tr class="memdesc:afefb0d9bc8ad9149aa7bb4c6420927d3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the number of indices of the specified shadow volume. <a href="#afefb0d9bc8ad9149aa7bb4c6420927d3">More...</a><br/></td></tr>
<tr class="separator:afefb0d9bc8ad9149aa7bb4c6420927d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1385a976b59da81d71bc27058307c2a0"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1_volume.html#a1385a976b59da81d71bc27058307c2a0">getTriangleCount</a> ()</td></tr>
<tr class="memdesc:a1385a976b59da81d71bc27058307c2a0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the number of triangles in the volume. <a href="#a1385a976b59da81d71bc27058307c2a0">More...</a><br/></td></tr>
<tr class="separator:a1385a976b59da81d71bc27058307c2a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab33e63d9336f382efd92d07195aefcb1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structpvr_1_1_volume_1_1_volume_triangle.html">VolumeTriangle</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1_volume.html#ab33e63d9336f382efd92d07195aefcb1">getTriangleData</a> (uint32_t triangleIndex)</td></tr>
<tr class="memdesc:ab33e63d9336f382efd92d07195aefcb1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the triangle data at a particular index in the volume. <a href="#ab33e63d9336f382efd92d07195aefcb1">More...</a><br/></td></tr>
<tr class="separator:ab33e63d9336f382efd92d07195aefcb1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5dfcd860f12326eacd3f3a7e9e688e4b"><td class="memItemLeft" align="right" valign="top">uint8_t *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1_volume.html#a5dfcd860f12326eacd3f3a7e9e688e4b">getVertexData</a> ()</td></tr>
<tr class="memdesc:a5dfcd860f12326eacd3f3a7e9e688e4b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a pointer to the raw vertex data. Use to bind vertex buffer. <a href="#a5dfcd860f12326eacd3f3a7e9e688e4b">More...</a><br/></td></tr>
<tr class="separator:a5dfcd860f12326eacd3f3a7e9e688e4b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a84be15b69591d7d70a5b84e79ce24b90"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1_volume.html#a84be15b69591d7d70a5b84e79ce24b90">getVertexDataExtrudeOffset</a> ()</td></tr>
<tr class="memdesc:a84be15b69591d7d70a5b84e79ce24b90"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the extrude offset. Is 3. <a href="#a84be15b69591d7d70a5b84e79ce24b90">More...</a><br/></td></tr>
<tr class="separator:a84be15b69591d7d70a5b84e79ce24b90"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a31c5b96f3f6bb0d623e126516765cf6f"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1_volume.html#a31c5b96f3f6bb0d623e126516765cf6f">getVertexDataPositionOffset</a> ()</td></tr>
<tr class="memdesc:a31c5b96f3f6bb0d623e126516765cf6f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the offset of the Position vertex attribute in bytes. Is 0. <a href="#a31c5b96f3f6bb0d623e126516765cf6f">More...</a><br/></td></tr>
<tr class="separator:a31c5b96f3f6bb0d623e126516765cf6f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a02fd603c4a8f313d1d8948fc5ec36826"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1_volume.html#a02fd603c4a8f313d1d8948fc5ec36826">getVertexDataSize</a> ()</td></tr>
<tr class="memdesc:a02fd603c4a8f313d1d8948fc5ec36826"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the size of the vertex attributes in bytes. Is 2 * numVertices * stride. <a href="#a02fd603c4a8f313d1d8948fc5ec36826">More...</a><br/></td></tr>
<tr class="separator:a02fd603c4a8f313d1d8948fc5ec36826"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c61d7e175a9c9c4bb7158a1fb6aec19"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1_volume.html#a2c61d7e175a9c9c4bb7158a1fb6aec19">getVertexDataStride</a> ()</td></tr>
<tr class="memdesc:a2c61d7e175a9c9c4bb7158a1fb6aec19"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the stride of the vertex attributes, in bytes. Is 3 * 4 + 4 = 16 . <a href="#a2c61d7e175a9c9c4bb7158a1fb6aec19">More...</a><br/></td></tr>
<tr class="separator:a2c61d7e175a9c9c4bb7158a1fb6aec19"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a250cbda6ab7de356d04facb0aea93322"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1_volume.html#a250cbda6ab7de356d04facb0aea93322">getVerticesForTriangle</a> (const <a class="el" href="structpvr_1_1_volume_1_1_volume_triangle.html">VolumeTriangle</a> &amp;triangle, glm::vec3 &amp;vertex0, glm::vec3 &amp;vertex1, glm::vec3 &amp;vertex2)</td></tr>
<tr class="memdesc:a250cbda6ab7de356d04facb0aea93322"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the vertices of a particular triangle <a href="#a250cbda6ab7de356d04facb0aea93322">More...</a><br/></td></tr>
<tr class="separator:a250cbda6ab7de356d04facb0aea93322"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae80873027751376e7192aa34a361a160"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1_volume.html#ae80873027751376e7192aa34a361a160">init</a> (const <a class="el" href="classpvr_1_1assets_1_1_mesh.html">assets::Mesh</a> &amp;mesh)</td></tr>
<tr class="memdesc:ae80873027751376e7192aa34a361a160"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize a volume from the data of a Mesh. <a href="#ae80873027751376e7192aa34a361a160">More...</a><br/></td></tr>
<tr class="separator:ae80873027751376e7192aa34a361a160"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a28b487c1342dbad16b7e8bdc465c2fe6"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1_volume.html#a28b487c1342dbad16b7e8bdc465c2fe6">init</a> (const uint8_t *const data, uint32_t numVertices, uint32_t verticesStride, DataType vertexType, const uint8_t *const faceData, uint32_t numFaces, IndexType indexType)</td></tr>
<tr class="memdesc:a28b487c1342dbad16b7e8bdc465c2fe6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize a volume from raw data. <a href="#a28b487c1342dbad16b7e8bdc465c2fe6">More...</a><br/></td></tr>
<tr class="separator:a28b487c1342dbad16b7e8bdc465c2fe6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab6096d851f94d1183b559d5ac19988c7"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1_shadow_volume.html#ab6096d851f94d1183b559d5ac19988c7">isIndexDataInternal</a> (uint32_t volumeID)</td></tr>
<tr class="memdesc:ab6096d851f94d1183b559d5ac19988c7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Query if this shadow volume is using internal index data. <a href="#ab6096d851f94d1183b559d5ac19988c7">More...</a><br/></td></tr>
<tr class="separator:ab6096d851f94d1183b559d5ac19988c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba84d3c752daca126fc813e652643bb3"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1_shadow_volume.html#aba84d3c752daca126fc813e652643bb3">isVisible</a> (const glm::mat4x4 projection, const glm::vec3 &amp;lightModel, bool isPointLight, float cameraZProj, float extrudeLength)</td></tr>
<tr class="memdesc:aba84d3c752daca126fc813e652643bb3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Query if this shadow volume is visible. <a href="#aba84d3c752daca126fc813e652643bb3">More...</a><br/></td></tr>
<tr class="separator:aba84d3c752daca126fc813e652643bb3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a97c3eb5371cc06eb040ff88935616218"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1_volume.html#a97c3eb5371cc06eb040ff88935616218">isVolumeClosed</a> ()</td></tr>
<tr class="memdesc:a97c3eb5371cc06eb040ff88935616218"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get if a volume is closed <a href="#a97c3eb5371cc06eb040ff88935616218">More...</a><br/></td></tr>
<tr class="separator:a97c3eb5371cc06eb040ff88935616218"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af0253009d5bd543576e694a2ca7cd272"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1_shadow_volume.html#af0253009d5bd543576e694a2ca7cd272">projectSilhouette</a> (uint32_t volumeID, uint32_t flags, const glm::vec3 &amp;lightModel, bool isPointLight, char **externalIndexBuffer=NULL)</td></tr>
<tr class="memdesc:af0253009d5bd543576e694a2ca7cd272"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the silhouette of the shadow volume for the specified light and prepare it for projection.  <a href="#af0253009d5bd543576e694a2ca7cd272">More...</a><br/></td></tr>
<tr class="separator:af0253009d5bd543576e694a2ca7cd272"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa96594ef8c6eee78c2f9945215281f3d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1_shadow_volume.html#aa96594ef8c6eee78c2f9945215281f3d">releaseVolume</a> (uint32_t volumeID)</td></tr>
<tr class="memdesc:aa96594ef8c6eee78c2f9945215281f3d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Delete the Shadow <a class="el" href="classpvr_1_1_volume.html" title="Represents data for handling volumes of a single Mesh.">Volume</a> with the provided ID. <a href="#aa96594ef8c6eee78c2f9945215281f3d">More...</a><br/></td></tr>
<tr class="separator:aa96594ef8c6eee78c2f9945215281f3d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:ae6cc654966f92552c741d78ebfe8ff06"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1_volume.html#ae6cc654966f92552c741d78ebfe8ff06">findOrCreateEdge</a> (const glm::vec3 &amp;v0, const glm::vec3 &amp;v1, bool &amp;existed)</td></tr>
<tr class="memdesc:ae6cc654966f92552c741d78ebfe8ff06"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve the index of an edge by vertex coordinates. If it does not exist, create a new one. <a href="#ae6cc654966f92552c741d78ebfe8ff06">More...</a><br/></td></tr>
<tr class="separator:ae6cc654966f92552c741d78ebfe8ff06"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a422ab7ebb84f8df264841ea1f4e0cd7b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1_volume.html#a422ab7ebb84f8df264841ea1f4e0cd7b">findOrCreateTriangle</a> (const glm::vec3 &amp;v0, const glm::vec3 &amp;v1, const glm::vec3 &amp;v2)</td></tr>
<tr class="memdesc:a422ab7ebb84f8df264841ea1f4e0cd7b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a triangle of given coordinates if one does not exist. <a href="#a422ab7ebb84f8df264841ea1f4e0cd7b">More...</a><br/></td></tr>
<tr class="separator:a422ab7ebb84f8df264841ea1f4e0cd7b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a66305ee6f8e45ee4ed68448ec2b3e1d5"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1_volume.html#a66305ee6f8e45ee4ed68448ec2b3e1d5">findOrCreateVertex</a> (const glm::vec3 &amp;vertex, bool &amp;existed)</td></tr>
<tr class="memdesc:a66305ee6f8e45ee4ed68448ec2b3e1d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve the index of a vertex by coordinates. If it does not exist, create a new one. <a href="#a66305ee6f8e45ee4ed68448ec2b3e1d5">More...</a><br/></td></tr>
<tr class="separator:a66305ee6f8e45ee4ed68448ec2b3e1d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:a16b941109dc16216f71965fbcb859874"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a16b941109dc16216f71965fbcb859874"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1_volume.html#a16b941109dc16216f71965fbcb859874">_isClosed</a></td></tr>
<tr class="memdesc:a16b941109dc16216f71965fbcb859874"><td class="mdescLeft">&#160;</td><td class="mdescRight">Is the mesh closed. <br/></td></tr>
<tr class="separator:a16b941109dc16216f71965fbcb859874"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ebe94853d63a993d2c3eea8e5bda494"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8ebe94853d63a993d2c3eea8e5bda494"></a>
<a class="el" href="structpvr_1_1_volume_1_1_volume_mesh.html">VolumeMesh</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1_volume.html#a8ebe94853d63a993d2c3eea8e5bda494">_volumeMesh</a></td></tr>
<tr class="memdesc:a8ebe94853d63a993d2c3eea8e5bda494"><td class="mdescLeft">&#160;</td><td class="mdescRight">The internal data of the mesh. <br/></td></tr>
<tr class="separator:a8ebe94853d63a993d2c3eea8e5bda494"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Represents data for handling Shadow volumes of a single Mesh.</p>
</div><h2 class="groupheader">Member Enumeration Documentation</h2>
<a class="anchor" id="a26e4418ab016fa8dd0e2d2cea9b5a52e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="classpvr_1_1_shadow_volume.html#a26e4418ab016fa8dd0e2d2cea9b5a52e">pvr::ShadowVolume::Flags</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enumerates the different options for different kinds of Shadow volumes.</p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><em><a class="anchor" id="a26e4418ab016fa8dd0e2d2cea9b5a52eaeac5571bd351f6545e1ec4e9f48b62d6"></a>Visible</em>&#160;</td><td class="fielddoc">
<p>The specified part is Visible. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a26e4418ab016fa8dd0e2d2cea9b5a52ea66e365df8866e60572a47d4599d601d6"></a>Cap_front</em>&#160;</td><td class="fielddoc">
<p>The front cap of the volume. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a26e4418ab016fa8dd0e2d2cea9b5a52ea5ab4f380ff80f11066790c7010dcaf15"></a>Cap_back</em>&#160;</td><td class="fielddoc">
<p>The back cap of the volume. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a26e4418ab016fa8dd0e2d2cea9b5a52ea4faec57b99c1df26718ef9992ac16529"></a>Zfail</em>&#160;</td><td class="fielddoc">
<p>The specified item is configured as Z-Fail. </p>
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="ad375982bd94062bf68af87ec39929c5a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">pvr::ShadowVolume::~ShadowVolume </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>dtor, releases all resources held by the shadow volume.</p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="acec04eaf1f74a913ec1ad952d411be1e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pvr::ShadowVolume::alllocateShadowVolume </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>volumeID</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allocate memory for a new shadow volume with the specified ID.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">volumeID</td><td>The ID of the volume. If exists, it will be overwritten.</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ae6cc654966f92552c741d78ebfe8ff06"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t pvr::Volume::findOrCreateEdge </td>
          <td>(</td>
          <td class="paramtype">const glm::vec3 &amp;&#160;</td>
          <td class="paramname"><em>v0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const glm::vec3 &amp;&#160;</td>
          <td class="paramname"><em>v1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool &amp;&#160;</td>
          <td class="paramname"><em>existed</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Retrieve the index of an edge by vertex coordinates. If it does not exist, create a new one.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v0</td><td>The coordinates of the first vertex of the edge</td></tr>
    <tr><td class="paramname">v1</td><td>The coordinates of the second vertex of the edge</td></tr>
    <tr><td class="paramname">existed</td><td>Output: Is set to true if the edge already existed, otherwise will be set to false</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The index of the edge (existing or new)</dd></dl>

</div>
</div>
<a class="anchor" id="a422ab7ebb84f8df264841ea1f4e0cd7b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void pvr::Volume::findOrCreateTriangle </td>
          <td>(</td>
          <td class="paramtype">const glm::vec3 &amp;&#160;</td>
          <td class="paramname"><em>v0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const glm::vec3 &amp;&#160;</td>
          <td class="paramname"><em>v1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const glm::vec3 &amp;&#160;</td>
          <td class="paramname"><em>v2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a triangle of given coordinates if one does not exist.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v0</td><td>The coordinates of the first vertex of the edge</td></tr>
    <tr><td class="paramname">v1</td><td>The coordinates of the second vertex of the edge</td></tr>
    <tr><td class="paramname">v2</td><td>The coordinates of the third vertex of the edge</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a66305ee6f8e45ee4ed68448ec2b3e1d5"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t pvr::Volume::findOrCreateVertex </td>
          <td>(</td>
          <td class="paramtype">const glm::vec3 &amp;&#160;</td>
          <td class="paramname"><em>vertex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool &amp;&#160;</td>
          <td class="paramname"><em>existed</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Retrieve the index of a vertex by coordinates. If it does not exist, create a new one.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vertex</td><td>The coordinates of a vertex</td></tr>
    <tr><td class="paramname">existed</td><td>Output: Is set to true if the vertex already existed, otherwise will be set to false</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The index of the vertex (existing or new)</dd></dl>

</div>
</div>
<a class="anchor" id="a894e9d0050d4fce44dd9903cc21d9cf3"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t pvr::Volume::getIndexDataSize </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the size of the Index data, in bytes.</p>
<dl class="section return"><dt>Returns</dt><dd>The index data size</dd></dl>

</div>
</div>
<a class="anchor" id="a13a0ecadd29849f13633e8ef89a4dda2"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t pvr::Volume::getIndexDataStride </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the stride of the Index data, in bytes. Is sizeof(IndexType).</p>
<dl class="section return"><dt>Returns</dt><dd>The index data stride </dd></dl>

</div>
</div>
<a class="anchor" id="af851abc9cee9252ba9589f276cc7ca51"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char* pvr::ShadowVolume::getIndices </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>volumeID</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the indices of the specified shadow volume.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">volumeID</td><td>shadow volume id</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the Index data</dd></dl>

</div>
</div>
<a class="anchor" id="afefb0d9bc8ad9149aa7bb4c6420927d3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t pvr::ShadowVolume::getNumIndices </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>volumeID</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the number of indices of the specified shadow volume.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">volumeID</td><td>Shadow volume id</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of indexes </dd></dl>

</div>
</div>
<a class="anchor" id="a1385a976b59da81d71bc27058307c2a0"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t pvr::Volume::getTriangleCount </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the number of triangles in the volume.</p>
<dl class="section return"><dt>Returns</dt><dd>The number of triangles</dd></dl>

</div>
</div>
<a class="anchor" id="ab33e63d9336f382efd92d07195aefcb1"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structpvr_1_1_volume_1_1_volume_triangle.html">VolumeTriangle</a> pvr::Volume::getTriangleData </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>triangleIndex</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the triangle data at a particular index in the volume.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">triangleIndex</td><td>The index of the triangle to retrieve</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The triangle data</dd></dl>

</div>
</div>
<a class="anchor" id="a5dfcd860f12326eacd3f3a7e9e688e4b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t* pvr::Volume::getVertexData </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get a pointer to the raw vertex data. Use to bind vertex buffer.</p>
<dl class="section return"><dt>Returns</dt><dd>The vertex data</dd></dl>

</div>
</div>
<a class="anchor" id="a84be15b69591d7d70a5b84e79ce24b90"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t pvr::Volume::getVertexDataExtrudeOffset </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the extrude offset. Is 3.</p>
<dl class="section return"><dt>Returns</dt><dd>The size of each vertex attribute</dd></dl>

</div>
</div>
<a class="anchor" id="a31c5b96f3f6bb0d623e126516765cf6f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t pvr::Volume::getVertexDataPositionOffset </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the offset of the Position vertex attribute in bytes. Is 0.</p>
<dl class="section return"><dt>Returns</dt><dd>The offset of the Position attribute</dd></dl>

</div>
</div>
<a class="anchor" id="a02fd603c4a8f313d1d8948fc5ec36826"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t pvr::Volume::getVertexDataSize </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the size of the vertex attributes in bytes. Is 2 * numVertices * stride.</p>
<dl class="section return"><dt>Returns</dt><dd>The size of the vertex data</dd></dl>

</div>
</div>
<a class="anchor" id="a2c61d7e175a9c9c4bb7158a1fb6aec19"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t pvr::Volume::getVertexDataStride </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the stride of the vertex attributes, in bytes. Is 3 * 4 + 4 = 16 .</p>
<dl class="section return"><dt>Returns</dt><dd>The stride of the vertex attributes</dd></dl>

</div>
</div>
<a class="anchor" id="a250cbda6ab7de356d04facb0aea93322"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void pvr::Volume::getVerticesForTriangle </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structpvr_1_1_volume_1_1_volume_triangle.html">VolumeTriangle</a> &amp;&#160;</td>
          <td class="paramname"><em>triangle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">glm::vec3 &amp;&#160;</td>
          <td class="paramname"><em>vertex0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">glm::vec3 &amp;&#160;</td>
          <td class="paramname"><em>vertex1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">glm::vec3 &amp;&#160;</td>
          <td class="paramname"><em>vertex2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the vertices of a particular triangle</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">triangle</td><td>The triangle from which to return the vertices</td></tr>
    <tr><td class="paramname">vertex0</td><td>Output: The first vertex</td></tr>
    <tr><td class="paramname">vertex1</td><td>Output: The second vertex</td></tr>
    <tr><td class="paramname">vertex2</td><td>Output: The third vertex</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ae80873027751376e7192aa34a361a160"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool pvr::Volume::init </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classpvr_1_1assets_1_1_mesh.html">assets::Mesh</a> &amp;&#160;</td>
          <td class="paramname"><em>mesh</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initialize a volume from the data of a Mesh.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mesh</td><td>A mesh whose vertex data is used to initialize this <a class="el" href="classpvr_1_1_volume.html" title="Represents data for handling volumes of a single Mesh.">Volume</a> instance. The POSITION semantic must be present in the mesh.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if successfully initialized, otherwise false</dd></dl>
<p>This method will pre-process the data in the mesh, to calculate all vertices, edges and faces of the mesh as required. In effect it will extract the POSITION semantic data and the face data and use it to create a "light" and cleaned up version of the mesh that will be then used to calculate extruded volumes as required. </p>

</div>
</div>
<a class="anchor" id="a28b487c1342dbad16b7e8bdc465c2fe6"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool pvr::Volume::init </td>
          <td>(</td>
          <td class="paramtype">const uint8_t *const&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>numVertices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>verticesStride</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">DataType&#160;</td>
          <td class="paramname"><em>vertexType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t *const&#160;</td>
          <td class="paramname"><em>faceData</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>numFaces</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IndexType&#160;</td>
          <td class="paramname"><em>indexType</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initialize a volume from raw data.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>Pointer to the first POSITION attribute of vertex data (so buffer_start + offset)</td></tr>
    <tr><td class="paramname">numVertices</td><td>Number of vertices in (data)</td></tr>
    <tr><td class="paramname">verticesStride</td><td>Stride between each vertex attribute</td></tr>
    <tr><td class="paramname">vertexType</td><td>The DataType of each position coordinate</td></tr>
    <tr><td class="paramname">faceData</td><td>Pointer to index data</td></tr>
    <tr><td class="paramname">numFaces</td><td>Number of Faces contained in (faceData)</td></tr>
    <tr><td class="paramname">indexType</td><td>Type of indices in faceData (16/32 bit)</td></tr>
  </table>
  </dd>
</dl>
<p>This method will pre-process the data in the mesh, to calculate all vertices, edges and faces of the mesh as required</p>
<dl class="section return"><dt>Returns</dt><dd>True if successfully initialized, otherwise false</dd></dl>

</div>
</div>
<a class="anchor" id="ab6096d851f94d1183b559d5ac19988c7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool pvr::ShadowVolume::isIndexDataInternal </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>volumeID</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Query if this shadow volume is using internal index data.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">volumeID</td><td>Shadow volume id</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Return true if is using internal index data</dd></dl>

</div>
</div>
<a class="anchor" id="aba84d3c752daca126fc813e652643bb3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t pvr::ShadowVolume::isVisible </td>
          <td>(</td>
          <td class="paramtype">const glm::mat4x4&#160;</td>
          <td class="paramname"><em>projection</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const glm::vec3 &amp;&#160;</td>
          <td class="paramname"><em>lightModel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>isPointLight</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>cameraZProj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>extrudeLength</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Query if this shadow volume is visible.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">projection</td><td>A projection matrix to test</td></tr>
    <tr><td class="paramname">lightModel</td><td>The light source position (if point) or direction (if directional)</td></tr>
    <tr><td class="paramname">isPointLight</td><td>True if it is a point light, false if it is directional</td></tr>
    <tr><td class="paramname">cameraZProj</td><td>The Z projection of the camera</td></tr>
    <tr><td class="paramname">extrudeLength</td><td>The length of extrusion for the volume.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the volume is visible, otherwise false</dd></dl>

</div>
</div>
<a class="anchor" id="a97c3eb5371cc06eb040ff88935616218"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool pvr::Volume::isVolumeClosed </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get if a volume is closed</p>
<dl class="section return"><dt>Returns</dt><dd>True if voluem is closed, otherwise false</dd></dl>

</div>
</div>
<a class="anchor" id="af0253009d5bd543576e694a2ca7cd272"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool pvr::ShadowVolume::projectSilhouette </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>volumeID</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>flags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const glm::vec3 &amp;&#160;</td>
          <td class="paramname"><em>lightModel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>isPointLight</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char **&#160;</td>
          <td class="paramname"><em>externalIndexBuffer</em> = <code>NULL</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Find the silhouette of the shadow volume for the specified light and prepare it for projection. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">volumeID</td><td>The Shadow <a class="el" href="classpvr_1_1_volume.html" title="Represents data for handling volumes of a single Mesh.">Volume</a> to prepare. Must have had alllocateShadowVolume called on it</td></tr>
    <tr><td class="paramname">flags</td><td>The properties of the shadow volume to generate (caps, technique)</td></tr>
    <tr><td class="paramname">lightModel</td><td>The Model-space light. Either point-light(or spot) or directional light supported </td></tr>
    <tr><td class="paramname">isPointLight</td><td>Pass true for point (or spot) light, false for directional</td></tr>
    <tr><td class="paramname">externalIndexBuffer</td><td>An external buffer that contains custom, user provided index data.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if successful, otherwise false</dd></dl>

</div>
</div>
<a class="anchor" id="aa96594ef8c6eee78c2f9945215281f3d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool pvr::ShadowVolume::releaseVolume </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>volumeID</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Delete the Shadow <a class="el" href="classpvr_1_1_volume.html" title="Represents data for handling volumes of a single Mesh.">Volume</a> with the provided ID.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">volumeID</td><td>shadow volume id</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>pvr::Success of suc</dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>/usr/buildxl/buildroot/sdk/branch/SDK/framework/PVRAssets/<a class="el" href="_shadow_volume_8h_source.html">ShadowVolume.h</a></li>
</ul>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.8.4-->
<!-- start footer part (NON TREEVIEW ONLY!!) -->
<!--BEGIN GENERATE_TREEVIEW-->
<div id="FooterMainContainer">
	<div id="FooterContainer">
		<div class="footerlogo">
			<a href="http://www.imgtec.com" target="_blank"><img src="img-footer-logo-grey.png" width="100%" height="100%" border="none" /></a>
		</div>
		<div class="copyright"><p>&copy; Imagination Technologies Limited<br> All rights reserved</p></div>
	</div>
</div>
</body>
</html>
