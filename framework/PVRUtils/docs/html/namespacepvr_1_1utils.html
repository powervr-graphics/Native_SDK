<!-- HTML header for doxygen 1.8.4-->
<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="generator" content="Doxygen 1.8.6"/>
<title>PVRUtils: pvr::utils Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="IMGdoxygen.css" rel="stylesheet" type="text/css"/>
<link rel="shortcut icon" type="image/x-icon" href="img.ico">
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
  <div class="headercontent">
    <div class="PVRlogo">
      <a href="https://www.imgtec.com/developers/" target="_blank"><img src="PVRlogo.png" width="40%" height="40%"  border="none" /></a>
    </div>
    <a class="SiteTitle"><span id="projectname">PVRUtils</span> Documentation</a>
   <tbody>
  </div>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.6 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="inherits.html"><span>Class&#160;Hierarchy</span></a></li>
      <li class="current"><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Friends</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Macros</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(10)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacepvr.html">pvr</a></li><li class="navelem"><a class="el" href="namespacepvr_1_1utils.html">utils</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">pvr::utils Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Main namespace for the PVRUtils Library  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpvr_1_1utils_1_1_debug_utils_callbacks.html">DebugUtilsCallbacks</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A simple wrapper structure which provides a more abstract representation of a set of debug utils messengers or debug callbacks when using either VK_EXT_debug_utils or VK_EXT_debug_report respectively. <a href="structpvr_1_1utils_1_1_debug_utils_callbacks.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpvr_1_1utils_1_1_device_extensions.html">DeviceExtensions</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Container for a list of device extensions to be used for initiailising a device using the helper function 'createDeviceAndQueues'. <a href="structpvr_1_1utils_1_1_device_extensions.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1utils_1_1_image_api_async_uploader.html">ImageApiAsyncUploader</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class wraps a worker thread that uploads texture to the GPU asynchronously and returns futures to them. This class would normally be used with Texture Futures as well, in order to do both of the operations asynchronously. <a href="classpvr_1_1utils_1_1_image_api_async_uploader.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpvr_1_1utils_1_1_image_update_info.html">ImageUpdateInfo</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <a class="el" href="structpvr_1_1utils_1_1_image_update_info.html" title="The ImageUpdateInfo struct.">ImageUpdateInfo</a> struct. <a href="structpvr_1_1utils_1_1_image_update_info.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpvr_1_1utils_1_1_image_upload_future__.html">ImageUploadFuture_</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class provides a wrapper for a Image upload future <a href="structpvr_1_1utils_1_1_image_upload_future__.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpvr_1_1utils_1_1_instance_extensions.html">InstanceExtensions</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Container for a list of instance extensions to be used for initiailising an instance using the helper function 'createInstanceAndSurface'. <a href="structpvr_1_1utils_1_1_instance_extensions.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpvr_1_1utils_1_1_instance_layers.html">InstanceLayers</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Container for a list of instance layers to be used for initiailising an instance using the helper function 'createInstanceAndSurface'. <a href="structpvr_1_1utils_1_1_instance_layers.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1utils_1_1_model_gles.html">ModelGles</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <a class="el" href="classpvr_1_1utils_1_1_model_gles.html" title="The ModelGles class provides the functionality for creating all of the buffers (vbos and ibos) and te...">ModelGles</a> class provides the functionality for creating all of the buffers (vbos and ibos) and textures required for basic rendering of a pvr::assets::Model using OpenGL ES. <a href="classpvr_1_1utils_1_1_model_gles.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpvr_1_1utils_1_1_queue_access_info.html">QueueAccessInfo</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A structure encapsulating the family id and queue id of a particular queue retrieved via the helper function 'createDeviceAndQueues'. The family id corresponds to the family id the queue was retrieved from. The queue id corresponds to the particular queue index for the retrieved queue. <a href="structpvr_1_1utils_1_1_queue_access_info.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpvr_1_1utils_1_1_queue_populate_info.html">QueuePopulateInfo</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A structure encapsulating the set of queue flags required for a particular queue retrieved via the helper function 'createDeviceAndQueues'. Optionally additionally providing a surface will indicate that the queue must support presentation via the provided surface. <a href="structpvr_1_1utils_1_1_queue_populate_info.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1utils_1_1_structured_buffer_view.html">StructuredBufferView</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A structured buffer view is a class that can be used to define an explicit structure to an object that is usually accessed as raw memory. For example, a GPU-side buffer is mapped to a void pointer, but a <a class="el" href="classpvr_1_1utils_1_1_structured_buffer_view.html" title="A structured buffer view is a class that can be used to define an explicit structure to an object tha...">StructuredBufferView</a> can be used to create a runtime structure for it, and set its entries one by one. Example usage for accessing a <a class="el" href="classpvr_1_1utils_1_1_structured_buffer_view.html" title="A structured buffer view is a class that can be used to define an explicit structure to an object tha...">StructuredBufferView</a> defined for the buffer bonesUbo defined below: struct Bone{ highp mat4 boneMatrix; highp mat3 boneMatrixIT; }; layout(std140, binding = i) uniform bonesUbo { mediump int BoneCount; // a name or index can be used to retrieve a particular element Bone bones[]; // elementArrayIndex is used to index into an arrays of elements } boneBuffer; getElementByName("BoneCount") = boneBuffer.BoneCount getElementByName("bones") = boneBuffer.Bone[0] getElementByName("bones", 1) = boneBuffer.Bone[1] <a href="classpvr_1_1utils_1_1_structured_buffer_view.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1utils_1_1_structured_buffer_view_element.html">StructuredBufferViewElement</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defines a <a class="el" href="classpvr_1_1utils_1_1_structured_buffer_view_element.html" title="Defines a StructuredBufferViewElement. A StructuredBufferViewElement handles the public interface use...">StructuredBufferViewElement</a>. A <a class="el" href="classpvr_1_1utils_1_1_structured_buffer_view_element.html" title="Defines a StructuredBufferViewElement. A StructuredBufferViewElement handles the public interface use...">StructuredBufferViewElement</a> handles the public interface used for working with a <a class="el" href="classpvr_1_1utils_1_1_structured_memory_entry.html" title="Defines a StructuredMemoryEntry element. A StructuredMemoryEntry defines an actual element entry in a...">StructuredMemoryEntry</a>. <a href="classpvr_1_1utils_1_1_structured_buffer_view_element.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1utils_1_1_structured_memory_description.html">StructuredMemoryDescription</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defines a memory element description. The element will be provided with a name, type and number of array elements. The element itself may also contain child memory elements <a href="classpvr_1_1utils_1_1_structured_memory_description.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1utils_1_1_structured_memory_entry.html">StructuredMemoryEntry</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defines a <a class="el" href="classpvr_1_1utils_1_1_structured_memory_entry.html" title="Defines a StructuredMemoryEntry element. A StructuredMemoryEntry defines an actual element entry in a...">StructuredMemoryEntry</a> element. A <a class="el" href="classpvr_1_1utils_1_1_structured_memory_entry.html" title="Defines a StructuredMemoryEntry element. A StructuredMemoryEntry defines an actual element entry in a...">StructuredMemoryEntry</a> defines an actual element entry in a structured buffer view. WARNING: Arrays of size 1 not supported - they are considered non-arrays. WARNING: Due to pointers to parents, no reallocations must <em>ever</em> happen. Once initialized, the lists must be final. WARNING: THE ENTIRE PUBLIC INTERFACE OF THIS CLASS EXCEPT FOR INIT, IS CONST. WARNING: IT IS NOT INTENDED FOR THIS CLASS TO BE EVER MODIFIABLE. <a href="classpvr_1_1utils_1_1_structured_memory_entry.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpvr_1_1utils_1_1_texture_upload_results.html">TextureUploadResults</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <a class="el" href="structpvr_1_1utils_1_1_texture_upload_results.html" title="The TextureUploadResults structure provides the results for texture upload functions in a simple to u...">TextureUploadResults</a> structure provides the results for texture upload functions in a simple to use structure <a href="structpvr_1_1utils_1_1_texture_upload_results.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpvr_1_1utils_1_1_vertex_attribute_info.html">VertexAttributeInfo</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Contains a full description of a Vertex Attribute: Index, format, number of elements, offset in the buffer, optionally name. All values (except attributeName) must be set explicitly. <a href="structpvr_1_1utils_1_1_vertex_attribute_info.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpvr_1_1utils_1_1_vertex_attribute_info_with_binding.html">VertexAttributeInfoWithBinding</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A container struct carrying Vertex Attribute information (vertex layout, plus binding point) <a href="structpvr_1_1utils_1_1_vertex_attribute_info_with_binding.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpvr_1_1utils_1_1_vertex_bindings.html">VertexBindings</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents a shader Explicit binding, tying a Semantic name to an Attribute Index. <a href="structpvr_1_1utils_1_1_vertex_bindings.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpvr_1_1utils_1_1_vertex_bindings___name.html">VertexBindings_Name</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents a shader Reflective binding, tying a Semantic name to an Attribute variable name. <a href="structpvr_1_1utils_1_1_vertex_bindings___name.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpvr_1_1utils_1_1_vertex_input_binding_info.html">VertexInputBindingInfo</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Information about a Buffer binding: Binding index, stride, (instance) step rate. <a href="structpvr_1_1utils_1_1_vertex_input_binding_info.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpvr_1_1utils_1_1_vulkan_version.html">VulkanVersion</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <a class="el" href="structpvr_1_1utils_1_1_vulkan_version.html" title="The VulkanVersion structure provides an easy mechanism for constructing the Vulkan version for use wh...">VulkanVersion</a> structure provides an easy mechanism for constructing the Vulkan version for use when creating a Vulkan instance. <a href="structpvr_1_1utils_1_1_vulkan_version.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:a990a2454c0ddfb8bf5383a11262a76ec"><td class="memItemLeft" align="right" valign="top">typedef std::shared_ptr<br class="typebreak"/>
&lt; async::IFrameworkAsyncResult<br class="typebreak"/>
&lt; pvrvk::ImageView &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr_1_1utils.html#a990a2454c0ddfb8bf5383a11262a76ec">AsyncApiTexture</a></td></tr>
<tr class="memdesc:a990a2454c0ddfb8bf5383a11262a76ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides a reference counted pointer to a IFrameworkAsyncResult specialised by an ImageView which will be used as the main interface for using API specific asynchronous textures. <a href="#a990a2454c0ddfb8bf5383a11262a76ec">More...</a><br/></td></tr>
<tr class="separator:a990a2454c0ddfb8bf5383a11262a76ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a54bd78a7c682d6b8161db1db04f1f910"><td class="memItemLeft" align="right" valign="top">typedef std::shared_ptr<br class="typebreak"/>
&lt; async::IFrameworkAsyncResult<br class="typebreak"/>
&lt; <a class="el" href="namespacepvr_1_1utils.html#adbd0dc78bf662b222b9e01a5efb6c778">TexturePtr</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr_1_1utils.html#a54bd78a7c682d6b8161db1db04f1f910">AsyncTexture</a></td></tr>
<tr class="memdesc:a54bd78a7c682d6b8161db1db04f1f910"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides a reference counted pointer to a IFrameworkAsyncResult specialised by a TexturePtr which will be used as the main interface for using API agnostic asynchronous textures. <a href="#a54bd78a7c682d6b8161db1db04f1f910">More...</a><br/></td></tr>
<tr class="separator:a54bd78a7c682d6b8161db1db04f1f910"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab251744ba4295771d35ea8f3ee497e0f"><td class="memItemLeft" align="right" valign="top">typedef std::shared_ptr<br class="typebreak"/>
&lt; <a class="el" href="structpvr_1_1utils_1_1_image_upload_future__.html">ImageUploadFuture_</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr_1_1utils.html#ab251744ba4295771d35ea8f3ee497e0f">ImageUploadFuture</a></td></tr>
<tr class="memdesc:ab251744ba4295771d35ea8f3ee497e0f"><td class="mdescLeft">&#160;</td><td class="mdescRight">A ref-counted pointer to a Future of an Image Upload: A class that wraps the texture that "is being uploaded on a separate thread", together with functions to "query if the upload is yet complete" and to "block until the upload is complete, if necessary, and return the result" <a href="#ab251744ba4295771d35ea8f3ee497e0f">More...</a><br/></td></tr>
<tr class="separator:ab251744ba4295771d35ea8f3ee497e0f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adbd0dc78bf662b222b9e01a5efb6c778"><td class="memItemLeft" align="right" valign="top">typedef std::shared_ptr&lt; Texture &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr_1_1utils.html#adbd0dc78bf662b222b9e01a5efb6c778">TexturePtr</a></td></tr>
<tr class="memdesc:adbd0dc78bf662b222b9e01a5efb6c778"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides a reference counted pointer to a pvr::Texture which will be used for loading API agnostic texture data to disk. <a href="#adbd0dc78bf662b222b9e01a5efb6c778">More...</a><br/></td></tr>
<tr class="separator:adbd0dc78bf662b222b9e01a5efb6c778"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ac66fa9a9c7f8232c3f5aa3f41106cfea"><td class="memTemplParams" colspan="2">template&lt;typename VboContainer_ , typename IboContainer_ &gt; </td></tr>
<tr class="memitem:ac66fa9a9c7f8232c3f5aa3f41106cfea"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacepvr_1_1utils.html#ac66fa9a9c7f8232c3f5aa3f41106cfea">appendSingleBuffersFromModel</a> (pvrvk::Device &amp;device, const assets::Model &amp;model, VboContainer_ &amp;vbos, IboContainer_ &amp;ibos, pvrvk::CommandBuffer &amp;uploadCmdBuffer, bool &amp;requiresCommandBufferSubmission, vma::Allocator *bufferAllocator=nullptr, vma::AllocationCreateFlags vmaAllocationCreateFlags=vma::AllocationCreateFlags::e_MAPPED_BIT)</td></tr>
<tr class="memdesc:ac66fa9a9c7f8232c3f5aa3f41106cfea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Auto generates a set of VBOs and a set of IBOs from the vertex data of the meshes of a model and appends them at the end of containers provided by the user. <a href="#ac66fa9a9c7f8232c3f5aa3f41106cfea">More...</a><br/></td></tr>
<tr class="separator:ac66fa9a9c7f8232c3f5aa3f41106cfea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f241ba112200732fffaeb2906b6ed4b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr_1_1utils.html#a3f241ba112200732fffaeb2906b6ed4b">beginCommandBufferDebugLabel</a> (pvrvk::CommandBufferBase commandBufferBase, const pvrvk::DebugUtilsLabel &amp;labelInfo)</td></tr>
<tr class="memdesc:a3f241ba112200732fffaeb2906b6ed4b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Begins identifying a region of work submitted to this command buffer. The calls to beginDebugUtilsLabel and endDebugUtilsLabel must be matched and balanced. <a href="#a3f241ba112200732fffaeb2906b6ed4b">More...</a><br/></td></tr>
<tr class="separator:a3f241ba112200732fffaeb2906b6ed4b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab62f121a7b8a9d790ca4e4e3dfcff0aa"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr_1_1utils.html#ab62f121a7b8a9d790ca4e4e3dfcff0aa">beginCommandBufferDebugLabel</a> (pvrvk::CommandBuffer &amp;commandBuffer, const pvrvk::DebugUtilsLabel &amp;labelInfo)</td></tr>
<tr class="memdesc:ab62f121a7b8a9d790ca4e4e3dfcff0aa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Begins identifying a region of work submitted to this command buffer. The calls to beginDebugUtilsLabel and endDebugUtilsLabel must be matched and balanced. <a href="#ab62f121a7b8a9d790ca4e4e3dfcff0aa">More...</a><br/></td></tr>
<tr class="separator:ab62f121a7b8a9d790ca4e4e3dfcff0aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a45dc67a22e33dc6bf735edc27a1432ef"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr_1_1utils.html#a45dc67a22e33dc6bf735edc27a1432ef">beginCommandBufferDebugLabel</a> (pvrvk::SecondaryCommandBuffer &amp;secondaryCommandBuffer, const pvrvk::DebugUtilsLabel &amp;labelInfo)</td></tr>
<tr class="memdesc:a45dc67a22e33dc6bf735edc27a1432ef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Begins identifying a region of work submitted to this secondary command buffer. The calls to beginDebugUtilsLabel and endDebugUtilsLabel must be matched and balanced. <a href="#a45dc67a22e33dc6bf735edc27a1432ef">More...</a><br/></td></tr>
<tr class="separator:a45dc67a22e33dc6bf735edc27a1432ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7eaec27096b06e097a3ead372e30c68c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr_1_1utils.html#a7eaec27096b06e097a3ead372e30c68c">beginQueueDebugLabel</a> (pvrvk::Queue queue, const pvrvk::DebugUtilsLabel &amp;labelInfo)</td></tr>
<tr class="memdesc:a7eaec27096b06e097a3ead372e30c68c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Begins identifying a region of work submitted to this queue. The calls to beginDebugUtilsLabel and endDebugUtilsLabel must be matched and balanced. <a href="#a7eaec27096b06e097a3ead372e30c68c">More...</a><br/></td></tr>
<tr class="separator:a7eaec27096b06e097a3ead372e30c68c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e26711ea2633048564188b42d62f11b"><td class="memItemLeft" align="right" valign="top">std::vector&lt; unsigned char &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr_1_1utils.html#a1e26711ea2633048564188b42d62f11b">captureImageRegion</a> (pvrvk::Queue &amp;queue, pvrvk::CommandPool &amp;commandPool, pvrvk::Image &amp;image, pvrvk::Offset3D srcOffset=pvrvk::Offset3D(0, 0, 0), pvrvk::Extent3D srcExtent=pvrvk::Extent3D(-1,-1,-1), pvrvk::Format destinationImageFormat=pvrvk::Format::e_UNDEFINED, pvrvk::ImageLayout imageInitialLayout=pvrvk::ImageLayout::e_TRANSFER_SRC_OPTIMAL, pvrvk::ImageLayout imageFinalLayout=pvrvk::ImageLayout::e_TRANSFER_DST_OPTIMAL, vma::Allocator *bufferAllocator=nullptr, vma::Allocator *imageAllocator=nullptr)</td></tr>
<tr class="memdesc:a1e26711ea2633048564188b42d62f11b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves and returns the contents of a particular image region. Note that the image must have been created with the pvrvk::ImageUsageFlags::e_TRANSFER_SRC_BIT set. <a href="#a1e26711ea2633048564188b42d62f11b">More...</a><br/></td></tr>
<tr class="separator:a1e26711ea2633048564188b42d62f11b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aafce526b759924e9114572d863b5b8f6"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr_1_1utils.html#aafce526b759924e9114572d863b5b8f6">checkApiError</a> (std::string *errOutStr=NULL)</td></tr>
<tr class="memdesc:aafce526b759924e9114572d863b5b8f6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks and returns api error if appropriate. <a href="#aafce526b759924e9114572d863b5b8f6">More...</a><br/></td></tr>
<tr class="separator:aafce526b759924e9114572d863b5b8f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b92cb613310549a5b748d1f5c4b4557"><td class="memItemLeft" align="right" valign="top">GLenum&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr_1_1utils.html#a7b92cb613310549a5b748d1f5c4b4557">convertToGles</a> (IndexType type)</td></tr>
<tr class="memdesc:a7b92cb613310549a5b748d1f5c4b4557"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts from a pvr::IndexType to its OpenGL ES GLenum counterpart. <a href="#a7b92cb613310549a5b748d1f5c4b4557">More...</a><br/></td></tr>
<tr class="separator:a7b92cb613310549a5b748d1f5c4b4557"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aabfe42ed26ab9fcb99118de82013eedb"><td class="memItemLeft" align="right" valign="top">GLenum&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr_1_1utils.html#aabfe42ed26ab9fcb99118de82013eedb">convertToGles</a> (Face face)</td></tr>
<tr class="memdesc:aabfe42ed26ab9fcb99118de82013eedb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert to opengl face. <a href="#aabfe42ed26ab9fcb99118de82013eedb">More...</a><br/></td></tr>
<tr class="separator:aabfe42ed26ab9fcb99118de82013eedb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2cf730a0573373abb18dcefa9390e840"><td class="memItemLeft" align="right" valign="top">GLenum&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr_1_1utils.html#a2cf730a0573373abb18dcefa9390e840">convertToGles</a> (PolygonWindingOrder windingOrder)</td></tr>
<tr class="memdesc:a2cf730a0573373abb18dcefa9390e840"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert to opengl winding-order. <a href="#a2cf730a0573373abb18dcefa9390e840">More...</a><br/></td></tr>
<tr class="separator:a2cf730a0573373abb18dcefa9390e840"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a196375d06b5173798e46037c7b8eb890"><td class="memItemLeft" align="right" valign="top">GLenum&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr_1_1utils.html#a196375d06b5173798e46037c7b8eb890">convertToGles</a> (CompareOp func)</td></tr>
<tr class="memdesc:a196375d06b5173798e46037c7b8eb890"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert to opengl comparison mode. <a href="#a196375d06b5173798e46037c7b8eb890">More...</a><br/></td></tr>
<tr class="separator:a196375d06b5173798e46037c7b8eb890"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a648788eddea6a26479db4a04cdeedf55"><td class="memItemLeft" align="right" valign="top">GLenum&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr_1_1utils.html#a648788eddea6a26479db4a04cdeedf55">convertToGles</a> (ImageAspectFlags type)</td></tr>
<tr class="memdesc:a648788eddea6a26479db4a04cdeedf55"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert to an opengl image aspect type. <a href="#a648788eddea6a26479db4a04cdeedf55">More...</a><br/></td></tr>
<tr class="separator:a648788eddea6a26479db4a04cdeedf55"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d36f28640fc36caaed25f8935a48229"><td class="memItemLeft" align="right" valign="top">GLenum&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr_1_1utils.html#a7d36f28640fc36caaed25f8935a48229">convertToGles</a> (ImageViewType texType)</td></tr>
<tr class="memdesc:a7d36f28640fc36caaed25f8935a48229"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert to opengl texture type. <a href="#a7d36f28640fc36caaed25f8935a48229">More...</a><br/></td></tr>
<tr class="separator:a7d36f28640fc36caaed25f8935a48229"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad86cd8604c6d3c155b531d7a1784581f"><td class="memItemLeft" align="right" valign="top">GLenum&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr_1_1utils.html#ad86cd8604c6d3c155b531d7a1784581f">convertToGles</a> (DataType dataType)</td></tr>
<tr class="memdesc:ad86cd8604c6d3c155b531d7a1784581f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert to opengl data type. <a href="#ad86cd8604c6d3c155b531d7a1784581f">More...</a><br/></td></tr>
<tr class="separator:ad86cd8604c6d3c155b531d7a1784581f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4848cd91db829306bc8a1ed929762aad"><td class="memItemLeft" align="right" valign="top">GLenum&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr_1_1utils.html#a4848cd91db829306bc8a1ed929762aad">convertToGles</a> (PrimitiveTopology primitiveType)</td></tr>
<tr class="memdesc:a4848cd91db829306bc8a1ed929762aad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert to opengl priitive type. <a href="#a4848cd91db829306bc8a1ed929762aad">More...</a><br/></td></tr>
<tr class="separator:a4848cd91db829306bc8a1ed929762aad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c41ff094638c4216cb39bf821408fe5"><td class="memItemLeft" align="right" valign="top">GLenum&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr_1_1utils.html#a3c41ff094638c4216cb39bf821408fe5">convertToGles</a> (SamplerAddressMode addressMode)</td></tr>
<tr class="memdesc:a3c41ff094638c4216cb39bf821408fe5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert to opengl sampler wrap. <a href="#a3c41ff094638c4216cb39bf821408fe5">More...</a><br/></td></tr>
<tr class="separator:a3c41ff094638c4216cb39bf821408fe5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af1dc4d95376bb577dd85455028527815"><td class="memItemLeft" align="right" valign="top">GLenum&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr_1_1utils.html#af1dc4d95376bb577dd85455028527815">convertToGles</a> (StencilOp stencilOp)</td></tr>
<tr class="memdesc:af1dc4d95376bb577dd85455028527815"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert to opengl stencil op output. <a href="#af1dc4d95376bb577dd85455028527815">More...</a><br/></td></tr>
<tr class="separator:af1dc4d95376bb577dd85455028527815"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe32fb89dfe5e37513af651055cdef15"><td class="memItemLeft" align="right" valign="top">GLenum&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr_1_1utils.html#afe32fb89dfe5e37513af651055cdef15">convertToGles</a> (BlendOp blendOp)</td></tr>
<tr class="memdesc:afe32fb89dfe5e37513af651055cdef15"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert to opengl blend op output. <a href="#afe32fb89dfe5e37513af651055cdef15">More...</a><br/></td></tr>
<tr class="separator:afe32fb89dfe5e37513af651055cdef15"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a20ca18b411c83be99cc9b83137cef4d8"><td class="memItemLeft" align="right" valign="top">GLenum&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr_1_1utils.html#a20ca18b411c83be99cc9b83137cef4d8">convertToGles</a> (BlendFactor blendFactor)</td></tr>
<tr class="memdesc:a20ca18b411c83be99cc9b83137cef4d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert to opengl blend factor output. <a href="#a20ca18b411c83be99cc9b83137cef4d8">More...</a><br/></td></tr>
<tr class="separator:a20ca18b411c83be99cc9b83137cef4d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6faa52cbc7bd9bc2ff02b680ca3c869d"><td class="memItemLeft" align="right" valign="top">pvrvk::IndexType&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr_1_1utils.html#a6faa52cbc7bd9bc2ff02b680ca3c869d">convertToPVRVk</a> (IndexType type)</td></tr>
<tr class="memdesc:a6faa52cbc7bd9bc2ff02b680ca3c869d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a pvr::IndexType to its Native, Vulkan representation. <a href="#a6faa52cbc7bd9bc2ff02b680ca3c869d">More...</a><br/></td></tr>
<tr class="separator:a6faa52cbc7bd9bc2ff02b680ca3c869d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac4535ea5342874964d50833bfa20221c"><td class="memItemLeft" align="right" valign="top">pvrvk::ImageViewType&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr_1_1utils.html#ac4535ea5342874964d50833bfa20221c">convertToPVRVk</a> (ImageViewType texDimemsion)</td></tr>
<tr class="memdesc:ac4535ea5342874964d50833bfa20221c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert to pvrvk image view type <a href="#ac4535ea5342874964d50833bfa20221c">More...</a><br/></td></tr>
<tr class="separator:ac4535ea5342874964d50833bfa20221c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0492010765906fc6787a7e2498ba57c"><td class="memItemLeft" align="right" valign="top">pvrvk::VertexInputRate&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr_1_1utils.html#ae0492010765906fc6787a7e2498ba57c">convertToPVRVk</a> (StepRate stepRate)</td></tr>
<tr class="memdesc:ae0492010765906fc6787a7e2498ba57c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert to pvrvk vertex input rate <a href="#ae0492010765906fc6787a7e2498ba57c">More...</a><br/></td></tr>
<tr class="separator:ae0492010765906fc6787a7e2498ba57c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada8e829e93a104391248c513aeabe8d3"><td class="memItemLeft" align="right" valign="top">pvrvk::DataType&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr_1_1utils.html#ada8e829e93a104391248c513aeabe8d3">convertToPVRVk</a> (DataType dataType)</td></tr>
<tr class="memdesc:ada8e829e93a104391248c513aeabe8d3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert to pvrvk Data type <a href="#ada8e829e93a104391248c513aeabe8d3">More...</a><br/></td></tr>
<tr class="separator:ada8e829e93a104391248c513aeabe8d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3116f95a85b64265c0b26ce81df895cd"><td class="memItemLeft" align="right" valign="top">pvrvk::Format&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr_1_1utils.html#a3116f95a85b64265c0b26ce81df895cd">convertToPVRVk</a> (const ImageDataFormat &amp;format)</td></tr>
<tr class="memdesc:a3116f95a85b64265c0b26ce81df895cd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert to pvrvk pixel format <a href="#a3116f95a85b64265c0b26ce81df895cd">More...</a><br/></td></tr>
<tr class="separator:a3116f95a85b64265c0b26ce81df895cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af9c490851508a5e8618c5f6e15b3cae0"><td class="memItemLeft" align="right" valign="top">pvrvk::StencilOpState&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr_1_1utils.html#af9c490851508a5e8618c5f6e15b3cae0">convertToPVRVk</a> (const StencilState &amp;op)</td></tr>
<tr class="memdesc:af9c490851508a5e8618c5f6e15b3cae0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert to pvrvk StencilOpState <a href="#af9c490851508a5e8618c5f6e15b3cae0">More...</a><br/></td></tr>
<tr class="separator:af9c490851508a5e8618c5f6e15b3cae0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf411047de1c9b93006e248404d156cd"><td class="memItemLeft" align="right" valign="top">pvrvk::PipelineColorBlendAttachmentState&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr_1_1utils.html#abf411047de1c9b93006e248404d156cd">convertToPVRVk</a> (const BlendingConfig &amp;config)</td></tr>
<tr class="memdesc:abf411047de1c9b93006e248404d156cd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert to pvrvk PipelineColorBlendAttachmentState <a href="#abf411047de1c9b93006e248404d156cd">More...</a><br/></td></tr>
<tr class="separator:abf411047de1c9b93006e248404d156cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a980064e6fd1ed7293c5b04941625bccf"><td class="memItemLeft" align="right" valign="top">pvrvk::VertexInputAttributeDescription&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr_1_1utils.html#a980064e6fd1ed7293c5b04941625bccf">convertToPVRVk</a> (const <a class="el" href="structpvr_1_1utils_1_1_vertex_attribute_info.html">VertexAttributeInfo</a> &amp;info, uint32_t binding)</td></tr>
<tr class="memdesc:a980064e6fd1ed7293c5b04941625bccf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert to pvrvk VertexInputAttributeDescription <a href="#a980064e6fd1ed7293c5b04941625bccf">More...</a><br/></td></tr>
<tr class="separator:a980064e6fd1ed7293c5b04941625bccf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a85935527bc9b1766c64a889a5194f405"><td class="memItemLeft" align="right" valign="top">pvrvk::VertexInputBindingDescription&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr_1_1utils.html#a85935527bc9b1766c64a889a5194f405">convertToPVRVk</a> (const <a class="el" href="structpvr_1_1utils_1_1_vertex_input_binding_info.html">VertexInputBindingInfo</a> &amp;info)</td></tr>
<tr class="memdesc:a85935527bc9b1766c64a889a5194f405"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert to pvrvk VertexInputBindingDescription <a href="#a85935527bc9b1766c64a889a5194f405">More...</a><br/></td></tr>
<tr class="separator:a85935527bc9b1766c64a889a5194f405"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e5b7760e47f22fd546b6eabfcae3b62"><td class="memItemLeft" align="right" valign="top">pvrvk::Extent3D&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr_1_1utils.html#a3e5b7760e47f22fd546b6eabfcae3b62">convertToPVRVk</a> (const Extent3D &amp;extent)</td></tr>
<tr class="memdesc:a3e5b7760e47f22fd546b6eabfcae3b62"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert to pvrvk Extent3D <a href="#a3e5b7760e47f22fd546b6eabfcae3b62">More...</a><br/></td></tr>
<tr class="separator:a3e5b7760e47f22fd546b6eabfcae3b62"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1015e60258a9b1ea86213471275c8955"><td class="memItemLeft" align="right" valign="top">pvrvk::Extent2D&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr_1_1utils.html#a1015e60258a9b1ea86213471275c8955">convertToPVRVk</a> (const Extent2D &amp;extent)</td></tr>
<tr class="memdesc:a1015e60258a9b1ea86213471275c8955"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert to pvrvk Extent2D <a href="#a1015e60258a9b1ea86213471275c8955">More...</a><br/></td></tr>
<tr class="separator:a1015e60258a9b1ea86213471275c8955"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ae6b94f99d8533786ba3eb16f4e694a"><td class="memItemLeft" align="right" valign="top">pvrvk::Offset3D&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr_1_1utils.html#a7ae6b94f99d8533786ba3eb16f4e694a">convertToPVRVk</a> (const Offset3D &amp;offset)</td></tr>
<tr class="memdesc:a7ae6b94f99d8533786ba3eb16f4e694a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert to pvrvk Offset3D <a href="#a7ae6b94f99d8533786ba3eb16f4e694a">More...</a><br/></td></tr>
<tr class="separator:a7ae6b94f99d8533786ba3eb16f4e694a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a251d0fffcee64a05e2619a02b52b109e"><td class="memItemLeft" align="right" valign="top">pvrvk::Offset2D&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr_1_1utils.html#a251d0fffcee64a05e2619a02b52b109e">convertToPVRVk</a> (const Offset2D &amp;offset)</td></tr>
<tr class="memdesc:a251d0fffcee64a05e2619a02b52b109e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert to pvrvk Offset2D <a href="#a251d0fffcee64a05e2619a02b52b109e">More...</a><br/></td></tr>
<tr class="separator:a251d0fffcee64a05e2619a02b52b109e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a745663053f1f1c98e457ce71a8b0048a"><td class="memItemLeft" align="right" valign="top">pvrvk::SamplerMipmapMode&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr_1_1utils.html#a745663053f1f1c98e457ce71a8b0048a">convertToPVRVkMipmapMode</a> (Filter filter)</td></tr>
<tr class="memdesc:a745663053f1f1c98e457ce71a8b0048a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert to pvrvk sampler mip-map mode <a href="#a745663053f1f1c98e457ce71a8b0048a">More...</a><br/></td></tr>
<tr class="separator:a745663053f1f1c98e457ce71a8b0048a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb6a1fc2c108c439d57cb44f189099aa"><td class="memItemLeft" align="right" valign="top">pvrvk::SampleCountFlags&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr_1_1utils.html#acb6a1fc2c108c439d57cb44f189099aa">convertToPVRVkNumSamples</a> (uint8_t numSamples)</td></tr>
<tr class="memdesc:acb6a1fc2c108c439d57cb44f189099aa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert to pvrvk sample count <a href="#acb6a1fc2c108c439d57cb44f189099aa">More...</a><br/></td></tr>
<tr class="separator:acb6a1fc2c108c439d57cb44f189099aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d459b2f7cdcedd6fc8ae939064dae1d"><td class="memItemLeft" align="right" valign="top">pvrvk::Format&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr_1_1utils.html#a7d459b2f7cdcedd6fc8ae939064dae1d">convertToPVRVkPixelFormat</a> (PixelFormat format, ColorSpace colorSpace, VariableType dataType)</td></tr>
<tr class="memdesc:a7d459b2f7cdcedd6fc8ae939064dae1d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert to pvrvk pixel format <a href="#a7d459b2f7cdcedd6fc8ae939064dae1d">More...</a><br/></td></tr>
<tr class="separator:a7d459b2f7cdcedd6fc8ae939064dae1d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5985423e5f61cf77204a1157fa4783f1"><td class="memItemLeft" align="right" valign="top">pvrvk::Format&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr_1_1utils.html#a5985423e5f61cf77204a1157fa4783f1">convertToPVRVkPixelFormat</a> (PixelFormat format, ColorSpace colorSpace, VariableType dataType, bool &amp;outIsCompressedFormat)</td></tr>
<tr class="memdesc:a5985423e5f61cf77204a1157fa4783f1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert to pvrvk pixel format <a href="#a5985423e5f61cf77204a1157fa4783f1">More...</a><br/></td></tr>
<tr class="separator:a5985423e5f61cf77204a1157fa4783f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a116badc6ed0a108f3cc8ea515283a458"><td class="memItemLeft" align="right" valign="top">pvrvk::Format&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr_1_1utils.html#a116badc6ed0a108f3cc8ea515283a458">convertToPVRVkVertexInputFormat</a> (DataType dataType, uint8_t width)</td></tr>
<tr class="memdesc:a116badc6ed0a108f3cc8ea515283a458"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert to pvrvk format <a href="#a116badc6ed0a108f3cc8ea515283a458">More...</a><br/></td></tr>
<tr class="separator:a116badc6ed0a108f3cc8ea515283a458"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad0c9ce4267ec635305fc87aba0b9d9c2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr_1_1utils.html#ad0c9ce4267ec635305fc87aba0b9d9c2">create3dPlaneMesh</a> (uint32_t width, uint32_t depth, bool generateTexCoords, bool generateNormalCoords, assets::Mesh &amp;outMesh)</td></tr>
<tr class="memdesc:ad0c9ce4267ec635305fc87aba0b9d9c2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a 3d plane mesh based on the width and depth specified. Texture coordinates and normal coordinates can also optionally be generated based on the generateTexCoords and generateNormalCoords flags respectively. The generated mesh will be returned as a pvr::assets::Mesh. <a href="#ad0c9ce4267ec635305fc87aba0b9d9c2">More...</a><br/></td></tr>
<tr class="separator:ad0c9ce4267ec635305fc87aba0b9d9c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acecac80786da19a6303dbf72345c16a9"><td class="memItemLeft" align="right" valign="top">pvrvk::Buffer&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr_1_1utils.html#acecac80786da19a6303dbf72345c16a9">createBuffer</a> (pvrvk::Device device, VkDeviceSize size, pvrvk::BufferUsageFlags bufferUsage, pvrvk::MemoryPropertyFlags requiredMemoryFlags, pvrvk::MemoryPropertyFlags optimalMemoryFlags=pvrvk::MemoryPropertyFlags::e_NONE, vma::Allocator *bufferAllocator=nullptr, vma::AllocationCreateFlags vmaAllocationCreateFlags=vma::AllocationCreateFlags::e_MAPPED_BIT, pvrvk::BufferCreateFlags bufferCreateFlags=pvrvk::BufferCreateFlags(0), pvrvk::SharingMode sharingMode=pvrvk::SharingMode::e_EXCLUSIVE, const uint32_t *queueFamilyIndices=nullptr, uint32_t numQueueFamilyIndices=0)</td></tr>
<tr class="memdesc:acecac80786da19a6303dbf72345c16a9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new buffer object and (optionally) allocate and bind memory for it <a href="#acecac80786da19a6303dbf72345c16a9">More...</a><br/></td></tr>
<tr class="separator:acecac80786da19a6303dbf72345c16a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7af92cf8d09982258386f5cc4e6f2f80"><td class="memItemLeft" align="right" valign="top">GLuint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr_1_1utils.html#a7af92cf8d09982258386f5cc4e6f2f80">createComputeShaderProgram</a> (IAssetProvider &amp;app, const char *compShaderFilename, const char *const *defines=0, uint32_t numDefines=0)</td></tr>
<tr class="memdesc:a7af92cf8d09982258386f5cc4e6f2f80"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a native shader program from a compute shader <a href="#a7af92cf8d09982258386f5cc4e6f2f80">More...</a><br/></td></tr>
<tr class="separator:a7af92cf8d09982258386f5cc4e6f2f80"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c7a82ad08f5f77c574a75fc1c4eca9a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structpvr_1_1utils_1_1_debug_utils_callbacks.html">DebugUtilsCallbacks</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr_1_1utils.html#a3c7a82ad08f5f77c574a75fc1c4eca9a">createDebugUtilsCallbacks</a> (pvrvk::Instance &amp;instance)</td></tr>
<tr class="memdesc:a3c7a82ad08f5f77c574a75fc1c4eca9a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a default set of debug utils messengers or debug callbacks using either VK_EXT_debug_utils or VK_EXT_debug_report respectively. The first callback will trigger an exception to be thrown when an error message is returned. The second callback will Log a message for errors and warnings. <a href="#a3c7a82ad08f5f77c574a75fc1c4eca9a">More...</a><br/></td></tr>
<tr class="separator:a3c7a82ad08f5f77c574a75fc1c4eca9a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a34226196d1cd435e8f19abecc2d3b0eb"><td class="memItemLeft" align="right" valign="top">pvrvk::Device&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr_1_1utils.html#a34226196d1cd435e8f19abecc2d3b0eb">createDeviceAndQueues</a> (pvrvk::PhysicalDevice physicalDevice, const <a class="el" href="structpvr_1_1utils_1_1_queue_populate_info.html">QueuePopulateInfo</a> *queueCreateInfos, uint32_t numQueueCreateInfos, <a class="el" href="structpvr_1_1utils_1_1_queue_access_info.html">QueueAccessInfo</a> *outAccessInfo, const <a class="el" href="structpvr_1_1utils_1_1_device_extensions.html">DeviceExtensions</a> &amp;deviceExtensions=<a class="el" href="structpvr_1_1utils_1_1_device_extensions.html">DeviceExtensions</a>())</td></tr>
<tr class="memdesc:a34226196d1cd435e8f19abecc2d3b0eb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create the pvrvk::Device and the queues <a href="#a34226196d1cd435e8f19abecc2d3b0eb">More...</a><br/></td></tr>
<tr class="separator:a34226196d1cd435e8f19abecc2d3b0eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ea80135aa97006c881f5d3fface1563"><td class="memItemLeft" align="right" valign="top">pvrvk::Image&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr_1_1utils.html#a2ea80135aa97006c881f5d3fface1563">createImage</a> (pvrvk::Device device, pvrvk::ImageType imageType, pvrvk::Format format, const pvrvk::Extent3D &amp;dimension, pvrvk::ImageUsageFlags usage, pvrvk::ImageCreateFlags flags=pvrvk::ImageCreateFlags(0), const pvrvk::ImageLayersSize &amp;layerSize=pvrvk::ImageLayersSize(), pvrvk::SampleCountFlags samples=pvrvk::SampleCountFlags::e_1_BIT, pvrvk::MemoryPropertyFlags requiredMemoryFlags=pvrvk::MemoryPropertyFlags::e_DEVICE_LOCAL_BIT, pvrvk::MemoryPropertyFlags optimalMemoryFlags=pvrvk::MemoryPropertyFlags::e_NONE, vma::Allocator *imageAllocator=nullptr, vma::AllocationCreateFlags vmaAllocationCreateFlags=vma::AllocationCreateFlags::e_NONE, pvrvk::SharingMode sharingMode=pvrvk::SharingMode::e_EXCLUSIVE, pvrvk::ImageTiling tiling=pvrvk::ImageTiling::e_OPTIMAL, pvrvk::ImageLayout initialLayout=pvrvk::ImageLayout::e_UNDEFINED, const uint32_t *queueFamilyIndices=nullptr, uint32_t numQueueFamilyIndices=0)</td></tr>
<tr class="memdesc:a2ea80135aa97006c881f5d3fface1563"><td class="mdescLeft">&#160;</td><td class="mdescRight">create a new Image(sparse or with memory backing, depending on <em>flags</em> . The user should not call bindMemory on the image if sparse flags are used. <em>requiredMemoryFlags</em>  is ignored if <em>flags</em>  contains sparse binding flags. <a href="#a2ea80135aa97006c881f5d3fface1563">More...</a><br/></td></tr>
<tr class="separator:a2ea80135aa97006c881f5d3fface1563"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a680ef5943947e565f7d14aa9ff0393d9"><td class="memItemLeft" align="right" valign="top">pvrvk::Instance&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr_1_1utils.html#a680ef5943947e565f7d14aa9ff0393d9">createInstance</a> (const std::string &amp;applicationName, <a class="el" href="structpvr_1_1utils_1_1_vulkan_version.html">VulkanVersion</a> apiVersion=<a class="el" href="structpvr_1_1utils_1_1_vulkan_version.html">VulkanVersion</a>(), const <a class="el" href="structpvr_1_1utils_1_1_instance_extensions.html">InstanceExtensions</a> &amp;instanceExtensions=<a class="el" href="structpvr_1_1utils_1_1_instance_extensions.html">InstanceExtensions</a>(), const <a class="el" href="structpvr_1_1utils_1_1_instance_layers.html">InstanceLayers</a> &amp;instanceLayers=<a class="el" href="structpvr_1_1utils_1_1_instance_layers.html">InstanceLayers</a>())</td></tr>
<tr class="memdesc:a680ef5943947e565f7d14aa9ff0393d9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Utility function for creating a Vulkan instance and supported physical devices using the appropriately set parameters. <a href="#a680ef5943947e565f7d14aa9ff0393d9">More...</a><br/></td></tr>
<tr class="separator:a680ef5943947e565f7d14aa9ff0393d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a95e0a5be7c444548e52a74c2f40faaa5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr_1_1utils.html#a95e0a5be7c444548e52a74c2f40faaa5">createMultipleBuffersFromMesh</a> (pvrvk::Device &amp;device, const assets::Mesh &amp;mesh, std::vector&lt; pvrvk::Buffer &gt; &amp;outVbos, pvrvk::Buffer &amp;outIbo, pvrvk::CommandBuffer &amp;uploadCmdBuffer, bool &amp;requiresCommandBufferSubmission, vma::Allocator *bufferAllocator, vma::AllocationCreateFlags vmaAllocationCreateFlags=vma::AllocationCreateFlags::e_MAPPED_BIT)</td></tr>
<tr class="memdesc:a95e0a5be7c444548e52a74c2f40faaa5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Auto generates a set of VBOs and a single IBO from all the vertex data of a mesh. <a href="#a95e0a5be7c444548e52a74c2f40faaa5">More...</a><br/></td></tr>
<tr class="separator:a95e0a5be7c444548e52a74c2f40faaa5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af3c27cb705f0f371580caad44b5763be"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr_1_1utils.html#af3c27cb705f0f371580caad44b5763be">createOnscreenFramebufferAndRenderPass</a> (pvrvk::Swapchain &amp;swapchain, pvrvk::ImageView *depthStencilImages, <a class="el" href="classpvr_1_1_multi.html">Multi</a>&lt; pvrvk::Framebuffer &gt; &amp;outFramebuffers, pvrvk::RenderPass &amp;outRenderPass, pvrvk::ImageLayout initialSwapchainLayout=pvrvk::ImageLayout::e_UNDEFINED, pvrvk::ImageLayout initialDepthStencilLayout=pvrvk::ImageLayout::e_UNDEFINED, pvrvk::AttachmentLoadOp colorLoadOp=pvrvk::AttachmentLoadOp::e_CLEAR, pvrvk::AttachmentStoreOp colorStoreOp=pvrvk::AttachmentStoreOp::e_STORE, pvrvk::AttachmentLoadOp depthStencilLoadOp=pvrvk::AttachmentLoadOp::e_CLEAR, pvrvk::AttachmentStoreOp depthStencilStoreOp=pvrvk::AttachmentStoreOp::e_DONT_CARE)</td></tr>
<tr class="memdesc:af3c27cb705f0f371580caad44b5763be"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a pvrvk::Framebuffer and RenderPass to use for 'default' rendering to the 'onscreen' color images with following config RenderPass: Attachment0: ColorAttachment swapchain image, finalLayout - PresentSrcKHR LoadOp - Clear StoreOp - Store Attachment1: DepthStencilAttachment finalLayout - DepthStencilAttachmentOptimal LoadOp - Clear StoreOp - Store <a href="#af3c27cb705f0f371580caad44b5763be">More...</a><br/></td></tr>
<tr class="separator:af3c27cb705f0f371580caad44b5763be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a800aecef7aa17bc651e2ee97b8e2c6d9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr_1_1utils.html#a800aecef7aa17bc651e2ee97b8e2c6d9">createOnscreenFramebufferAndRenderPass</a> (pvrvk::Swapchain &amp;swapchain, pvrvk::ImageView *depthStencilImages, <a class="el" href="classpvr_1_1_multi.html">Multi</a>&lt; pvrvk::Framebuffer &gt; &amp;outFramebuffers, pvrvk::ImageLayout initialSwapchainLayout=pvrvk::ImageLayout::e_UNDEFINED, pvrvk::ImageLayout initialDepthStencilLayout=pvrvk::ImageLayout::e_UNDEFINED, pvrvk::AttachmentLoadOp colorLoadOp=pvrvk::AttachmentLoadOp::e_CLEAR, pvrvk::AttachmentStoreOp colorStoreOp=pvrvk::AttachmentStoreOp::e_STORE, pvrvk::AttachmentLoadOp depthStencilLoadOp=pvrvk::AttachmentLoadOp::e_CLEAR, pvrvk::AttachmentStoreOp depthStencilStoreOp=pvrvk::AttachmentStoreOp::e_DONT_CARE)</td></tr>
<tr class="memdesc:a800aecef7aa17bc651e2ee97b8e2c6d9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a pvrvk::Framebuffer and RenderPass to use for 'default' rendering to the 'onscreen' color images with following config RenderPass: ColorAttachment0: swapchain image, finalLayout - PresentSrcKHR LoadOp - Clear StoreOp - Store DepthStencilAttachment: finalLayout - DepthStencilAttachmentOptimal LoadOp - Clear StoreOp - Store Subpass0 <a href="#a800aecef7aa17bc651e2ee97b8e2c6d9">More...</a><br/></td></tr>
<tr class="separator:a800aecef7aa17bc651e2ee97b8e2c6d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a55c8c338b47c9a66f58a39feb29c9fbe"><td class="memItemLeft" align="right" valign="top">pvrvk::ShaderModule&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr_1_1utils.html#a55c8c338b47c9a66f58a39feb29c9fbe">createShaderModule</a> (pvrvk::Device &amp;device, std::string &amp;shaderSource, pvrvk::ShaderStageFlags shaderStageFlags, pvrvk::ShaderModuleCreateFlags flags=pvrvk::ShaderModuleCreateFlags::e_NONE, const char *const *defines=nullptr, uint32_t numDefines=0)</td></tr>
<tr class="memdesc:a55c8c338b47c9a66f58a39feb29c9fbe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Load a ShaderModule from shader source using glslang. <a href="#a55c8c338b47c9a66f58a39feb29c9fbe">More...</a><br/></td></tr>
<tr class="separator:a55c8c338b47c9a66f58a39feb29c9fbe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a270a77975b4db20cad82e6974a065a6d"><td class="memItemLeft" align="right" valign="top">pvrvk::ShaderModule&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr_1_1utils.html#a270a77975b4db20cad82e6974a065a6d">createShaderModule</a> (pvrvk::Device &amp;device, const Stream &amp;shaderSource, pvrvk::ShaderStageFlags shaderStageFlags, pvrvk::ShaderModuleCreateFlags flags=pvrvk::ShaderModuleCreateFlags::e_NONE, const char *const *defines=nullptr, uint32_t numDefines=0)</td></tr>
<tr class="memdesc:a270a77975b4db20cad82e6974a065a6d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Load a ShaderModule from shader source using glslang. <a href="#a270a77975b4db20cad82e6974a065a6d">More...</a><br/></td></tr>
<tr class="separator:a270a77975b4db20cad82e6974a065a6d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af094283fa2ed1a4434130f9eaf16feb6"><td class="memItemLeft" align="right" valign="top">GLuint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr_1_1utils.html#af094283fa2ed1a4434130f9eaf16feb6">createShaderProgram</a> (const GLuint pShaders[], uint32_t shadersCount, const char **const attribNames, const uint16_t *attribIndices, uint32_t attribsCount, std::string *infolog=NULL)</td></tr>
<tr class="memdesc:af094283fa2ed1a4434130f9eaf16feb6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a native shader program from an array of native shader handles. Will implicitly load on the current context. <a href="#af094283fa2ed1a4434130f9eaf16feb6">More...</a><br/></td></tr>
<tr class="separator:af094283fa2ed1a4434130f9eaf16feb6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a42a0675b91a9e04cfcf514db85a8af81"><td class="memItemLeft" align="right" valign="top">GLuint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr_1_1utils.html#a42a0675b91a9e04cfcf514db85a8af81">createShaderProgram</a> (IAssetProvider &amp;app, const char *vertShaderFilename, const char *tessCtrlShaderFilename, const char *tessEvalShaderFilename, const char *geometryShaderFilename, const char *fragShaderFilename, const char **attribNames, const uint16_t *attribIndices, uint32_t numAttribs, const char *const *defines=0, uint32_t numDefines=0)</td></tr>
<tr class="memdesc:a42a0675b91a9e04cfcf514db85a8af81"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a native shader program from a vertex, fragment, tessellation control, tessellation evaluation and geometry shader <a href="#a42a0675b91a9e04cfcf514db85a8af81">More...</a><br/></td></tr>
<tr class="separator:a42a0675b91a9e04cfcf514db85a8af81"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad8ae577267c30e8c9ac6de425a7201cd"><td class="memItemLeft" align="right" valign="top">GLuint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr_1_1utils.html#ad8ae577267c30e8c9ac6de425a7201cd">createShaderProgram</a> (IAssetProvider &amp;app, const char *vertShaderFilename, const char *fragShaderFilename, const char **attribNames, const uint16_t *attribIndices, uint32_t numAttribs, const char *const *defines=0, uint32_t numDefines=0)</td></tr>
<tr class="memdesc:ad8ae577267c30e8c9ac6de425a7201cd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a native shader program from a vertex and fragment shader <a href="#ad8ae577267c30e8c9ac6de425a7201cd">More...</a><br/></td></tr>
<tr class="separator:ad8ae577267c30e8c9ac6de425a7201cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae6934715b675cba2e0a7454813b431a3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr_1_1utils.html#ae6934715b675cba2e0a7454813b431a3">createSingleBuffersFromMesh</a> (pvrvk::Device &amp;device, const assets::Mesh &amp;mesh, pvrvk::Buffer &amp;outVbo, pvrvk::Buffer &amp;outIbo, pvrvk::CommandBuffer &amp;uploadCmdBuffer, bool &amp;requiresCommandBufferSubmission, vma::Allocator *bufferAllocator=nullptr, vma::AllocationCreateFlags vmaAllocationCreateFlags=vma::AllocationCreateFlags::e_MAPPED_BIT)</td></tr>
<tr class="memdesc:ae6934715b675cba2e0a7454813b431a3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Auto generates a single VBO and a single IBO from all the vertex data of a mesh. <a href="#ae6934715b675cba2e0a7454813b431a3">More...</a><br/></td></tr>
<tr class="separator:ae6934715b675cba2e0a7454813b431a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a06f94be9a865755c8bafaac56f286b01"><td class="memTemplParams" colspan="2">template&lt;typename MeshIterator_ , typename VboInsertIterator_ , typename IboInsertIterator_ &gt; </td></tr>
<tr class="memitem:a06f94be9a865755c8bafaac56f286b01"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacepvr_1_1utils.html#a06f94be9a865755c8bafaac56f286b01">createSingleBuffersFromMeshes</a> (pvrvk::Device &amp;device, MeshIterator_ meshIter, MeshIterator_ meshIterEnd, VboInsertIterator_ outVbos, IboInsertIterator_ outIbos, pvrvk::CommandBuffer &amp;uploadCmdBuffer, bool &amp;requiresCommandBufferSubmission, vma::Allocator *bufferAllocator=nullptr, vma::AllocationCreateFlags vmaAllocationCreateFlags=vma::AllocationCreateFlags::e_MAPPED_BIT)</td></tr>
<tr class="memdesc:a06f94be9a865755c8bafaac56f286b01"><td class="mdescLeft">&#160;</td><td class="mdescRight">Auto generates a set of VBOs and a set of IBOs from the vertex data of multiple meshes and uses std::inserter provided by the user to insert them to any container. <a href="#a06f94be9a865755c8bafaac56f286b01">More...</a><br/></td></tr>
<tr class="separator:a06f94be9a865755c8bafaac56f286b01"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4493b0c69e45e8b7af4d2fa32f763f23"><td class="memTemplParams" colspan="2">template&lt;typename MeshIterator_ , typename VboContainer_ , typename IboContainer_ &gt; </td></tr>
<tr class="memitem:a4493b0c69e45e8b7af4d2fa32f763f23"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacepvr_1_1utils.html#a4493b0c69e45e8b7af4d2fa32f763f23">createSingleBuffersFromMeshes</a> (pvrvk::Device &amp;device, MeshIterator_ meshIter, MeshIterator_ meshIterEnd, VboContainer_ &amp;outVbos, typename VboContainer_::iterator vbos_where, IboContainer_ &amp;outIbos, typename IboContainer_::iterator ibos_where, pvrvk::CommandBuffer &amp;uploadCmdBuffer, bool &amp;requiresCommandBufferSubmission, vma::Allocator *bufferAllocator=nullptr, vma::AllocationCreateFlags vmaAllocationCreateFlags=vma::AllocationCreateFlags::e_MAPPED_BIT)</td></tr>
<tr class="memdesc:a4493b0c69e45e8b7af4d2fa32f763f23"><td class="mdescLeft">&#160;</td><td class="mdescRight">Auto generates a set of VBOs and a set of IBOs from the vertex data of multiple meshes and insert them at the specified spot in a user-provided container. <a href="#a4493b0c69e45e8b7af4d2fa32f763f23">More...</a><br/></td></tr>
<tr class="separator:a4493b0c69e45e8b7af4d2fa32f763f23"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b77d306417876f431ed11fffde3a84f"><td class="memTemplParams" colspan="2">template&lt;typename VboInsertIterator_ , typename IboInsertIterator_ &gt; </td></tr>
<tr class="memitem:a8b77d306417876f431ed11fffde3a84f"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacepvr_1_1utils.html#a8b77d306417876f431ed11fffde3a84f">createSingleBuffersFromModel</a> (pvrvk::Device &amp;device, const assets::Model &amp;model, VboInsertIterator_ vbos, IboInsertIterator_ ibos, pvrvk::CommandBuffer &amp;uploadCmdBuffer, bool &amp;requiresCommandBufferSubmission, vma::Allocator *bufferAllocator=nullptr, vma::AllocationCreateFlags vmaAllocationCreateFlags=vma::AllocationCreateFlags::e_MAPPED_BIT)</td></tr>
<tr class="memdesc:a8b77d306417876f431ed11fffde3a84f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Auto generates a set of VBOs and a set of IBOs from the vertex data of the meshes of a model and inserts them into containers provided by the user using std::inserters. <a href="#a8b77d306417876f431ed11fffde3a84f">More...</a><br/></td></tr>
<tr class="separator:a8b77d306417876f431ed11fffde3a84f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa583027696be258fc78dd3156ffaece5"><td class="memItemLeft" align="right" valign="top">pvrvk::Surface&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr_1_1utils.html#aa583027696be258fc78dd3156ffaece5">createSurface</a> (pvrvk::Instance &amp;instance, pvrvk::PhysicalDevice &amp;physicalDevice, void *window, void *display)</td></tr>
<tr class="memdesc:aa583027696be258fc78dd3156ffaece5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an abstract vulkan native platform surface. <a href="#aa583027696be258fc78dd3156ffaece5">More...</a><br/></td></tr>
<tr class="separator:aa583027696be258fc78dd3156ffaece5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d992b548d4b9d5617bc2766f1dbdda9"><td class="memItemLeft" align="right" valign="top">pvrvk::Swapchain&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr_1_1utils.html#a3d992b548d4b9d5617bc2766f1dbdda9">createSwapchain</a> (pvrvk::Device &amp;device, const pvrvk::Surface &amp;surface, pvr::DisplayAttributes &amp;displayAttributes, const std::vector&lt; pvrvk::Format &gt; &amp;preferredColorFormats=std::vector&lt; pvrvk::Format &gt;(), pvrvk::ImageUsageFlags swapchainImageUsageFlags=pvrvk::ImageUsageFlags::e_COLOR_ATTACHMENT_BIT)</td></tr>
<tr class="memdesc:a3d992b548d4b9d5617bc2766f1dbdda9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a pvrvk::Swapchain using a pre-initialised pvrvk::Device and pvrvk::Surface choosing the color format of the swapchain images created from the specified list of preferred color formats. <a href="#a3d992b548d4b9d5617bc2766f1dbdda9">More...</a><br/></td></tr>
<tr class="separator:a3d992b548d4b9d5617bc2766f1dbdda9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb02e95824004b5bf3b80049ec0a3e40"><td class="memItemLeft" align="right" valign="top">pvrvk::Swapchain&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr_1_1utils.html#acb02e95824004b5bf3b80049ec0a3e40">createSwapchain</a> (pvrvk::Device &amp;device, const pvrvk::Surface &amp;surface, pvr::DisplayAttributes &amp;displayAttributes, pvrvk::ImageUsageFlags swapchainImageUsageFlags=pvrvk::ImageUsageFlags::e_COLOR_ATTACHMENT_BIT)</td></tr>
<tr class="memdesc:acb02e95824004b5bf3b80049ec0a3e40"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a pvrvk::Swapchain using a pre-initialised pvrvk::Device and pvrvk::Surface. <a href="#acb02e95824004b5bf3b80049ec0a3e40">More...</a><br/></td></tr>
<tr class="separator:acb02e95824004b5bf3b80049ec0a3e40"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a391224081fe950b01072c76a7a33fbac"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr_1_1utils.html#a391224081fe950b01072c76a7a33fbac">createSwapchainAndDepthStencilImageAndViews</a> (pvrvk::Device &amp;device, const pvrvk::Surface &amp;surface, pvr::DisplayAttributes &amp;displayAttributes, pvrvk::Swapchain &amp;outSwapchain, <a class="el" href="classpvr_1_1_multi.html">Multi</a>&lt; pvrvk::ImageView &gt; &amp;outDepthStencilImages, const std::vector&lt; pvrvk::Format &gt; &amp;preferredColorFormats=std::vector&lt; pvrvk::Format &gt;(), const std::vector&lt; pvrvk::Format &gt; &amp;preferredDepthStencilFormats=std::vector&lt; pvrvk::Format &gt;(), const pvrvk::ImageUsageFlags &amp;swapchainImageUsageFlags=pvrvk::ImageUsageFlags::e_COLOR_ATTACHMENT_BIT, const pvrvk::ImageUsageFlags &amp;dsImageUsageFlags=pvrvk::ImageUsageFlags::e_DEPTH_STENCIL_ATTACHMENT_BIT|pvrvk::ImageUsageFlags::e_TRANSIENT_ATTACHMENT_BIT, vma::Allocator *dsImageAllocator=nullptr, vma::AllocationCreateFlags dsImageAllocationCreateFlags=vma::AllocationCreateFlags::e_DEDICATED_MEMORY_BIT)</td></tr>
<tr class="memdesc:a391224081fe950b01072c76a7a33fbac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a pvrvk::Swapchain and corresponding number of depth stencil images using a pre-initialised pvrvk::Device and pvrvk::Surface choosing the color and depth stencil format of the images created from the specified list of preferred color and depth stencil formats. <a href="#a391224081fe950b01072c76a7a33fbac">More...</a><br/></td></tr>
<tr class="separator:a391224081fe950b01072c76a7a33fbac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb4cbed57981943e18958f5d6708caac"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr_1_1utils.html#afb4cbed57981943e18958f5d6708caac">createSwapchainAndDepthStencilImageAndViews</a> (pvrvk::Device &amp;device, const pvrvk::Surface &amp;surface, pvr::DisplayAttributes &amp;displayAttributes, pvrvk::Swapchain &amp;outSwapchain, <a class="el" href="classpvr_1_1_multi.html">Multi</a>&lt; pvrvk::ImageView &gt; &amp;outDepthStencilImages, const pvrvk::ImageUsageFlags &amp;swapchainImageUsageFlags=pvrvk::ImageUsageFlags::e_COLOR_ATTACHMENT_BIT, const pvrvk::ImageUsageFlags &amp;dsImageUsageFlags=pvrvk::ImageUsageFlags::e_DEPTH_STENCIL_ATTACHMENT_BIT|pvrvk::ImageUsageFlags::e_TRANSIENT_ATTACHMENT_BIT, vma::Allocator *dsImageAllocator=nullptr, vma::AllocationCreateFlags dsImageAllocationCreateFlags=vma::AllocationCreateFlags::e_DEDICATED_MEMORY_BIT)</td></tr>
<tr class="memdesc:afb4cbed57981943e18958f5d6708caac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a pvrvk::Swapchain and corresponding number of depth stencil images using a pre-initialised pvrvk::Device and pvrvk::Surface. <a href="#afb4cbed57981943e18958f5d6708caac">More...</a><br/></td></tr>
<tr class="separator:afb4cbed57981943e18958f5d6708caac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a12e6adce5bcec23564fd67553c9f4088"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr_1_1utils.html#a12e6adce5bcec23564fd67553c9f4088">endCommandBufferDebugLabel</a> (pvrvk::CommandBufferBase commandBufferBase)</td></tr>
<tr class="memdesc:a12e6adce5bcec23564fd67553c9f4088"><td class="mdescLeft">&#160;</td><td class="mdescRight">Ends a label region of work submitted to this base command buffer. <a href="#a12e6adce5bcec23564fd67553c9f4088">More...</a><br/></td></tr>
<tr class="separator:a12e6adce5bcec23564fd67553c9f4088"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2da693f264b2b719a77fc84bf0a32ec5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr_1_1utils.html#a2da693f264b2b719a77fc84bf0a32ec5">endCommandBufferDebugLabel</a> (pvrvk::CommandBuffer &amp;commandBuffer)</td></tr>
<tr class="memdesc:a2da693f264b2b719a77fc84bf0a32ec5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Ends a label region of work submitted to this command buffer. <a href="#a2da693f264b2b719a77fc84bf0a32ec5">More...</a><br/></td></tr>
<tr class="separator:a2da693f264b2b719a77fc84bf0a32ec5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adee1c88c7937b7a16127e810b75b2ab7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr_1_1utils.html#adee1c88c7937b7a16127e810b75b2ab7">endCommandBufferDebugLabel</a> (pvrvk::SecondaryCommandBuffer &amp;secondaryCommandBuffer)</td></tr>
<tr class="memdesc:adee1c88c7937b7a16127e810b75b2ab7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Ends a label region of work submitted to this secondary command buffer. <a href="#adee1c88c7937b7a16127e810b75b2ab7">More...</a><br/></td></tr>
<tr class="separator:adee1c88c7937b7a16127e810b75b2ab7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a605300322093e44b7cd509533f14b4fa"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr_1_1utils.html#a605300322093e44b7cd509533f14b4fa">endQueueDebugLabel</a> (pvrvk::Queue queue)</td></tr>
<tr class="memdesc:a605300322093e44b7cd509533f14b4fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Ends a label region of work submitted to this queue. <a href="#a605300322093e44b7cd509533f14b4fa">More...</a><br/></td></tr>
<tr class="separator:a605300322093e44b7cd509533f14b4fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a12bdf9f718d984f14166f6b91b254b4c"><td class="memItemLeft" align="right" valign="top">pvr::Texture&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr_1_1utils.html#a12bdf9f718d984f14166f6b91b254b4c">generateCookTorranceBRDFLUT</a> (uint32_t mapDim=256)</td></tr>
<tr class="memdesc:a12bdf9f718d984f14166f6b91b254b4c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generates BRDF lookup table image. <a href="#a12bdf9f718d984f14166f6b91b254b4c">More...</a><br/></td></tr>
<tr class="separator:a12bdf9f718d984f14166f6b91b254b4c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af47a86d6668e712e353dd8aea5e984c2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr_1_1utils.html#af47a86d6668e712e353dd8aea5e984c2">generateIrradianceMap</a> (GLuint environmentMap, pvr::Texture &amp;outTexture, GLuint &amp;outTextureGles, uint32_t mapSize=64, uint32_t mapNumSamples=128)</td></tr>
<tr class="memdesc:af47a86d6668e712e353dd8aea5e984c2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generates a mipmapped diffuse irradiance map. <a href="#af47a86d6668e712e353dd8aea5e984c2">More...</a><br/></td></tr>
<tr class="separator:af47a86d6668e712e353dd8aea5e984c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab24c4e93b0c93756506ebd6f2ca1b399"><td class="memItemLeft" align="right" valign="top">Texture&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr_1_1utils.html#ab24c4e93b0c93756506ebd6f2ca1b399">generateIrradianceMap</a> (pvrvk::Queue queue, pvrvk::ImageView environmentMap, pvr::PixelFormat outputPixelFormat, pvr::VariableType outputVariableType, uint32_t mapSize=64, uint32_t mapNumSamples=16384)</td></tr>
<tr class="memdesc:ab24c4e93b0c93756506ebd6f2ca1b399"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generates a mipmapped diffuse irradiance map. <a href="#ab24c4e93b0c93756506ebd6f2ca1b399">More...</a><br/></td></tr>
<tr class="separator:ab24c4e93b0c93756506ebd6f2ca1b399"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b892efb9cd1baa5753d0d180a2d3d94"><td class="memItemLeft" align="right" valign="top">Texture&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr_1_1utils.html#a8b892efb9cd1baa5753d0d180a2d3d94">generatePreFilteredMapMipmapStyle</a> (pvrvk::Queue queue, pvrvk::ImageView environmentMap, pvr::PixelFormat outputPixelFormat, pvr::VariableType outputVariableType, uint32_t mapSize, bool zeroRoughnessIsExternal, int numMipLevelsToDiscard, uint32_t mapNumSamples=65536)</td></tr>
<tr class="memdesc:a8b892efb9cd1baa5753d0d180a2d3d94"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate specular irradiance map. Each level of the specular mip map gets blurred corresponding to a roughness value from 0 to 1.0. <a href="#a8b892efb9cd1baa5753d0d180a2d3d94">More...</a><br/></td></tr>
<tr class="separator:a8b892efb9cd1baa5753d0d180a2d3d94"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc8a7f6f6edde3ee63bffd29af44b0e8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr_1_1utils.html#afc8a7f6f6edde3ee63bffd29af44b0e8">generatePreFilteredMapMipMapStyle</a> (GLuint environmentMap, pvr::Texture &amp;outTexture, GLuint &amp;outTextureGles, uint32_t mapSize, bool zeroRoughnessIsExternal, int numMipLevelsToDiscard, uint32_t mapNumSamples=65536)</td></tr>
<tr class="memdesc:afc8a7f6f6edde3ee63bffd29af44b0e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate specular irradiance map. Each level of the specular mip map gets blurred corresponding to a roughness value from 0 to 1.0. <a href="#afc8a7f6f6edde3ee63bffd29af44b0e8">More...</a><br/></td></tr>
<tr class="separator:afc8a7f6f6edde3ee63bffd29af44b0e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d3d1522b9db9f69b91090f918ccc8c0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr_1_1utils.html#a5d3d1522b9db9f69b91090f918ccc8c0">generateTextureAtlas</a> (pvrvk::Device &amp;device, const pvrvk::Image *inputImages, pvrvk::Rect2Df *outUVs, uint32_t numImages, pvrvk::ImageLayout inputImageLayout, pvrvk::ImageView *outImageView, TextureHeader *outDescriptor, pvrvk::CommandBufferBase cmdBuffer, pvrvk::ImageLayout finalLayout=pvrvk::ImageLayout::e_SHADER_READ_ONLY_OPTIMAL, vma::Allocator *imageAllocator=nullptr, vma::AllocationCreateFlags imageAllocationCreateFlags=vma::AllocationCreateFlags::e_NONE)</td></tr>
<tr class="memdesc:a5d3d1522b9db9f69b91090f918ccc8c0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Utility function for generating a texture atlas based on a set of images. <a href="#a5d3d1522b9db9f69b91090f918ccc8c0">More...</a><br/></td></tr>
<tr class="separator:a5d3d1522b9db9f69b91090f918ccc8c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a56ce1f5bcf625224715988176c3519a2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr_1_1utils.html#a56ce1f5bcf625224715988176c3519a2">getColorBits</a> (pvrvk::Format format, uint32_t &amp;redBits, uint32_t &amp;greenBits, uint32_t &amp;blueBits, uint32_t &amp;alphaBits)</td></tr>
<tr class="memdesc:a56ce1f5bcf625224715988176c3519a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines the number of color bits per pixel for the given pvrvk::Format. <a href="#a56ce1f5bcf625224715988176c3519a2">More...</a><br/></td></tr>
<tr class="separator:a56ce1f5bcf625224715988176c3519a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1bcac1e9af1869244329d12c291200a5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr_1_1utils.html#a1bcac1e9af1869244329d12c291200a5">getDepthStencilBits</a> (pvrvk::Format format, uint32_t &amp;depthBits, uint32_t &amp;stencilBits)</td></tr>
<tr class="memdesc:a1bcac1e9af1869244329d12c291200a5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines the number of depth and stencil bits per pixel for the given pvrvk::Format. <a href="#a1bcac1e9af1869244329d12c291200a5">More...</a><br/></td></tr>
<tr class="separator:a1bcac1e9af1869244329d12c291200a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a811320035b806bb4e727d9ffc7f68873"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr_1_1utils.html#a811320035b806bb4e727d9ffc7f68873">getGlErrorString</a> (GLuint apiError)</td></tr>
<tr class="memdesc:a811320035b806bb4e727d9ffc7f68873"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves a string representation of an OpenGLES error code. <a href="#a811320035b806bb4e727d9ffc7f68873">More...</a><br/></td></tr>
<tr class="separator:a811320035b806bb4e727d9ffc7f68873"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6bbf98fde377992e9e7e0d23f38a9dcc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr_1_1utils.html#a6bbf98fde377992e9e7e0d23f38a9dcc">getMemoryTypeIndex</a> (const pvrvk::PhysicalDevice &amp;physicalDevice, const uint32_t allowedMemoryTypeBits, const pvrvk::MemoryPropertyFlags requiredMemoryProperties, const pvrvk::MemoryPropertyFlags optimalMemoryProperties, uint32_t &amp;outMemoryTypeIndex, pvrvk::MemoryPropertyFlags &amp;outMemoryPropertyFlags)</td></tr>
<tr class="memdesc:a6bbf98fde377992e9e7e0d23f38a9dcc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Utility function for retrieving a memory type index for a suitable memory type which supports the memory type bits specified. If the optimal set of memory properties are supported then return the corresponding memory type index otherwise check for availablility of the required set of memory properties. This allows for implementations to optionally request the use of a more optimal set of memory properties whilst still preserving the ability to retrieve the required set of memory properties as a fallback. <a href="#a6bbf98fde377992e9e7e0d23f38a9dcc">More...</a><br/></td></tr>
<tr class="separator:a6bbf98fde377992e9e7e0d23f38a9dcc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b2d4df80d31e3e63923ab1d68152ace"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr_1_1utils.html#a7b2d4df80d31e3e63923ab1d68152ace">getNumSamplesFromSampleCountFlags</a> (pvrvk::SampleCountFlags sampleCountFlags)</td></tr>
<tr class="memdesc:a7b2d4df80d31e3e63923ab1d68152ace"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert pvrvk sample count to the number of samples it is equivalent to <a href="#a7b2d4df80d31e3e63923ab1d68152ace">More...</a><br/></td></tr>
<tr class="separator:a7b2d4df80d31e3e63923ab1d68152ace"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad17214254f1b21d40271dac7b2a4b691"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr_1_1utils.html#ad17214254f1b21d40271dac7b2a4b691">getOpenGLFormat</a> (PixelFormat pixelFormat, ColorSpace colorSpace, VariableType dataType, uint32_t &amp;glInternalFormat, uint32_t &amp;glFormat, uint32_t &amp;glType, uint32_t &amp;glTypeSize, bool &amp;isCompressedFormat)</td></tr>
<tr class="memdesc:ad17214254f1b21d40271dac7b2a4b691"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves the OpenGL ES texture formats for a texture with pvr::PixelFormat pixelFormat, pvr::ColorSpace colorSpace and pvr::VariableType dataType. <a href="#ad17214254f1b21d40271dac7b2a4b691">More...</a><br/></td></tr>
<tr class="separator:ad17214254f1b21d40271dac7b2a4b691"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a291e4ede9083ee35cc595b7775a6f41c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr_1_1utils.html#a291e4ede9083ee35cc595b7775a6f41c">getOpenGLFormat</a> (ImageStorageFormat storageFormat, uint32_t &amp;glInternalFormat, uint32_t &amp;glFormat, uint32_t &amp;glType, uint32_t &amp;glTypeSize, bool &amp;isCompressedFormat)</td></tr>
<tr class="memdesc:a291e4ede9083ee35cc595b7775a6f41c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves the OpenGL ES texture formats for a texture with the provided ImageStorageFormat. <a href="#a291e4ede9083ee35cc595b7775a6f41c">More...</a><br/></td></tr>
<tr class="separator:a291e4ede9083ee35cc595b7775a6f41c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9faeae4c6a35b0080b0b6031151e53e2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr_1_1utils.html#a9faeae4c6a35b0080b0b6031151e53e2">getOpenGLStorageFormat</a> (PixelFormat pixelFormat, ColorSpace colorSpace, VariableType dataType, GLenum &amp;glInternalFormat)</td></tr>
<tr class="memdesc:a9faeae4c6a35b0080b0b6031151e53e2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves the internal OpenGL ES texture format for a texture with pvr::PixelFormat pixelFormat, pvr::ColorSpace colorSpace and pvr::VariableType dataType. <a href="#a9faeae4c6a35b0080b0b6031151e53e2">More...</a><br/></td></tr>
<tr class="separator:a9faeae4c6a35b0080b0b6031151e53e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a71a6472c33618ce49ded8e029b463429"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr_1_1utils.html#a71a6472c33618ce49ded8e029b463429">getOpenGLStorageFormat</a> (ImageStorageFormat storageFormat, GLenum &amp;glInternalFormat)</td></tr>
<tr class="memdesc:a71a6472c33618ce49ded8e029b463429"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves the internal OpenGL ES texture formats for a texture with the provided ImageStorageFormat. <a href="#a71a6472c33618ce49ded8e029b463429">More...</a><br/></td></tr>
<tr class="separator:a71a6472c33618ce49ded8e029b463429"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3555f264beaaf83ff1b84853a87a40fe"><td class="memItemLeft" align="right" valign="top">glm::mat4&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr_1_1utils.html#a3555f264beaaf83ff1b84853a87a40fe">getPerspectiveMatrix</a> (float fovy, float aspect, float near1, float far1, float rotate=.0f)</td></tr>
<tr class="memdesc:a3555f264beaaf83ff1b84853a87a40fe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create perspective matrix that trasform scenes that use Opengl Convention (+y up) to Vulkan Convention (+y down). <a href="#a3555f264beaaf83ff1b84853a87a40fe">More...</a><br/></td></tr>
<tr class="separator:a3555f264beaaf83ff1b84853a87a40fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb45f4b332ee2574510ef0155a590b8f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr_1_1utils.html#aeb45f4b332ee2574510ef0155a590b8f">imageUploadAsyncWorker</a> (<a class="el" href="namespacepvr_1_1utils.html#ab251744ba4295771d35ea8f3ee497e0f">ImageUploadFuture</a> uploadFuture)</td></tr>
<tr class="memdesc:aeb45f4b332ee2574510ef0155a590b8f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides a mechanism for kicking an asynchronous image upload worker <a href="#aeb45f4b332ee2574510ef0155a590b8f">More...</a><br/></td></tr>
<tr class="separator:aeb45f4b332ee2574510ef0155a590b8f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93735fa36d5aedc03cf746dfa208a4b5"><td class="memItemLeft" align="right" valign="top">pvrvk::ImageAspectFlags&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr_1_1utils.html#a93735fa36d5aedc03cf746dfa208a4b5">inferAspectFromFormat</a> (pvrvk::Format format)</td></tr>
<tr class="memdesc:a93735fa36d5aedc03cf746dfa208a4b5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Infers the pvrvk::ImageAspectFlags from the pvrvk::Format. <a href="#a93735fa36d5aedc03cf746dfa208a4b5">More...</a><br/></td></tr>
<tr class="separator:a93735fa36d5aedc03cf746dfa208a4b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae3adba7320aa2b924adc48cfa5e043ed"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr_1_1utils.html#ae3adba7320aa2b924adc48cfa5e043ed">insertDebugUtilsLabel</a> (pvrvk::CommandBufferBase commandBufferBase, const pvrvk::DebugUtilsLabel &amp;labelInfo)</td></tr>
<tr class="memdesc:ae3adba7320aa2b924adc48cfa5e043ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts a single debug label any time. <a href="#ae3adba7320aa2b924adc48cfa5e043ed">More...</a><br/></td></tr>
<tr class="separator:ae3adba7320aa2b924adc48cfa5e043ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab77d5528ee9f9dc1f4dda381175b89eb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr_1_1utils.html#ab77d5528ee9f9dc1f4dda381175b89eb">insertDebugUtilsLabel</a> (pvrvk::CommandBuffer &amp;commandBuffer, const pvrvk::DebugUtilsLabel &amp;labelInfo)</td></tr>
<tr class="memdesc:ab77d5528ee9f9dc1f4dda381175b89eb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts a single debug label any time. <a href="#ab77d5528ee9f9dc1f4dda381175b89eb">More...</a><br/></td></tr>
<tr class="separator:ab77d5528ee9f9dc1f4dda381175b89eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2938b3543ae68e23f0f2eb348a786ae9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr_1_1utils.html#a2938b3543ae68e23f0f2eb348a786ae9">insertDebugUtilsLabel</a> (pvrvk::SecondaryCommandBuffer &amp;secondaryCommandBuffer, const pvrvk::DebugUtilsLabel &amp;labelInfo)</td></tr>
<tr class="memdesc:a2938b3543ae68e23f0f2eb348a786ae9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts a single debug label any time. <a href="#a2938b3543ae68e23f0f2eb348a786ae9">More...</a><br/></td></tr>
<tr class="separator:a2938b3543ae68e23f0f2eb348a786ae9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7151c7b74ff657fc17ff09c0ab114a07"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr_1_1utils.html#a7151c7b74ff657fc17ff09c0ab114a07">isFormatDepthStencil</a> (pvrvk::Format format)</td></tr>
<tr class="memdesc:a7151c7b74ff657fc17ff09c0ab114a07"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if the format is a depth stencil format <a href="#a7151c7b74ff657fc17ff09c0ab114a07">More...</a><br/></td></tr>
<tr class="separator:a7151c7b74ff657fc17ff09c0ab114a07"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a59222cc49624a76fab4d4f65e3337ac3"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr_1_1utils.html#a59222cc49624a76fab4d4f65e3337ac3">isImageUsageSupportedBySurface</a> (const pvrvk::SurfaceCapabilitiesKHR &amp;surfaceCapabilities, pvrvk::ImageUsageFlags imageUsage)</td></tr>
<tr class="memdesc:a59222cc49624a76fab4d4f65e3337ac3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Utility function used to determine whether the SurfaceCapabilitiesKHR supportedUsageFlags member contains the specified image usage and therefore can be used in the intended way. <a href="#a59222cc49624a76fab4d4f65e3337ac3">More...</a><br/></td></tr>
<tr class="separator:a59222cc49624a76fab4d4f65e3337ac3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9bf319f2a39bf8149f2c8c4b36b1382a"><td class="memItemLeft" align="right" valign="top">pvrvk::Image&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr_1_1utils.html#a9bf319f2a39bf8149f2c8c4b36b1382a">loadAndUploadImage</a> (pvrvk::Device &amp;device, const char *fileName, bool allowDecompress, pvrvk::CommandBuffer &amp;commandBuffer, IAssetProvider &amp;assetProvider, pvrvk::ImageUsageFlags usageFlags=pvrvk::ImageUsageFlags::e_SAMPLED_BIT, pvrvk::ImageLayout finalLayout=pvrvk::ImageLayout::e_SHADER_READ_ONLY_OPTIMAL, Texture *outAssetTexture=nullptr, vma::Allocator *stagingBufferAllocator=nullptr, vma::Allocator *imageAllocator=nullptr, vma::AllocationCreateFlags imageAllocationCreateFlags=vma::AllocationCreateFlags::e_NONE)</td></tr>
<tr class="memdesc:a9bf319f2a39bf8149f2c8c4b36b1382a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Load and upload image to gpu. The upload command and staging buffers are recorded in the commandbuffer. <a href="#a9bf319f2a39bf8149f2c8c4b36b1382a">More...</a><br/></td></tr>
<tr class="separator:a9bf319f2a39bf8149f2c8c4b36b1382a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a88581dc8fdfc8d1f32d8a272e5c24a75"><td class="memItemLeft" align="right" valign="top">pvrvk::Image&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr_1_1utils.html#a88581dc8fdfc8d1f32d8a272e5c24a75">loadAndUploadImage</a> (pvrvk::Device &amp;device, const std::string &amp;fileName, bool allowDecompress, pvrvk::CommandBuffer &amp;commandBuffer, IAssetProvider &amp;assetProvider, pvrvk::ImageUsageFlags usageFlags=pvrvk::ImageUsageFlags::e_SAMPLED_BIT, pvrvk::ImageLayout finalLayout=pvrvk::ImageLayout::e_SHADER_READ_ONLY_OPTIMAL, Texture *outAssetTexture=nullptr, vma::Allocator *stagingBufferAllocator=nullptr, vma::Allocator *imageAllocator=nullptr, vma::AllocationCreateFlags imageAllocationCreateFlags=vma::AllocationCreateFlags::e_NONE)</td></tr>
<tr class="memdesc:a88581dc8fdfc8d1f32d8a272e5c24a75"><td class="mdescLeft">&#160;</td><td class="mdescRight">Load and upload image to gpu. The upload command and staging buffers are recorded in the commandbuffer. <a href="#a88581dc8fdfc8d1f32d8a272e5c24a75">More...</a><br/></td></tr>
<tr class="separator:a88581dc8fdfc8d1f32d8a272e5c24a75"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae13b551250f56033c7e3c17e67602ad6"><td class="memItemLeft" align="right" valign="top">pvrvk::Image&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr_1_1utils.html#ae13b551250f56033c7e3c17e67602ad6">loadAndUploadImage</a> (pvrvk::Device &amp;device, const char *fileName, bool allowDecompress, pvrvk::SecondaryCommandBuffer &amp;commandBuffer, IAssetProvider &amp;assetProvider, pvrvk::ImageUsageFlags usageFlags=pvrvk::ImageUsageFlags::e_SAMPLED_BIT, pvrvk::ImageLayout finalLayout=pvrvk::ImageLayout::e_SHADER_READ_ONLY_OPTIMAL, Texture *outAssetTexture=nullptr, vma::Allocator *stagingBufferAllocator=nullptr, vma::Allocator *imageAllocator=nullptr, vma::AllocationCreateFlags imageAllocationCreateFlags=vma::AllocationCreateFlags::e_NONE)</td></tr>
<tr class="memdesc:ae13b551250f56033c7e3c17e67602ad6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Load and upload image to gpu. The upload command and staging buffers are recorded in the commandbuffer. <a href="#ae13b551250f56033c7e3c17e67602ad6">More...</a><br/></td></tr>
<tr class="separator:ae13b551250f56033c7e3c17e67602ad6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad7010e7802edc5e1cc101034ac386d37"><td class="memItemLeft" align="right" valign="top">pvrvk::ImageView&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr_1_1utils.html#ad7010e7802edc5e1cc101034ac386d37">loadAndUploadImageAndView</a> (pvrvk::Device &amp;device, const char *fileName, bool allowDecompress, pvrvk::CommandBuffer &amp;commandBuffer, IAssetProvider &amp;assetProvider, pvrvk::ImageUsageFlags usageFlags=pvrvk::ImageUsageFlags::e_SAMPLED_BIT, pvrvk::ImageLayout finalLayout=pvrvk::ImageLayout::e_SHADER_READ_ONLY_OPTIMAL, Texture *outAssetTexture=nullptr, vma::Allocator *stagingBufferAllocator=nullptr, vma::Allocator *imageAllocator=nullptr, vma::AllocationCreateFlags imageAllocationCreateFlags=vma::AllocationCreateFlags::e_NONE)</td></tr>
<tr class="memdesc:ad7010e7802edc5e1cc101034ac386d37"><td class="mdescLeft">&#160;</td><td class="mdescRight">Load and upload image to gpu. The upload command and staging buffers are recorded in the commandbuffer. <a href="#ad7010e7802edc5e1cc101034ac386d37">More...</a><br/></td></tr>
<tr class="separator:ad7010e7802edc5e1cc101034ac386d37"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab1fd64515fccd74310bb74070b669339"><td class="memItemLeft" align="right" valign="top">pvrvk::ImageView&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr_1_1utils.html#ab1fd64515fccd74310bb74070b669339">loadAndUploadImageAndView</a> (pvrvk::Device &amp;device, const char *fileName, bool allowDecompress, pvrvk::SecondaryCommandBuffer &amp;commandBuffer, IAssetProvider &amp;assetProvider, pvrvk::ImageUsageFlags usageFlags=pvrvk::ImageUsageFlags::e_SAMPLED_BIT, pvrvk::ImageLayout finalLayout=pvrvk::ImageLayout::e_SHADER_READ_ONLY_OPTIMAL, Texture *outAssetTexture=nullptr, vma::Allocator *stagingBufferAllocator=nullptr, vma::Allocator *imageAllocator=nullptr, vma::AllocationCreateFlags imageAllocationCreateFlags=vma::AllocationCreateFlags::e_NONE)</td></tr>
<tr class="memdesc:ab1fd64515fccd74310bb74070b669339"><td class="mdescLeft">&#160;</td><td class="mdescRight">Load and upload image to gpu. The upload command and staging buffers are recorded in the commandbuffer. <a href="#ab1fd64515fccd74310bb74070b669339">More...</a><br/></td></tr>
<tr class="separator:ab1fd64515fccd74310bb74070b669339"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab6587db0405c15cfceeb768f0a740dca"><td class="memItemLeft" align="right" valign="top">GLuint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr_1_1utils.html#ab6587db0405c15cfceeb768f0a740dca">loadShader</a> (const Stream &amp;shaderSource, ShaderType shaderType, const char *const *defines, uint32_t numDefines)</td></tr>
<tr class="memdesc:ab6587db0405c15cfceeb768f0a740dca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Load shader from shader source. Will implicitly load on the current context. <a href="#ab6587db0405c15cfceeb768f0a740dca">More...</a><br/></td></tr>
<tr class="separator:ab6587db0405c15cfceeb768f0a740dca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8cb2e88f9124d29c4a2498783cf4e1c9"><td class="memItemLeft" align="right" valign="top">GLuint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr_1_1utils.html#a8cb2e88f9124d29c4a2498783cf4e1c9">loadShader</a> (const std::string &amp;shaderSource, ShaderType shaderType, const char *const *defines, uint32_t numDefines)</td></tr>
<tr class="memdesc:a8cb2e88f9124d29c4a2498783cf4e1c9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Load shader from shader source. Will implicitly load on the current context. <a href="#a8cb2e88f9124d29c4a2498783cf4e1c9">More...</a><br/></td></tr>
<tr class="separator:a8cb2e88f9124d29c4a2498783cf4e1c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1cbbbd1665449ea70d772de63595c806"><td class="memItemLeft" align="right" valign="top">VKAPI_ATTR VkBool32 VKAPI_CALL&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr_1_1utils.html#a1cbbbd1665449ea70d772de63595c806">logMessageDebugReportCallback</a> (VkDebugReportFlagsEXT flags, VkDebugReportObjectTypeEXT objectType, uint64_t object, size_t location, int32_t messageCode, const char *pLayerPrefix, const char *pMessage, void *pUserData)</td></tr>
<tr class="memdesc:a1cbbbd1665449ea70d772de63595c806"><td class="mdescLeft">&#160;</td><td class="mdescRight">An application DebugReportCallback function providing logging for various events. <a href="#a1cbbbd1665449ea70d772de63595c806">More...</a><br/></td></tr>
<tr class="separator:a1cbbbd1665449ea70d772de63595c806"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e37e4f2f8723d81f2f60ff7c9ffebdf"><td class="memItemLeft" align="right" valign="top">VKAPI_ATTR VkBool32 VKAPI_CALL&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr_1_1utils.html#a5e37e4f2f8723d81f2f60ff7c9ffebdf">logMessageDebugUtilsMessengerCallback</a> (VkDebugUtilsMessageSeverityFlagBitsEXT messageSeverity, VkDebugUtilsMessageTypeFlagsEXT messageTypes, const VkDebugUtilsMessengerCallbackDataEXT *pCallbackData, void *pUserData)</td></tr>
<tr class="memdesc:a5e37e4f2f8723d81f2f60ff7c9ffebdf"><td class="mdescLeft">&#160;</td><td class="mdescRight">An application DebugUtilsMessengerCallback function providing logging for various events. <a href="#a5e37e4f2f8723d81f2f60ff7c9ffebdf">More...</a><br/></td></tr>
<tr class="separator:a5e37e4f2f8723d81f2f60ff7c9ffebdf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee21903727c73558ad8e3cf936917344"><td class="memItemLeft" align="right" valign="top">LogLevel&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr_1_1utils.html#aee21903727c73558ad8e3cf936917344">mapDebugReportFlagsToLogLevel</a> (pvrvk::DebugReportFlagsEXT flags)</td></tr>
<tr class="memdesc:aee21903727c73558ad8e3cf936917344"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maps a set of DebugReportFlagsEXT to a particular type of log message. <a href="#aee21903727c73558ad8e3cf936917344">More...</a><br/></td></tr>
<tr class="separator:aee21903727c73558ad8e3cf936917344"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abbd1f30f49a0d36c9d932437e902d2bb"><td class="memItemLeft" align="right" valign="top">LogLevel&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr_1_1utils.html#abbd1f30f49a0d36c9d932437e902d2bb">mapDebugUtilsMessageSeverityFlagsToLogLevel</a> (pvrvk::DebugUtilsMessageSeverityFlagsEXT flags)</td></tr>
<tr class="memdesc:abbd1f30f49a0d36c9d932437e902d2bb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maps a set of DebugUtilsMessageSeverityFlagsEXT to a particular type of log message. <a href="#abbd1f30f49a0d36c9d932437e902d2bb">More...</a><br/></td></tr>
<tr class="separator:abbd1f30f49a0d36c9d932437e902d2bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c0c12df7c704cd669d4bef29942555e"><td class="memItemLeft" align="right" valign="top">PackedSamplerFilter&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr_1_1utils.html#a9c0c12df7c704cd669d4bef29942555e">packSamplerFilter</a> (pvrvk::Filter mini, pvrvk::Filter magni, pvrvk::SamplerMipmapMode mip)</td></tr>
<tr class="memdesc:a9c0c12df7c704cd669d4bef29942555e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Created a packed sampler filter <a href="#a9c0c12df7c704cd669d4bef29942555e">More...</a><br/></td></tr>
<tr class="separator:a9c0c12df7c704cd669d4bef29942555e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a98e4ac9990af6eaf6b9bf0928f2bd07d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr_1_1utils.html#a98e4ac9990af6eaf6b9bf0928f2bd07d">populateClearValues</a> (const pvrvk::RenderPass &amp;renderpass, const pvrvk::ClearValue &amp;clearColor, const pvrvk::ClearValue &amp;clearDepthStencilValue, pvrvk::ClearValue *outClearValues)</td></tr>
<tr class="memdesc:a98e4ac9990af6eaf6b9bf0928f2bd07d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Populate color and depthstencil clear values <a href="#a98e4ac9990af6eaf6b9bf0928f2bd07d">More...</a><br/></td></tr>
<tr class="separator:a98e4ac9990af6eaf6b9bf0928f2bd07d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0c2fd1a13ff3b5e9086e13ea4608c43"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr_1_1utils.html#ae0c2fd1a13ff3b5e9086e13ea4608c43">populateInputAssemblyFromMesh</a> (const assets::Mesh &amp;mesh, const <a class="el" href="structpvr_1_1utils_1_1_vertex_bindings.html">VertexBindings</a> *bindingMap, uint16_t numBindings, pvrvk::PipelineVertexInputStateCreateInfo &amp;vertexCreateInfo, pvrvk::PipelineInputAssemblerStateCreateInfo &amp;inputAssemblerCreateInfo, uint16_t *numOutBuffers=nullptr)</td></tr>
<tr class="memdesc:ae0c2fd1a13ff3b5e9086e13ea4608c43"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fills out input assembly and vertex input state structures using a mesh and a list of corresponding <a class="el" href="structpvr_1_1utils_1_1_vertex_bindings.html" title="Represents a shader Explicit binding, tying a Semantic name to an Attribute Index.">VertexBindings</a>. <a href="#ae0c2fd1a13ff3b5e9086e13ea4608c43">More...</a><br/></td></tr>
<tr class="separator:ae0c2fd1a13ff3b5e9086e13ea4608c43"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b4a65db2498eb2d073a7af233bb1367"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr_1_1utils.html#a5b4a65db2498eb2d073a7af233bb1367">populateInputAssemblyFromMesh</a> (const assets::Mesh &amp;mesh, const <a class="el" href="structpvr_1_1utils_1_1_vertex_bindings___name.html">VertexBindings_Name</a> *bindingMap, uint16_t numBindings, pvrvk::PipelineVertexInputStateCreateInfo &amp;vertexCreateInfo, pvrvk::PipelineInputAssemblerStateCreateInfo &amp;inputAssemblerCreateInfo, uint16_t *numOutBuffers=nullptr)</td></tr>
<tr class="memdesc:a5b4a65db2498eb2d073a7af233bb1367"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fills out input assembly and vertex input state structures using a mesh and a list of corresponding <a class="el" href="structpvr_1_1utils_1_1_vertex_bindings___name.html" title="Represents a shader Reflective binding, tying a Semantic name to an Attribute variable name...">VertexBindings_Name</a>. <a href="#a5b4a65db2498eb2d073a7af233bb1367">More...</a><br/></td></tr>
<tr class="separator:a5b4a65db2498eb2d073a7af233bb1367"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e9a18d03439c5efe7d88dbb3c16b783"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr_1_1utils.html#a1e9a18d03439c5efe7d88dbb3c16b783">populateViewportStateCreateInfo</a> (const pvrvk::Framebuffer &amp;framebuffer, pvrvk::PipelineViewportStateCreateInfo &amp;outCreateInfo)</td></tr>
<tr class="memdesc:a1e9a18d03439c5efe7d88dbb3c16b783"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fills out a pvrvk::ViewportStateCreateInfo structure setting parameters for a 'default' viewport and scissor based on the specified frame buffer dimensions. <a href="#a1e9a18d03439c5efe7d88dbb3c16b783">More...</a><br/></td></tr>
<tr class="separator:a1e9a18d03439c5efe7d88dbb3c16b783"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd56ceb5a0ccd36437b833a00a1bd9c5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr_1_1utils.html#acd56ceb5a0ccd36437b833a00a1bd9c5">saveImage</a> (pvrvk::Queue &amp;queue, pvrvk::CommandPool &amp;commandPool, pvrvk::Image &amp;image, const pvrvk::ImageLayout imageInitialLayout, const pvrvk::ImageLayout imageFinalLayout, const std::string &amp;filename, vma::Allocator *bufferAllocator=nullptr, vma::Allocator *imageAllocator=nullptr, const uint32_t screenshotScale=1)</td></tr>
<tr class="memdesc:acd56ceb5a0ccd36437b833a00a1bd9c5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Saves the input image as a TGA file with the filename specified. Note that the image must have been created with the pvrvk::ImageUsageFlags::e_TRANSFER_SRC_BIT set. <a href="#acd56ceb5a0ccd36437b833a00a1bd9c5">More...</a><br/></td></tr>
<tr class="separator:acd56ceb5a0ccd36437b833a00a1bd9c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a076fe31eafd575f7f2a10f27f6130935"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr_1_1utils.html#a076fe31eafd575f7f2a10f27f6130935">setImageLayout</a> (pvrvk::Image &amp;image, pvrvk::ImageLayout oldLayout, pvrvk::ImageLayout newLayout, pvrvk::CommandBufferBase transitionCmdBuffer)</td></tr>
<tr class="memdesc:a076fe31eafd575f7f2a10f27f6130935"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set image layout <a href="#a076fe31eafd575f7f2a10f27f6130935">More...</a><br/></td></tr>
<tr class="separator:a076fe31eafd575f7f2a10f27f6130935"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a19f7af5558e7afc812edc1e8899d8f50"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr_1_1utils.html#a19f7af5558e7afc812edc1e8899d8f50">setImageLayoutAndQueueFamilyOwnership</a> (pvrvk::CommandBufferBase srccmd, pvrvk::CommandBufferBase dstcmd, uint32_t srcQueueFamily, uint32_t dstQueueFamily, pvrvk::ImageLayout oldLayout, pvrvk::ImageLayout newLayout, pvrvk::Image &amp;image, uint32_t baseMipLevel, uint32_t numMipLevels, uint32_t baseArrayLayer, uint32_t numArrayLayers, pvrvk::ImageAspectFlags aspect)</td></tr>
<tr class="memdesc:a19f7af5558e7afc812edc1e8899d8f50"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set image layout and queue family ownership <a href="#a19f7af5558e7afc812edc1e8899d8f50">More...</a><br/></td></tr>
<tr class="separator:a19f7af5558e7afc812edc1e8899d8f50"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af132fea9e3e9e5b4bc87004a4228096a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr_1_1utils.html#af132fea9e3e9e5b4bc87004a4228096a">takeScreenshot</a> (pvrvk::Queue &amp;queue, pvrvk::CommandPool &amp;commandPool, pvrvk::Swapchain &amp;swapchain, const uint32_t swapIndex, const std::string &amp;screenshotFileName, vma::Allocator *bufferAllocator=nullptr, vma::Allocator *imageAllocator=nullptr, const uint32_t screenshotScale=1)</td></tr>
<tr class="memdesc:af132fea9e3e9e5b4bc87004a4228096a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Saves a particular swapchain image corresponding to the swapchain image at index swapIndex for the swapchain. <a href="#af132fea9e3e9e5b4bc87004a4228096a">More...</a><br/></td></tr>
<tr class="separator:af132fea9e3e9e5b4bc87004a4228096a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adac9f0af2d041d5efe3f668f87c6932b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structpvr_1_1utils_1_1_texture_upload_results.html">TextureUploadResults</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr_1_1utils.html#adac9f0af2d041d5efe3f668f87c6932b">textureUpload</a> (const Texture &amp;texture, bool isEs2, bool allowDecompress)</td></tr>
<tr class="memdesc:adac9f0af2d041d5efe3f668f87c6932b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Upload a texture to the GPU on the current context, and return it as part of the <a class="el" href="structpvr_1_1utils_1_1_texture_upload_results.html" title="The TextureUploadResults structure provides the results for texture upload functions in a simple to u...">TextureUploadResults</a> structure. <a href="#adac9f0af2d041d5efe3f668f87c6932b">More...</a><br/></td></tr>
<tr class="separator:adac9f0af2d041d5efe3f668f87c6932b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a54f2bb511b50d2c11ddc7377a60714ad"><td class="memItemLeft" align="right" valign="top">VKAPI_ATTR VkBool32 VKAPI_CALL&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr_1_1utils.html#a54f2bb511b50d2c11ddc7377a60714ad">throwOnErrorDebugReportCallback</a> (VkDebugReportFlagsEXT flags, VkDebugReportObjectTypeEXT objectType, uint64_t object, size_t location, int32_t messageCode, const char *pLayerPrefix, const char *pMessage, void *pUserData)</td></tr>
<tr class="memdesc:a54f2bb511b50d2c11ddc7377a60714ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">An application DebugReportCallback function providing logging for various events. The callback will also throw an exception when VkDebugReportFlagsEXT includes the VK_DEBUG_REPORT_ERROR_BIT_EXT. <a href="#a54f2bb511b50d2c11ddc7377a60714ad">More...</a><br/></td></tr>
<tr class="separator:a54f2bb511b50d2c11ddc7377a60714ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf3d187bfb119271fea887f28268699a"><td class="memItemLeft" align="right" valign="top">VKAPI_ATTR VkBool32 VKAPI_CALL&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr_1_1utils.html#aaf3d187bfb119271fea887f28268699a">throwOnErrorDebugUtilsMessengerCallback</a> (VkDebugUtilsMessageSeverityFlagBitsEXT messageSeverity, VkDebugUtilsMessageTypeFlagsEXT messageTypes, const VkDebugUtilsMessengerCallbackDataEXT *pCallbackData, void *pUserData)</td></tr>
<tr class="memdesc:aaf3d187bfb119271fea887f28268699a"><td class="mdescLeft">&#160;</td><td class="mdescRight">An application DebugUtilsMessengerCallback function providing logging for various events. The callback will also throw an exception when VkDebugUtilsMessageSeverityFlagBitsEXT includes the VK_DEBUG_UTILS_MESSAGE_SEVERITY_ERROR_BIT_EXT. <a href="#aaf3d187bfb119271fea887f28268699a">More...</a><br/></td></tr>
<tr class="separator:aaf3d187bfb119271fea887f28268699a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a60f28cc84ae08ec7d3c050c8f9725d88"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr_1_1utils.html#a60f28cc84ae08ec7d3c050c8f9725d88">throwOnGlError</a> (const char *note, LogLevel severity=LogLevel::Error)</td></tr>
<tr class="memdesc:a60f28cc84ae08ec7d3c050c8f9725d88"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks and logs api errors if appropriate. <a href="#a60f28cc84ae08ec7d3c050c8f9725d88">More...</a><br/></td></tr>
<tr class="separator:a60f28cc84ae08ec7d3c050c8f9725d88"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf553ba402ff80bc721c72d3a831a703"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr_1_1utils.html#abf553ba402ff80bc721c72d3a831a703">unpackSamplerFilter</a> (PackedSamplerFilter packed, pvrvk::Filter &amp;mini, pvrvk::Filter &amp;magni, pvrvk::SamplerMipmapMode &amp;mip)</td></tr>
<tr class="memdesc:abf553ba402ff80bc721c72d3a831a703"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unpack a packed sampler filter <a href="#abf553ba402ff80bc721c72d3a831a703">More...</a><br/></td></tr>
<tr class="separator:abf553ba402ff80bc721c72d3a831a703"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac885b6f537cb86c114be6696c3dc2fb6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr_1_1utils.html#ac885b6f537cb86c114be6696c3dc2fb6">updateBufferUsingStagingBuffer</a> (pvrvk::Device &amp;device, pvrvk::Buffer &amp;buffer, pvrvk::CommandBufferBase uploadCmdBuffer, const void *data, VkDeviceSize offset=0, VkDeviceSize size=VK_WHOLE_SIZE, vma::Allocator *stagingBufferAllocator=nullptr)</td></tr>
<tr class="memdesc:ac885b6f537cb86c114be6696c3dc2fb6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Utility function to update a buffer's data via an indirect copy from a temporary staging buffer. Updating memory via the use of a staging buffer is necessary when using memory without e_HOST_VISIBLE_BIT memory property flags meaning the buffer itself cannot be mapped to host memory. <a href="#ac885b6f537cb86c114be6696c3dc2fb6">More...</a><br/></td></tr>
<tr class="separator:ac885b6f537cb86c114be6696c3dc2fb6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a618e4160bd8c24d9e0d394dc9511f4a3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr_1_1utils.html#a618e4160bd8c24d9e0d394dc9511f4a3">updateHostVisibleBuffer</a> (pvrvk::Buffer &amp;buffer, const void *data, VkDeviceSize offset=0, VkDeviceSize size=VK_WHOLE_SIZE, bool flushMemory=false)</td></tr>
<tr class="memdesc:a618e4160bd8c24d9e0d394dc9511f4a3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Utility function to update a buffer's data. This function maps and unmap the buffer only if the buffer is not already mapped. <a href="#a618e4160bd8c24d9e0d394dc9511f4a3">More...</a><br/></td></tr>
<tr class="separator:a618e4160bd8c24d9e0d394dc9511f4a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a71cc4019e6c6315a8a714f4103bfe503"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr_1_1utils.html#a71cc4019e6c6315a8a714f4103bfe503">updateImage</a> (pvrvk::Device &amp;device, pvrvk::CommandBufferBase transferCommandBuffer, <a class="el" href="structpvr_1_1utils_1_1_image_update_info.html">ImageUpdateInfo</a> *updateInfos, uint32_t numUpdateInfos, pvrvk::Format format, pvrvk::ImageLayout layout, bool isCubeMap, pvrvk::Image &amp;image, vma::Allocator *bufferAllocator=nullptr)</td></tr>
<tr class="memdesc:a71cc4019e6c6315a8a714f4103bfe503"><td class="mdescLeft">&#160;</td><td class="mdescRight">Utility function to update an image's data. This function will record the update of the image in the supplied command buffer but NOT submit the command buffer, hence allowing the user to submit it at his own time. IMPORTANT. Assumes image layout is pvrvk::ImageLayout::e_DST_OPTIMAL IMPORTANT. The cleanup object that is the return value of the function must be kept alive as long until the moment that the relevant command buffer submission is finished. Then it can be destroyed (or the cleanup function be called) to free any relevant resources. <a href="#a71cc4019e6c6315a8a714f4103bfe503">More...</a><br/></td></tr>
<tr class="separator:a71cc4019e6c6315a8a714f4103bfe503"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a94564335e1a4bb4afe501e4b90c9c25e"><td class="memItemLeft" align="right" valign="top">pvrvk::Image&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr_1_1utils.html#a94564335e1a4bb4afe501e4b90c9c25e">uploadImage</a> (pvrvk::Device &amp;device, const Texture &amp;texture, bool allowDecompress, pvrvk::CommandBuffer &amp;commandBuffer, pvrvk::ImageUsageFlags usageFlags=pvrvk::ImageUsageFlags::e_SAMPLED_BIT, pvrvk::ImageLayout finalLayout=pvrvk::ImageLayout::e_SHADER_READ_ONLY_OPTIMAL, vma::Allocator *stagingBufferAllocator=nullptr, vma::Allocator *imageAllocator=nullptr, vma::AllocationCreateFlags imageAllocationCreateFlags=vma::AllocationCreateFlags::e_NONE)</td></tr>
<tr class="memdesc:a94564335e1a4bb4afe501e4b90c9c25e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Upload image to gpu. The upload command and staging buffers are recorded in the commandbuffer. <a href="#a94564335e1a4bb4afe501e4b90c9c25e">More...</a><br/></td></tr>
<tr class="separator:a94564335e1a4bb4afe501e4b90c9c25e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0bd6e8b8a62c678202323873aeda6115"><td class="memItemLeft" align="right" valign="top">pvrvk::ImageView&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr_1_1utils.html#a0bd6e8b8a62c678202323873aeda6115">uploadImageAndView</a> (pvrvk::Device &amp;device, const Texture &amp;texture, bool allowDecompress, pvrvk::SecondaryCommandBuffer &amp;commandBuffer, pvrvk::ImageUsageFlags usageFlags=pvrvk::ImageUsageFlags::e_SAMPLED_BIT, pvrvk::ImageLayout finalLayout=pvrvk::ImageLayout::e_SHADER_READ_ONLY_OPTIMAL, vma::Allocator *stagingBufferAllocator=nullptr, vma::Allocator *imageAllocator=nullptr, vma::AllocationCreateFlags imageAllocationCreateFlags=vma::AllocationCreateFlags::e_NONE)</td></tr>
<tr class="memdesc:a0bd6e8b8a62c678202323873aeda6115"><td class="mdescLeft">&#160;</td><td class="mdescRight">Uploads an image to gpu. The upload command and staging buffers are recorded in the commandbuffer. <a href="#a0bd6e8b8a62c678202323873aeda6115">More...</a><br/></td></tr>
<tr class="separator:a0bd6e8b8a62c678202323873aeda6115"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaabab7a3b0f9d671f39fd5d6cb9e5fad"><td class="memItemLeft" align="right" valign="top">pvrvk::ImageView&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr_1_1utils.html#aaabab7a3b0f9d671f39fd5d6cb9e5fad">uploadImageAndView</a> (pvrvk::Device &amp;device, const Texture &amp;texture, bool allowDecompress, pvrvk::CommandBuffer &amp;commandBuffer, pvrvk::ImageUsageFlags usageFlags=pvrvk::ImageUsageFlags::e_SAMPLED_BIT, pvrvk::ImageLayout finalLayout=pvrvk::ImageLayout::e_SHADER_READ_ONLY_OPTIMAL, vma::Allocator *stagingBufferAllocator=nullptr, vma::Allocator *imageAllocator=nullptr, vma::AllocationCreateFlags imageAllocationCreateFlags=vma::AllocationCreateFlags::e_NONE)</td></tr>
<tr class="memdesc:aaabab7a3b0f9d671f39fd5d6cb9e5fad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Upload image to gpu. The upload command and staging buffers are recorded in the commandbuffer. <a href="#aaabab7a3b0f9d671f39fd5d6cb9e5fad">More...</a><br/></td></tr>
<tr class="separator:aaabab7a3b0f9d671f39fd5d6cb9e5fad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4275d35b8141132ad949ef9d8ad0f5a2"><td class="memItemLeft" align="right" valign="top">pvrvk::ImageView&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr_1_1utils.html#a4275d35b8141132ad949ef9d8ad0f5a2">uploadImageAndViewSubmit</a> (pvrvk::Device &amp;device, const Texture &amp;texture, bool allowDecompress, pvrvk::CommandPool &amp;commandPool, pvrvk::Queue &amp;queue, pvrvk::ImageUsageFlags usageFlags=pvrvk::ImageUsageFlags::e_SAMPLED_BIT, pvrvk::ImageLayout finalLayout=pvrvk::ImageLayout::e_SHADER_READ_ONLY_OPTIMAL, vma::Allocator *stagingBufferAllocator=nullptr, vma::Allocator *imageAllocator=nullptr, vma::AllocationCreateFlags imageAllocationCreateFlags=vma::AllocationCreateFlags::e_NONE)</td></tr>
<tr class="memdesc:a4275d35b8141132ad949ef9d8ad0f5a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Uploads an image to GPU memory and returns the created image view and associated image. <a href="#a4275d35b8141132ad949ef9d8ad0f5a2">More...</a><br/></td></tr>
<tr class="separator:a4275d35b8141132ad949ef9d8ad0f5a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Main namespace for the PVRUtils Library </p>
</div><h2 class="groupheader">Typedef Documentation</h2>
<a class="anchor" id="a990a2454c0ddfb8bf5383a11262a76ec"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef std::shared_ptr&lt;async::IFrameworkAsyncResult&lt;pvrvk::ImageView&gt; &gt; <a class="el" href="namespacepvr_1_1utils.html#a990a2454c0ddfb8bf5383a11262a76ec">pvr::utils::AsyncApiTexture</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Provides a reference counted pointer to a IFrameworkAsyncResult specialised by an ImageView which will be used as the main interface for using API specific asynchronous textures.</p>

</div>
</div>
<a class="anchor" id="a54bd78a7c682d6b8161db1db04f1f910"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef std::shared_ptr&lt;async::IFrameworkAsyncResult&lt;<a class="el" href="namespacepvr_1_1utils.html#adbd0dc78bf662b222b9e01a5efb6c778">TexturePtr</a>&gt; &gt; <a class="el" href="namespacepvr_1_1utils.html#a54bd78a7c682d6b8161db1db04f1f910">pvr::utils::AsyncTexture</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Provides a reference counted pointer to a IFrameworkAsyncResult specialised by a TexturePtr which will be used as the main interface for using API agnostic asynchronous textures.</p>

</div>
</div>
<a class="anchor" id="ab251744ba4295771d35ea8f3ee497e0f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef std::shared_ptr&lt;<a class="el" href="structpvr_1_1utils_1_1_image_upload_future__.html">ImageUploadFuture_</a>&gt; <a class="el" href="namespacepvr_1_1utils.html#ab251744ba4295771d35ea8f3ee497e0f">pvr::utils::ImageUploadFuture</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A ref-counted pointer to a Future of an Image Upload: A class that wraps the texture that "is being uploaded on a separate thread", together with functions to "query if the upload is yet complete" and to "block until the upload is complete, if necessary, and return the result"</p>

</div>
</div>
<a class="anchor" id="adbd0dc78bf662b222b9e01a5efb6c778"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef std::shared_ptr&lt;Texture&gt; <a class="el" href="namespacepvr_1_1utils.html#adbd0dc78bf662b222b9e01a5efb6c778">pvr::utils::TexturePtr</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Provides a reference counted pointer to a pvr::Texture which will be used for loading API agnostic texture data to disk.</p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="ac66fa9a9c7f8232c3f5aa3f41106cfea"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VboContainer_ , typename IboContainer_ &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void pvr::utils::appendSingleBuffersFromModel </td>
          <td>(</td>
          <td class="paramtype">pvrvk::Device &amp;&#160;</td>
          <td class="paramname"><em>device</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const assets::Model &amp;&#160;</td>
          <td class="paramname"><em>model</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VboContainer_ &amp;&#160;</td>
          <td class="paramname"><em>vbos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IboContainer_ &amp;&#160;</td>
          <td class="paramname"><em>ibos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">pvrvk::CommandBuffer &amp;&#160;</td>
          <td class="paramname"><em>uploadCmdBuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool &amp;&#160;</td>
          <td class="paramname"><em>requiresCommandBufferSubmission</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vma::Allocator *&#160;</td>
          <td class="paramname"><em>bufferAllocator</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vma::AllocationCreateFlags&#160;</td>
          <td class="paramname"><em>vmaAllocationCreateFlags</em> = <code>vma::AllocationCreateFlags::e_MAPPED_BIT</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Auto generates a set of VBOs and a set of IBOs from the vertex data of the meshes of a model and appends them at the end of containers provided by the user.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">device</td><td>The device device where the buffers will be generated on</td></tr>
    <tr><td class="paramname">model</td><td>The model whose meshes will be used to generate the Buffers</td></tr>
    <tr><td class="paramname">vbos</td><td>A container of pvrvk::Buffer handles. The VBOs will be inserted at the end of this container.</td></tr>
    <tr><td class="paramname">ibos</td><td>A container of pvrvk::Buffer handles. The IBOs will be inserted at the end of this container.</td></tr>
    <tr><td class="paramname">uploadCmdBuffer</td><td>A command buffer into which commands may be recorded for uploading mesh data to the created buffers. This command buffer will only be used when memory without e_HOST_VISIBLE_BIT memory property flags was allocated for the vbos or ibos.</td></tr>
    <tr><td class="paramname">requiresCommandBufferSubmission</td><td>Indicates whether commands have been recorded into the given command buffer.</td></tr>
    <tr><td class="paramname">bufferAllocator</td><td>A VMA allocator used to allocate memory for the created buffer.</td></tr>
    <tr><td class="paramname">vmaAllocationCreateFlags</td><td>VMA Allocation creation flags. These flags can be used to control how and where the memory is allocated from. Valid flags include e_DEDICATED_MEMORY_BIT and e_MAPPED_BIT. e_DEDICATED_MEMORY_BIT indicates that the allocation should have its own memory block. e_MAPPED_BIT indicates memory will be persistently mapped respectively. The default vma::AllocationCreateFlags::e_MAPPED_BIT is valid even if HOST_VISIBLE is not used - these flags will be ignored in this case.</td></tr>
  </table>
  </dd>
</dl>
<p>This utility function will read all vertex data from the VBO. It is usually preferred for meshes meshes containing a single set of interleaved data. If multiple data elements (i.e. sets of interleaved data), each block will be successively placed after the other.</p>

</div>
</div>
<a class="anchor" id="a3f241ba112200732fffaeb2906b6ed4b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void pvr::utils::beginCommandBufferDebugLabel </td>
          <td>(</td>
          <td class="paramtype">pvrvk::CommandBufferBase&#160;</td>
          <td class="paramname"><em>commandBufferBase</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const pvrvk::DebugUtilsLabel &amp;&#160;</td>
          <td class="paramname"><em>labelInfo</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Begins identifying a region of work submitted to this command buffer. The calls to beginDebugUtilsLabel and endDebugUtilsLabel must be matched and balanced.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">commandBufferBase</td><td>The command buffer base to which the debug label region should be opened</td></tr>
    <tr><td class="paramname">labelInfo</td><td>Specifies the parameters of the label region to open</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ab62f121a7b8a9d790ca4e4e3dfcff0aa"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void pvr::utils::beginCommandBufferDebugLabel </td>
          <td>(</td>
          <td class="paramtype">pvrvk::CommandBuffer &amp;&#160;</td>
          <td class="paramname"><em>commandBuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const pvrvk::DebugUtilsLabel &amp;&#160;</td>
          <td class="paramname"><em>labelInfo</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Begins identifying a region of work submitted to this command buffer. The calls to beginDebugUtilsLabel and endDebugUtilsLabel must be matched and balanced.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">commandBuffer</td><td>The command buffer to which the debug label region should be opened</td></tr>
    <tr><td class="paramname">labelInfo</td><td>Specifies the parameters of the label region to open</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a45dc67a22e33dc6bf735edc27a1432ef"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void pvr::utils::beginCommandBufferDebugLabel </td>
          <td>(</td>
          <td class="paramtype">pvrvk::SecondaryCommandBuffer &amp;&#160;</td>
          <td class="paramname"><em>secondaryCommandBuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const pvrvk::DebugUtilsLabel &amp;&#160;</td>
          <td class="paramname"><em>labelInfo</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Begins identifying a region of work submitted to this secondary command buffer. The calls to beginDebugUtilsLabel and endDebugUtilsLabel must be matched and balanced.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">secondaryCommandBuffer</td><td>The secondary command buffer to which the debug label region should be opened</td></tr>
    <tr><td class="paramname">labelInfo</td><td>Specifies the parameters of the label region to open</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a7eaec27096b06e097a3ead372e30c68c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void pvr::utils::beginQueueDebugLabel </td>
          <td>(</td>
          <td class="paramtype">pvrvk::Queue&#160;</td>
          <td class="paramname"><em>queue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const pvrvk::DebugUtilsLabel &amp;&#160;</td>
          <td class="paramname"><em>labelInfo</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Begins identifying a region of work submitted to this queue. The calls to beginDebugUtilsLabel and endDebugUtilsLabel must be matched and balanced.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">queue</td><td>The queue to which the debug label region should be opened</td></tr>
    <tr><td class="paramname">labelInfo</td><td>Specifies the parameters of the label region to open</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a1e26711ea2633048564188b42d62f11b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;unsigned char&gt; pvr::utils::captureImageRegion </td>
          <td>(</td>
          <td class="paramtype">pvrvk::Queue &amp;&#160;</td>
          <td class="paramname"><em>queue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">pvrvk::CommandPool &amp;&#160;</td>
          <td class="paramname"><em>commandPool</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">pvrvk::Image &amp;&#160;</td>
          <td class="paramname"><em>image</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">pvrvk::Offset3D&#160;</td>
          <td class="paramname"><em>srcOffset</em> = <code>pvrvk::Offset3D(0,&#160;0,&#160;0)</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">pvrvk::Extent3D&#160;</td>
          <td class="paramname"><em>srcExtent</em> = <code>pvrvk::Extent3D(-1,-1,-1)</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">pvrvk::Format&#160;</td>
          <td class="paramname"><em>destinationImageFormat</em> = <code>pvrvk::Format::e_UNDEFINED</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">pvrvk::ImageLayout&#160;</td>
          <td class="paramname"><em>imageInitialLayout</em> = <code>pvrvk::ImageLayout::e_TRANSFER_SRC_OPTIMAL</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">pvrvk::ImageLayout&#160;</td>
          <td class="paramname"><em>imageFinalLayout</em> = <code>pvrvk::ImageLayout::e_TRANSFER_DST_OPTIMAL</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vma::Allocator *&#160;</td>
          <td class="paramname"><em>bufferAllocator</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vma::Allocator *&#160;</td>
          <td class="paramname"><em>imageAllocator</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieves and returns the contents of a particular image region. Note that the image must have been created with the pvrvk::ImageUsageFlags::e_TRANSFER_SRC_BIT set.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">queue</td><td>A queue to submit the generated command buffer to. This queue must be compatible with the command pool provided.</td></tr>
    <tr><td class="paramname">commandPool</td><td>A command pool from which to allocate a temporary command buffer to carry out the transfer operations.</td></tr>
    <tr><td class="paramname">image</td><td>The image from which the specified region will be retrieved.</td></tr>
    <tr><td class="paramname">srcOffset</td><td>The offset into the specified image from which to begin the region to capture.</td></tr>
    <tr><td class="paramname">srcExtent</td><td>The extent of the region to capture.</td></tr>
    <tr><td class="paramname">destinationImageFormat</td><td>The format to use for the saved image. Valid format conversions will be applied using vkCmdBlitImage.</td></tr>
    <tr><td class="paramname">imageInitialLayout</td><td>The initial layout of the image from which a transition will be made to pvrvk::ImageLayout::e_TRANSFER_SRC_OPTIMAL.</td></tr>
    <tr><td class="paramname">imageFinalLayout</td><td>The final layout of the image to which a transition will be made.</td></tr>
    <tr><td class="paramname">bufferAllocator</td><td>A VMA allocator used to allocate memory for the created the buffer used as the target of an imageToBufferCopy.</td></tr>
    <tr><td class="paramname">imageAllocator</td><td>A VMA allocator used to allocate memory for the created image.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A vector containing the retrieved image data</dd></dl>

</div>
</div>
<a class="anchor" id="aafce526b759924e9114572d863b5b8f6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int pvr::utils::checkApiError </td>
          <td>(</td>
          <td class="paramtype">std::string *&#160;</td>
          <td class="paramname"><em>errOutStr</em> = <code>NULL</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks and returns api error if appropriate.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">errOutStr</td><td>error std::string to be output.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>api error code</dd></dl>

</div>
</div>
<a class="anchor" id="a7b92cb613310549a5b748d1f5c4b4557"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">GLenum pvr::utils::convertToGles </td>
          <td>(</td>
          <td class="paramtype">IndexType&#160;</td>
          <td class="paramname"><em>type</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Converts from a pvr::IndexType to its OpenGL ES GLenum counterpart.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">type</td><td>The pvr::IndexType to convert.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The OpenGL ES GLenum counterpart to a pvr::IndexType.</dd></dl>

</div>
</div>
<a class="anchor" id="aabfe42ed26ab9fcb99118de82013eedb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">GLenum pvr::utils::convertToGles </td>
          <td>(</td>
          <td class="paramtype">Face&#160;</td>
          <td class="paramname"><em>face</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert to opengl face.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">face</td><td>A Face enum</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A GLenum representing a face (GL_FRONT, GL_BACK, GL_FRONT_AND_BACK, GL_NONE)</dd></dl>

</div>
</div>
<a class="anchor" id="a2cf730a0573373abb18dcefa9390e840"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">GLenum pvr::utils::convertToGles </td>
          <td>(</td>
          <td class="paramtype">PolygonWindingOrder&#160;</td>
          <td class="paramname"><em>windingOrder</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert to opengl winding-order.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">windingOrder</td><td>A PolygonWindingOrder enum</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A GLenum representing a winding order (GL_CW, GL_CCW)</dd></dl>

</div>
</div>
<a class="anchor" id="a196375d06b5173798e46037c7b8eb890"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">GLenum pvr::utils::convertToGles </td>
          <td>(</td>
          <td class="paramtype">CompareOp&#160;</td>
          <td class="paramname"><em>func</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert to opengl comparison mode.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">func</td><td>A ComparisonMode enum</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A GLenum representing a ComparisonMode (GL_LESS, GL_EQUAL etc)</dd></dl>

</div>
</div>
<a class="anchor" id="a648788eddea6a26479db4a04cdeedf55"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">GLenum pvr::utils::convertToGles </td>
          <td>(</td>
          <td class="paramtype">ImageAspectFlags&#160;</td>
          <td class="paramname"><em>type</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert to an opengl image aspect type.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">type</td><td>An ImageAspectFlags enum</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A GLenum representing the ImageAspectFlags</dd></dl>

</div>
</div>
<a class="anchor" id="a7d36f28640fc36caaed25f8935a48229"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">GLenum pvr::utils::convertToGles </td>
          <td>(</td>
          <td class="paramtype">ImageViewType&#160;</td>
          <td class="paramname"><em>texType</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert to opengl texture type.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">texType</td><td>A TextureDimension enum</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A GLenum representing a texture dimension (GL_TEXTURE_2D, GL_TEXTURE_3D, GL_TEXTURE_CUBE_MAP, GL_TEXTURE_2D_ARRAY)</dd></dl>

</div>
</div>
<a class="anchor" id="ad86cd8604c6d3c155b531d7a1784581f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">GLenum pvr::utils::convertToGles </td>
          <td>(</td>
          <td class="paramtype">DataType&#160;</td>
          <td class="paramname"><em>dataType</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert to opengl data type.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dataType</td><td>A DataType enum</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A GLenum representing a DataType (GL_FLOAT, GL_UNSIGNED_BYTE etc)</dd></dl>

</div>
</div>
<a class="anchor" id="a4848cd91db829306bc8a1ed929762aad"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">GLenum pvr::utils::convertToGles </td>
          <td>(</td>
          <td class="paramtype">PrimitiveTopology&#160;</td>
          <td class="paramname"><em>primitiveType</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert to opengl priitive type.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">primitiveType</td><td>a PrimitiveTopology enum</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A GLenum representing a primitive type (GL_TRIANGLES, GL_TRIANGLE_STRIP, GL_POINTS etc)</dd></dl>

</div>
</div>
<a class="anchor" id="a3c41ff094638c4216cb39bf821408fe5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">GLenum pvr::utils::convertToGles </td>
          <td>(</td>
          <td class="paramtype">SamplerAddressMode&#160;</td>
          <td class="paramname"><em>addressMode</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert to opengl sampler wrap.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">addressMode</td><td>A SamplerAddressMode enum</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A GLenum representing a Sampler Wrap mode (GL_CLAMP_TO_EDGE, GL_REPEAT etc)</dd></dl>

</div>
</div>
<a class="anchor" id="af1dc4d95376bb577dd85455028527815"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">GLenum pvr::utils::convertToGles </td>
          <td>(</td>
          <td class="paramtype">StencilOp&#160;</td>
          <td class="paramname"><em>stencilOp</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert to opengl stencil op output.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">stencilOp</td><td>A StencilOp enum</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A GLenum representing a Stencil Operation (GL_INC_WRAP, GL_ZERO etc)</dd></dl>

</div>
</div>
<a class="anchor" id="afe32fb89dfe5e37513af651055cdef15"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">GLenum pvr::utils::convertToGles </td>
          <td>(</td>
          <td class="paramtype">BlendOp&#160;</td>
          <td class="paramname"><em>blendOp</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert to opengl blend op output.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">blendOp</td><td>A BlendOp enum</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A GLenum representing a Blend Operation (GL_FUNC_ADD, GL_MIN etc)</dd></dl>

</div>
</div>
<a class="anchor" id="a20ca18b411c83be99cc9b83137cef4d8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">GLenum pvr::utils::convertToGles </td>
          <td>(</td>
          <td class="paramtype">BlendFactor&#160;</td>
          <td class="paramname"><em>blendFactor</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert to opengl blend factor output.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">blendFactor</td><td>A BlendFactor enum</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A GLenum representing a BlendFactor (GL_ZERO, GL_SRC_COLOR, GL_ONE_MINUS_SRC_ALPHA etc)</dd></dl>

</div>
</div>
<a class="anchor" id="a6faa52cbc7bd9bc2ff02b680ca3c869d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">pvrvk::IndexType pvr::utils::convertToPVRVk </td>
          <td>(</td>
          <td class="paramtype">IndexType&#160;</td>
          <td class="paramname"><em>type</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert a pvr::IndexType to its Native, Vulkan representation.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">type</td><td>A pvr::IndexType to convert to its Vulkan representation</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pvrvk::IndexType corresponding to the pvr::IndexType</dd></dl>

</div>
</div>
<a class="anchor" id="ac4535ea5342874964d50833bfa20221c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">pvrvk::ImageViewType pvr::utils::convertToPVRVk </td>
          <td>(</td>
          <td class="paramtype">ImageViewType&#160;</td>
          <td class="paramname"><em>texDimemsion</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert to pvrvk image view type</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">texDimemsion</td><td>Texture dimension</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pvrvk::ImageViewType (pvrvk::ImageViewType::e_1D, pvrvk::ImageViewType::e_2D etc)</dd></dl>

</div>
</div>
<a class="anchor" id="ae0492010765906fc6787a7e2498ba57c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">pvrvk::VertexInputRate pvr::utils::convertToPVRVk </td>
          <td>(</td>
          <td class="paramtype">StepRate&#160;</td>
          <td class="paramname"><em>stepRate</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert to pvrvk vertex input rate</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">stepRate</td><td>The step rate of the vertex input(Vertex, Instance)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pvrvk::VertexInputRate (pvrvk::VertexInputRate::e_VERTEX, pvrvk::VertexInputRate::e_INSTANCE)</dd></dl>

</div>
</div>
<a class="anchor" id="ada8e829e93a104391248c513aeabe8d3"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">pvrvk::DataType pvr::utils::convertToPVRVk </td>
          <td>(</td>
          <td class="paramtype">DataType&#160;</td>
          <td class="paramname"><em>dataType</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert to pvrvk Data type</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dataType</td><td>The pvr::DataType to convert to Vulkan type</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pvrvk::DataType</dd></dl>

</div>
</div>
<a class="anchor" id="a3116f95a85b64265c0b26ce81df895cd"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">pvrvk::Format pvr::utils::convertToPVRVk </td>
          <td>(</td>
          <td class="paramtype">const ImageDataFormat &amp;&#160;</td>
          <td class="paramname"><em>format</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert to pvrvk pixel format</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">format</td><td>Image Data format</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pvrvk::Format representing the pixel format</dd></dl>

</div>
</div>
<a class="anchor" id="af9c490851508a5e8618c5f6e15b3cae0"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">pvrvk::StencilOpState pvr::utils::convertToPVRVk </td>
          <td>(</td>
          <td class="paramtype">const StencilState &amp;&#160;</td>
          <td class="paramname"><em>op</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert to pvrvk StencilOpState</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">op</td><td>The pvr::StencilState to convert</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pvrvk::StencilOpState representing the StencilState</dd></dl>

</div>
</div>
<a class="anchor" id="abf411047de1c9b93006e248404d156cd"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">pvrvk::PipelineColorBlendAttachmentState pvr::utils::convertToPVRVk </td>
          <td>(</td>
          <td class="paramtype">const BlendingConfig &amp;&#160;</td>
          <td class="paramname"><em>config</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert to pvrvk PipelineColorBlendAttachmentState</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">config</td><td>The pvr::BlendingConfig to convert</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pvrvk::PipelineColorBlendAttachmentState representing the BlendingConfig</dd></dl>

</div>
</div>
<a class="anchor" id="a980064e6fd1ed7293c5b04941625bccf"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">pvrvk::VertexInputAttributeDescription pvr::utils::convertToPVRVk </td>
          <td>(</td>
          <td class="paramtype">const VertexAttributeInfo &amp;&#160;</td>
          <td class="paramname"><em>info</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>binding</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert to pvrvk VertexInputAttributeDescription</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">info</td><td>The pvr::VertexAttributeInfo to convert</td></tr>
    <tr><td class="paramname">binding</td><td>The binding index to use as part of the pvrvk::VertexInputAttributeDescription</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pvrvk::VertexInputAttributeDescription representing the <a class="el" href="structpvr_1_1utils_1_1_vertex_attribute_info.html" title="Contains a full description of a Vertex Attribute: Index, format, number of elements, offset in the buffer, optionally name. All values (except attributeName) must be set explicitly.">VertexAttributeInfo</a> with corresponding binding index</dd></dl>

</div>
</div>
<a class="anchor" id="a85935527bc9b1766c64a889a5194f405"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">pvrvk::VertexInputBindingDescription pvr::utils::convertToPVRVk </td>
          <td>(</td>
          <td class="paramtype">const VertexInputBindingInfo &amp;&#160;</td>
          <td class="paramname"><em>info</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert to pvrvk VertexInputBindingDescription</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">info</td><td>The pvr::VertexInputBindingInfo to convert</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pvrvk::VertexInputBindingDescription representing the <a class="el" href="structpvr_1_1utils_1_1_vertex_input_binding_info.html" title="Information about a Buffer binding: Binding index, stride, (instance) step rate.">VertexInputBindingInfo</a></dd></dl>

</div>
</div>
<a class="anchor" id="a3e5b7760e47f22fd546b6eabfcae3b62"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">pvrvk::Extent3D pvr::utils::convertToPVRVk </td>
          <td>(</td>
          <td class="paramtype">const Extent3D &amp;&#160;</td>
          <td class="paramname"><em>extent</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert to pvrvk Extent3D</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">extent</td><td>The pvr::Extent3D to convert</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pvrvk::Extent3D representing the Extent3D</dd></dl>

</div>
</div>
<a class="anchor" id="a1015e60258a9b1ea86213471275c8955"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">pvrvk::Extent2D pvr::utils::convertToPVRVk </td>
          <td>(</td>
          <td class="paramtype">const Extent2D &amp;&#160;</td>
          <td class="paramname"><em>extent</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert to pvrvk Extent2D</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">extent</td><td>The pvr::Extent2D to convert</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pvrvk::Extent2D representing the Extent2D</dd></dl>

</div>
</div>
<a class="anchor" id="a7ae6b94f99d8533786ba3eb16f4e694a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">pvrvk::Offset3D pvr::utils::convertToPVRVk </td>
          <td>(</td>
          <td class="paramtype">const Offset3D &amp;&#160;</td>
          <td class="paramname"><em>offset</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert to pvrvk Offset3D</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">offset</td><td>The pvr::Offset3D to convert</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pvrvk::Offset3D representing the Offset3D</dd></dl>

</div>
</div>
<a class="anchor" id="a251d0fffcee64a05e2619a02b52b109e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">pvrvk::Offset2D pvr::utils::convertToPVRVk </td>
          <td>(</td>
          <td class="paramtype">const Offset2D &amp;&#160;</td>
          <td class="paramname"><em>offset</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert to pvrvk Offset2D</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">offset</td><td>The pvr::Offset2D to convert</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pvrvk::Offset2D representing the Offset2D</dd></dl>

</div>
</div>
<a class="anchor" id="a745663053f1f1c98e457ce71a8b0048a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">pvrvk::SamplerMipmapMode pvr::utils::convertToPVRVkMipmapMode </td>
          <td>(</td>
          <td class="paramtype">Filter&#160;</td>
          <td class="paramname"><em>filter</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert to pvrvk sampler mip-map mode</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">filter</td><td>Mip map sampler filter</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pvrvk::SamplerMipmapMode (pvrvk::SamplerMipmapMode::e_NEAREST, pvrvk::SamplerMipmapMode::e_LINEAR)</dd></dl>

</div>
</div>
<a class="anchor" id="acb6a1fc2c108c439d57cb44f189099aa"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">pvrvk::SampleCountFlags pvr::utils::convertToPVRVkNumSamples </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>numSamples</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert to pvrvk sample count</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">numSamples</td><td>Number of samples</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pvrvk::SampleCountFlags (pvrvk::SampleCountFlags::e_1_BIT, pvrvk::SampleCountFlags::e_2_BIT, etc)</dd></dl>

</div>
</div>
<a class="anchor" id="a7d459b2f7cdcedd6fc8ae939064dae1d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">pvrvk::Format pvr::utils::convertToPVRVkPixelFormat </td>
          <td>(</td>
          <td class="paramtype">PixelFormat&#160;</td>
          <td class="paramname"><em>format</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ColorSpace&#160;</td>
          <td class="paramname"><em>colorSpace</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VariableType&#160;</td>
          <td class="paramname"><em>dataType</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert to pvrvk pixel format</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">format</td><td>Pixel format</td></tr>
    <tr><td class="paramname">colorSpace</td><td>Color space of the format (lRGB, sRGB)</td></tr>
    <tr><td class="paramname">dataType</td><td>Type of the data (SignedByte, SignedInteger etc)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pvrvk::Format representing the pixel format</dd></dl>

</div>
</div>
<a class="anchor" id="a5985423e5f61cf77204a1157fa4783f1"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">pvrvk::Format pvr::utils::convertToPVRVkPixelFormat </td>
          <td>(</td>
          <td class="paramtype">PixelFormat&#160;</td>
          <td class="paramname"><em>format</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ColorSpace&#160;</td>
          <td class="paramname"><em>colorSpace</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VariableType&#160;</td>
          <td class="paramname"><em>dataType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool &amp;&#160;</td>
          <td class="paramname"><em>outIsCompressedFormat</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert to pvrvk pixel format</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">format</td><td>Pixel format</td></tr>
    <tr><td class="paramname">colorSpace</td><td>Color space of the format (lRGB, sRGB)</td></tr>
    <tr><td class="paramname">dataType</td><td>TYpe of the data (SignedByte, SignedInteger etc)</td></tr>
    <tr><td class="paramname">outIsCompressedFormat</td><td>Return if its a compressed format</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pvrvk::Format representing the pixel format</dd></dl>

</div>
</div>
<a class="anchor" id="a116badc6ed0a108f3cc8ea515283a458"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">pvrvk::Format pvr::utils::convertToPVRVkVertexInputFormat </td>
          <td>(</td>
          <td class="paramtype">DataType&#160;</td>
          <td class="paramname"><em>dataType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>width</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert to pvrvk format</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dataType</td><td>Type of the data(Float32, Int32 etc)</td></tr>
    <tr><td class="paramname">width</td><td>The Width of the data type</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pvrvk::Format (pvrvk::Format::e_R32_SFLOAT, pvrvk::Format::e_R32G32_SFLOAT etc)</dd></dl>

</div>
</div>
<a class="anchor" id="ad0c9ce4267ec635305fc87aba0b9d9c2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pvr::utils::create3dPlaneMesh </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>width</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>depth</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>generateTexCoords</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>generateNormalCoords</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">assets::Mesh &amp;&#160;</td>
          <td class="paramname"><em>outMesh</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a 3d plane mesh based on the width and depth specified. Texture coordinates and normal coordinates can also optionally be generated based on the generateTexCoords and generateNormalCoords flags respectively. The generated mesh will be returned as a pvr::assets::Mesh.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">width</td><td>The width of the plane to generate.</td></tr>
    <tr><td class="paramname">depth</td><td>The depth of the plane to generate.</td></tr>
    <tr><td class="paramname">generateTexCoords</td><td>Specifies whether to generate texture coordinates for the plane.</td></tr>
    <tr><td class="paramname">generateNormalCoords</td><td>Specifies whether to generate normal coordinates for the plane.</td></tr>
    <tr><td class="paramname">outMesh</td><td>The generated pvr::assets::Mesh.</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="acecac80786da19a6303dbf72345c16a9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">pvrvk::Buffer pvr::utils::createBuffer </td>
          <td>(</td>
          <td class="paramtype">pvrvk::Device&#160;</td>
          <td class="paramname"><em>device</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VkDeviceSize&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">pvrvk::BufferUsageFlags&#160;</td>
          <td class="paramname"><em>bufferUsage</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">pvrvk::MemoryPropertyFlags&#160;</td>
          <td class="paramname"><em>requiredMemoryFlags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">pvrvk::MemoryPropertyFlags&#160;</td>
          <td class="paramname"><em>optimalMemoryFlags</em> = <code>pvrvk::MemoryPropertyFlags::e_NONE</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vma::Allocator *&#160;</td>
          <td class="paramname"><em>bufferAllocator</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vma::AllocationCreateFlags&#160;</td>
          <td class="paramname"><em>vmaAllocationCreateFlags</em> = <code>vma::AllocationCreateFlags::e_MAPPED_BIT</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">pvrvk::BufferCreateFlags&#160;</td>
          <td class="paramname"><em>bufferCreateFlags</em> = <code>pvrvk::BufferCreateFlags(0)</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">pvrvk::SharingMode&#160;</td>
          <td class="paramname"><em>sharingMode</em> = <code>pvrvk::SharingMode::e_EXCLUSIVE</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint32_t *&#160;</td>
          <td class="paramname"><em>queueFamilyIndices</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>numQueueFamilyIndices</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a new buffer object and (optionally) allocate and bind memory for it</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">device</td><td>The device on which to create the buffer</td></tr>
    <tr><td class="paramname">size</td><td>The total size of the buffer</td></tr>
    <tr><td class="paramname">bufferUsage</td><td>All buffer usages for which this buffer will be valid</td></tr>
    <tr><td class="paramname">requiredMemoryFlags</td><td>The minimal set of memory property flags which are required for the PVRVk buffer to be created. If pvrvk::MemoryPropertyFlags::e_NONE is passed, no memory will be allocated for this buffer.</td></tr>
    <tr><td class="paramname">optimalMemoryFlags</td><td>The most optimal set of memory property flags which could be used by the memory backing the returned PVRVk buffer. If pvrvk::MemoryPropertyFlags::e_NONE is passed optimalMemoryFlags will be set to match requiredMemoryFlags.</td></tr>
    <tr><td class="paramname">bufferAllocator</td><td>A VMA allocator used to allocate memory for the created buffer.</td></tr>
    <tr><td class="paramname">vmaAllocationCreateFlags</td><td>VMA Allocation creation flags. These flags can be used to control how and where the memory is allocated from. Valid flags include e_DEDICATED_MEMORY_BIT and e_MAPPED_BIT. e_DEDICATED_MEMORY_BIT indicates that the allocation should have its own memory block. e_MAPPED_BIT indicates memory will be persistently mapped respectively. The default vma::AllocationCreateFlags::e_MAPPED_BIT is valid even if HOST_VISIBLE is not used - these flags will be ignored in this case.</td></tr>
    <tr><td class="paramname">bufferCreateFlags</td><td>Buffer creation flags (see Vulkan spec)</td></tr>
    <tr><td class="paramname">sharingMode</td><td>indicates whether the buffer is exclusive for some queues or can be used simultaneously multiple queues</td></tr>
    <tr><td class="paramname">queueFamilyIndices</td><td>If not exclusive, indicates which queue families the buffer can be used by</td></tr>
    <tr><td class="paramname">numQueueFamilyIndices</td><td>If not exclusive, the number of queue families for which this buffer is valid</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Return a valid object if success</dd></dl>
<p>. </p>

</div>
</div>
<a class="anchor" id="a7af92cf8d09982258386f5cc4e6f2f80"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">GLuint pvr::utils::createComputeShaderProgram </td>
          <td>(</td>
          <td class="paramtype">IAssetProvider &amp;&#160;</td>
          <td class="paramname"><em>app</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>compShaderFilename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *const *&#160;</td>
          <td class="paramname"><em>defines</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>numDefines</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a native shader program from a compute shader</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">app</td><td>An AssetProvider to use for loading shaders from memory</td></tr>
    <tr><td class="paramname">compShaderFilename</td><td>The filename of a compute shader</td></tr>
    <tr><td class="paramname">defines</td><td>A list of defines to be added to the shaders</td></tr>
    <tr><td class="paramname">numDefines</td><td>The number of defines to be added to the shaders</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The program object</dd></dl>

</div>
</div>
<a class="anchor" id="a3c7a82ad08f5f77c574a75fc1c4eca9a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structpvr_1_1utils_1_1_debug_utils_callbacks.html">DebugUtilsCallbacks</a> pvr::utils::createDebugUtilsCallbacks </td>
          <td>(</td>
          <td class="paramtype">pvrvk::Instance &amp;&#160;</td>
          <td class="paramname"><em>instance</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a default set of debug utils messengers or debug callbacks using either VK_EXT_debug_utils or VK_EXT_debug_report respectively. The first callback will trigger an exception to be thrown when an error message is returned. The second callback will Log a message for errors and warnings.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">instance</td><td>The instance from which the debug utils messengers or debug callbacks will be created depending on support for VK_EXT_debug_utils or VK_EXT_debug_report respectively.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A <a class="el" href="structpvr_1_1utils_1_1_debug_utils_callbacks.html" title="A simple wrapper structure which provides a more abstract representation of a set of debug utils mess...">pvr::utils::DebugUtilsCallbacks</a> structure which keeps alive the debug utils callbacks created.</dd></dl>

</div>
</div>
<a class="anchor" id="a34226196d1cd435e8f19abecc2d3b0eb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">pvrvk::Device pvr::utils::createDeviceAndQueues </td>
          <td>(</td>
          <td class="paramtype">pvrvk::PhysicalDevice&#160;</td>
          <td class="paramname"><em>physicalDevice</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const QueuePopulateInfo *&#160;</td>
          <td class="paramname"><em>queueCreateInfos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>numQueueCreateInfos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">QueueAccessInfo *&#160;</td>
          <td class="paramname"><em>outAccessInfo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const DeviceExtensions &amp;&#160;</td>
          <td class="paramname"><em>deviceExtensions</em> = <code>DeviceExtensions()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create the pvrvk::Device and the queues</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">physicalDevice</td><td>A physical device to use for creating the logical device.</td></tr>
    <tr><td class="paramname">queueCreateInfos</td><td>A pointer to a list of <a class="el" href="structpvr_1_1utils_1_1_queue_populate_info.html" title="A structure encapsulating the set of queue flags required for a particular queue retrieved via the he...">QueuePopulateInfo</a> structures specifying the required properties for each of the queues retrieved.</td></tr>
    <tr><td class="paramname">numQueueCreateInfos</td><td>The number of <a class="el" href="structpvr_1_1utils_1_1_queue_populate_info.html" title="A structure encapsulating the set of queue flags required for a particular queue retrieved via the he...">QueuePopulateInfo</a> structures provided.</td></tr>
    <tr><td class="paramname">outAccessInfo</td><td>A pointer to a list of <a class="el" href="structpvr_1_1utils_1_1_queue_access_info.html" title="A structure encapsulating the family id and queue id of a particular queue retrieved via the helper f...">QueueAccessInfo</a> structures specifying the properties for each of the queues retrieved.</td></tr>
    <tr><td class="paramname">deviceExtensions</td><td>A <a class="el" href="structpvr_1_1utils_1_1_device_extensions.html" title="Container for a list of device extensions to be used for initiailising a device using the helper func...">DeviceExtensions</a> structure which specifyies a list device extensions to try to enable.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the created device</dd></dl>

</div>
</div>
<a class="anchor" id="a2ea80135aa97006c881f5d3fface1563"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">pvrvk::Image pvr::utils::createImage </td>
          <td>(</td>
          <td class="paramtype">pvrvk::Device&#160;</td>
          <td class="paramname"><em>device</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">pvrvk::ImageType&#160;</td>
          <td class="paramname"><em>imageType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">pvrvk::Format&#160;</td>
          <td class="paramname"><em>format</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const pvrvk::Extent3D &amp;&#160;</td>
          <td class="paramname"><em>dimension</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">pvrvk::ImageUsageFlags&#160;</td>
          <td class="paramname"><em>usage</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">pvrvk::ImageCreateFlags&#160;</td>
          <td class="paramname"><em>flags</em> = <code>pvrvk::ImageCreateFlags(0)</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const pvrvk::ImageLayersSize &amp;&#160;</td>
          <td class="paramname"><em>layerSize</em> = <code>pvrvk::ImageLayersSize()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">pvrvk::SampleCountFlags&#160;</td>
          <td class="paramname"><em>samples</em> = <code>pvrvk::SampleCountFlags::e_1_BIT</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">pvrvk::MemoryPropertyFlags&#160;</td>
          <td class="paramname"><em>requiredMemoryFlags</em> = <code>pvrvk::MemoryPropertyFlags::e_DEVICE_LOCAL_BIT</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">pvrvk::MemoryPropertyFlags&#160;</td>
          <td class="paramname"><em>optimalMemoryFlags</em> = <code>pvrvk::MemoryPropertyFlags::e_NONE</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vma::Allocator *&#160;</td>
          <td class="paramname"><em>imageAllocator</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vma::AllocationCreateFlags&#160;</td>
          <td class="paramname"><em>vmaAllocationCreateFlags</em> = <code>vma::AllocationCreateFlags::e_NONE</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">pvrvk::SharingMode&#160;</td>
          <td class="paramname"><em>sharingMode</em> = <code>pvrvk::SharingMode::e_EXCLUSIVE</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">pvrvk::ImageTiling&#160;</td>
          <td class="paramname"><em>tiling</em> = <code>pvrvk::ImageTiling::e_OPTIMAL</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">pvrvk::ImageLayout&#160;</td>
          <td class="paramname"><em>initialLayout</em> = <code>pvrvk::ImageLayout::e_UNDEFINED</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint32_t *&#160;</td>
          <td class="paramname"><em>queueFamilyIndices</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>numQueueFamilyIndices</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>create a new Image(sparse or with memory backing, depending on <em>flags</em> . The user should not call bindMemory on the image if sparse flags are used. <em>requiredMemoryFlags</em>  is ignored if <em>flags</em>  contains sparse binding flags.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">device</td><td>The device on which to create the image</td></tr>
    <tr><td class="paramname">imageType</td><td>The type of the created image (1D/2D/3D etc)</td></tr>
    <tr><td class="paramname">format</td><td>The Image format</td></tr>
    <tr><td class="paramname">dimension</td><td>Image dimension</td></tr>
    <tr><td class="paramname">usage</td><td>Image usage flags</td></tr>
    <tr><td class="paramname">flags</td><td>Image create flags</td></tr>
    <tr><td class="paramname">layerSize</td><td>Image layer size</td></tr>
    <tr><td class="paramname">samples</td><td>Number of samples</td></tr>
    <tr><td class="paramname">requiredMemoryFlags</td><td>The minimal set of memory property flags which are required for the PVRVk Image to be created. If pvrvk::MemoryPropertyFlags::e_NONE is passed, no memory will be allocated for this Image.</td></tr>
    <tr><td class="paramname">optimalMemoryFlags</td><td>The most optimal set of memory property flags which could be used by the memory backing the returned PVRVk Image. If pvrvk::MemoryPropertyFlags::e_NONE is passed optimalMemoryFlags will be set to match requiredMemoryFlags.</td></tr>
    <tr><td class="paramname">imageAllocator</td><td>A VMA allocator used to allocate memory for the created image.</td></tr>
    <tr><td class="paramname">vmaAllocationCreateFlags</td><td>VMA Allocation creation flags. These flags can be used to control how and where the memory is allocated from. Valid flags include e_DEDICATED_MEMORY_BIT and e_MAPPED_BIT. e_DEDICATED_MEMORY_BIT indicates that the allocation should have its own memory block. e_MAPPED_BIT indicates memory will be persistently mapped respectively. The default vma::AllocationCreateFlags::e_MAPPED_BIT is valid even if HOST_VISIBLE is not used - these flags will be ignored in this case.</td></tr>
    <tr><td class="paramname">sharingMode</td><td>Specifying the sharing mode of this image. Setting it exclusive means that only a single queue can access it therefore the calle must exclusively transfer queue ownership of this image if they want separate queue family to access this image and the <em>queueFamilyIndices</em> , <em>numQueueFamilyIndices</em>  is ignored. Setting it to concurrent means multiple queue family can access this image at any point in time and requires <em>queueFamilyIndices</em> , <em>numQueueFamilyIndices</em> </td></tr>
    <tr><td class="paramname">queueFamilyIndices</td><td>A c-style array containing the queue family indices that this image is exclusive to</td></tr>
    <tr><td class="paramname">tiling</td><td>Specifies the tiling mode which defines the tiling arrangement of data elements in memory</td></tr>
    <tr><td class="paramname">initialLayout</td><td>Is a ImageLayout value specifying the initial ImageLayout of all image subresources of the image</td></tr>
    <tr><td class="paramname">numQueueFamilyIndices</td><td>The number of queues in <em>queueFamilyIndices</em> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The created Imageobject on success, null Image on failure</dd></dl>

</div>
</div>
<a class="anchor" id="a680ef5943947e565f7d14aa9ff0393d9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">pvrvk::Instance pvr::utils::createInstance </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>applicationName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VulkanVersion&#160;</td>
          <td class="paramname"><em>apiVersion</em> = <code>VulkanVersion()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const InstanceExtensions &amp;&#160;</td>
          <td class="paramname"><em>instanceExtensions</em> = <code>InstanceExtensions()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const InstanceLayers &amp;&#160;</td>
          <td class="paramname"><em>instanceLayers</em> = <code>InstanceLayers()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Utility function for creating a Vulkan instance and supported physical devices using the appropriately set parameters.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">applicationName</td><td>Used for setting the pApplicationName of the pvrvk::ApplicationInfo structure used when calling vkCreateInstance.</td></tr>
    <tr><td class="paramname">apiVersion</td><td>A <a class="el" href="structpvr_1_1utils_1_1_vulkan_version.html" title="The VulkanVersion structure provides an easy mechanism for constructing the Vulkan version for use wh...">VulkanVersion</a> structure used for setting the apiVersion of the pvrvk::ApplicationInfo structure used when creating the Vulkan instance.</td></tr>
    <tr><td class="paramname">instanceExtensions</td><td>An <a class="el" href="structpvr_1_1utils_1_1_instance_extensions.html" title="Container for a list of instance extensions to be used for initiailising an instance using the helper...">InstanceExtensions</a> structure which holds a list of instance extensions which will be checked for compatibility with the current Vulkan implementation before setting as the ppEnabledExtensionNames member of the pvrvk::InstanceCreateInfo used when creating the Vulkan instance.</td></tr>
    <tr><td class="paramname">instanceLayers</td><td>An <a class="el" href="structpvr_1_1utils_1_1_instance_layers.html" title="Container for a list of instance layers to be used for initiailising an instance using the helper fun...">InstanceLayers</a> structure which holds a list of instance layers which will be checked for compatibility with the current Vulkan implementation before setting as the ppEnabledLayerNames member of the pvrvk::InstanceCreateInfo used when creating the Vulkan instance.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the created Instance.</dd></dl>

</div>
</div>
<a class="anchor" id="a95e0a5be7c444548e52a74c2f40faaa5"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void pvr::utils::createMultipleBuffersFromMesh </td>
          <td>(</td>
          <td class="paramtype">pvrvk::Device &amp;&#160;</td>
          <td class="paramname"><em>device</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const assets::Mesh &amp;&#160;</td>
          <td class="paramname"><em>mesh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; pvrvk::Buffer &gt; &amp;&#160;</td>
          <td class="paramname"><em>outVbos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">pvrvk::Buffer &amp;&#160;</td>
          <td class="paramname"><em>outIbo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">pvrvk::CommandBuffer &amp;&#160;</td>
          <td class="paramname"><em>uploadCmdBuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool &amp;&#160;</td>
          <td class="paramname"><em>requiresCommandBufferSubmission</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vma::Allocator *&#160;</td>
          <td class="paramname"><em>bufferAllocator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vma::AllocationCreateFlags&#160;</td>
          <td class="paramname"><em>vmaAllocationCreateFlags</em> = <code>vma::AllocationCreateFlags::e_MAPPED_BIT</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Auto generates a set of VBOs and a single IBO from all the vertex data of a mesh.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">device</td><td>The device where the buffers will be generated on</td></tr>
    <tr><td class="paramname">mesh</td><td>The mesh whose data will populate the buffers</td></tr>
    <tr><td class="paramname">outVbos</td><td>Reference to a std::vector of VBO handles where the data will be put. Buffers will be appended at the end.</td></tr>
    <tr><td class="paramname">outIbo</td><td>The IBO handle where the data will be put. No buffer needs to have been created on the handle. If no face data is present on the mesh, the handle will be null.</td></tr>
    <tr><td class="paramname">uploadCmdBuffer</td><td>A command buffer into which commands may be recorded for uploading mesh data to the created buffers. This command buffer will only be used when memory without e_HOST_VISIBLE_BIT memory property flags was allocated for the vbos or ibos.</td></tr>
    <tr><td class="paramname">requiresCommandBufferSubmission</td><td>Indicates whether commands have been recorded into the given command buffer.</td></tr>
    <tr><td class="paramname">bufferAllocator</td><td>A VMA allocator used to allocate memory for the created buffer.</td></tr>
    <tr><td class="paramname">vmaAllocationCreateFlags</td><td>VMA Allocation creation flags. These flags can be used to control how and where the memory is allocated from. Valid flags include e_DEDICATED_MEMORY_BIT and e_MAPPED_BIT. e_DEDICATED_MEMORY_BIT indicates that the allocation should have its own memory block. e_MAPPED_BIT indicates memory will be persistently mapped respectively. The default vma::AllocationCreateFlags::e_MAPPED_BIT is valid even if HOST_VISIBLE is not used - these flags will be ignored in this case.</td></tr>
  </table>
  </dd>
</dl>
<p>This utility function will read all vertex data from the mesh and create one pvrvk::Buffer for each data element (block of interleaved data) in the mesh. It is thus commonly used for for meshes containing multiple sets of interleaved data (for example, a VBO with static and a VBO with streaming data).</p>

</div>
</div>
<a class="anchor" id="af3c27cb705f0f371580caad44b5763be"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void pvr::utils::createOnscreenFramebufferAndRenderPass </td>
          <td>(</td>
          <td class="paramtype">pvrvk::Swapchain &amp;&#160;</td>
          <td class="paramname"><em>swapchain</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">pvrvk::ImageView *&#160;</td>
          <td class="paramname"><em>depthStencilImages</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Multi&lt; pvrvk::Framebuffer &gt; &amp;&#160;</td>
          <td class="paramname"><em>outFramebuffers</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">pvrvk::RenderPass &amp;&#160;</td>
          <td class="paramname"><em>outRenderPass</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">pvrvk::ImageLayout&#160;</td>
          <td class="paramname"><em>initialSwapchainLayout</em> = <code>pvrvk::ImageLayout::e_UNDEFINED</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">pvrvk::ImageLayout&#160;</td>
          <td class="paramname"><em>initialDepthStencilLayout</em> = <code>pvrvk::ImageLayout::e_UNDEFINED</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">pvrvk::AttachmentLoadOp&#160;</td>
          <td class="paramname"><em>colorLoadOp</em> = <code>pvrvk::AttachmentLoadOp::e_CLEAR</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">pvrvk::AttachmentStoreOp&#160;</td>
          <td class="paramname"><em>colorStoreOp</em> = <code>pvrvk::AttachmentStoreOp::e_STORE</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">pvrvk::AttachmentLoadOp&#160;</td>
          <td class="paramname"><em>depthStencilLoadOp</em> = <code>pvrvk::AttachmentLoadOp::e_CLEAR</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">pvrvk::AttachmentStoreOp&#160;</td>
          <td class="paramname"><em>depthStencilStoreOp</em> = <code>pvrvk::AttachmentStoreOp::e_DONT_CARE</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a pvrvk::Framebuffer and RenderPass to use for 'default' rendering to the 'onscreen' color images with following config RenderPass: Attachment0: ColorAttachment swapchain image, finalLayout - PresentSrcKHR LoadOp - Clear StoreOp - Store Attachment1: DepthStencilAttachment finalLayout - DepthStencilAttachmentOptimal LoadOp - Clear StoreOp - Store</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">swapchain</td><td>A pre-created swapchain object from which the device will be taken for creating the framebuffer and renderpass. The swapchain image formats and dimensions will also be taken from the swapchain.</td></tr>
    <tr><td class="paramname">depthStencilImages</td><td>A pointer to an array of pvrvk::ImageView objects corresponding to an image to use as the depth stencil image per swap chain.</td></tr>
    <tr><td class="paramname">outFramebuffers</td><td>The created framebuffers will be returned by reference as part of outFramebuffers with each framebuffer corresponding to a single swap chain.</td></tr>
    <tr><td class="paramname">outRenderPass</td><td>The created renderpass will be returned by reference.</td></tr>
    <tr><td class="paramname">initialSwapchainLayout</td><td>Initial Layouts of the swapchain image</td></tr>
    <tr><td class="paramname">initialDepthStencilLayout</td><td>Initial Layouts of the depthstencil image</td></tr>
    <tr><td class="paramname">colorLoadOp</td><td>Attachment load operation for the color attachment</td></tr>
    <tr><td class="paramname">colorStoreOp</td><td>Attachment store operation for the color attachment</td></tr>
    <tr><td class="paramname">depthStencilLoadOp</td><td>Attachment load operation for the depth stencil attachment</td></tr>
    <tr><td class="paramname">depthStencilStoreOp</td><td>Attachment store operation for the depth stencil attachment</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a800aecef7aa17bc651e2ee97b8e2c6d9"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void pvr::utils::createOnscreenFramebufferAndRenderPass </td>
          <td>(</td>
          <td class="paramtype">pvrvk::Swapchain &amp;&#160;</td>
          <td class="paramname"><em>swapchain</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">pvrvk::ImageView *&#160;</td>
          <td class="paramname"><em>depthStencilImages</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Multi&lt; pvrvk::Framebuffer &gt; &amp;&#160;</td>
          <td class="paramname"><em>outFramebuffers</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">pvrvk::ImageLayout&#160;</td>
          <td class="paramname"><em>initialSwapchainLayout</em> = <code>pvrvk::ImageLayout::e_UNDEFINED</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">pvrvk::ImageLayout&#160;</td>
          <td class="paramname"><em>initialDepthStencilLayout</em> = <code>pvrvk::ImageLayout::e_UNDEFINED</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">pvrvk::AttachmentLoadOp&#160;</td>
          <td class="paramname"><em>colorLoadOp</em> = <code>pvrvk::AttachmentLoadOp::e_CLEAR</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">pvrvk::AttachmentStoreOp&#160;</td>
          <td class="paramname"><em>colorStoreOp</em> = <code>pvrvk::AttachmentStoreOp::e_STORE</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">pvrvk::AttachmentLoadOp&#160;</td>
          <td class="paramname"><em>depthStencilLoadOp</em> = <code>pvrvk::AttachmentLoadOp::e_CLEAR</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">pvrvk::AttachmentStoreOp&#160;</td>
          <td class="paramname"><em>depthStencilStoreOp</em> = <code>pvrvk::AttachmentStoreOp::e_DONT_CARE</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a pvrvk::Framebuffer and RenderPass to use for 'default' rendering to the 'onscreen' color images with following config RenderPass: ColorAttachment0: swapchain image, finalLayout - PresentSrcKHR LoadOp - Clear StoreOp - Store DepthStencilAttachment: finalLayout - DepthStencilAttachmentOptimal LoadOp - Clear StoreOp - Store Subpass0</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">swapchain</td><td>A pre-created swapchain object from which the device will be taken for creating the framebuffer and renderpass. The swapchain image formats and dimensions will also be taken from the swapchain.</td></tr>
    <tr><td class="paramname">depthStencilImages</td><td>A pointer to an array of pvrvk::ImageView objects corresponding to an image to use as the depth stencil image per swap chain.</td></tr>
    <tr><td class="paramname">outFramebuffers</td><td>The created framebuffers will be returned by reference as part of outFramebuffers with each framebuffer corresponding to a single swap chain.</td></tr>
    <tr><td class="paramname">initialSwapchainLayout</td><td>Initial Layouts of the swapchain image</td></tr>
    <tr><td class="paramname">initialDepthStencilLayout</td><td>Initial Layouts of the depthstencil image</td></tr>
    <tr><td class="paramname">initialSwapchainLayout</td><td>Initial Layouts of the swapchain image</td></tr>
    <tr><td class="paramname">initialDepthStencilLayout</td><td>Initial Layouts of the depthstencil image</td></tr>
    <tr><td class="paramname">colorLoadOp</td><td>Attachment load operation for the color attachment</td></tr>
    <tr><td class="paramname">colorStoreOp</td><td>Attachment store operation for the color attachment</td></tr>
    <tr><td class="paramname">depthStencilLoadOp</td><td>Attachment load operation for the depth stencil attachment</td></tr>
    <tr><td class="paramname">depthStencilStoreOp</td><td>Attachment store operation for the depth stencil attachment</td></tr>
  </table>
  </dd>
</dl>
<p>The renderpass will not be returned directly but can instead be retrieved via a call to outFramebuffers[i].getRenderPass()</p>

</div>
</div>
<a class="anchor" id="a55c8c338b47c9a66f58a39feb29c9fbe"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">pvrvk::ShaderModule pvr::utils::createShaderModule </td>
          <td>(</td>
          <td class="paramtype">pvrvk::Device &amp;&#160;</td>
          <td class="paramname"><em>device</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string &amp;&#160;</td>
          <td class="paramname"><em>shaderSource</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">pvrvk::ShaderStageFlags&#160;</td>
          <td class="paramname"><em>shaderStageFlags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">pvrvk::ShaderModuleCreateFlags&#160;</td>
          <td class="paramname"><em>flags</em> = <code>pvrvk::ShaderModuleCreateFlags::e_NONE</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *const *&#160;</td>
          <td class="paramname"><em>defines</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>numDefines</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Load a ShaderModule from shader source using glslang.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">device</td><td>A device from which to create the ShaderModule</td></tr>
    <tr><td class="paramname">shaderSource</td><td>A string containing the shader source text data</td></tr>
    <tr><td class="paramname">shaderStageFlags</td><td>The type (stage) of the shader (vertex, fragment...)</td></tr>
    <tr><td class="paramname">flags</td><td>A set of pvrvk::ShaderModuleCreateFlags controlling how the ShaderModule will be created</td></tr>
    <tr><td class="paramname">defines</td><td>A number of preprocessor definitions that will be passed to the shader</td></tr>
    <tr><td class="paramname">numDefines</td><td>The number of defines</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The created ShaderModule object</dd></dl>

</div>
</div>
<a class="anchor" id="a270a77975b4db20cad82e6974a065a6d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">pvrvk::ShaderModule pvr::utils::createShaderModule </td>
          <td>(</td>
          <td class="paramtype">pvrvk::Device &amp;&#160;</td>
          <td class="paramname"><em>device</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Stream &amp;&#160;</td>
          <td class="paramname"><em>shaderSource</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">pvrvk::ShaderStageFlags&#160;</td>
          <td class="paramname"><em>shaderStageFlags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">pvrvk::ShaderModuleCreateFlags&#160;</td>
          <td class="paramname"><em>flags</em> = <code>pvrvk::ShaderModuleCreateFlags::e_NONE</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *const *&#160;</td>
          <td class="paramname"><em>defines</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>numDefines</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Load a ShaderModule from shader source using glslang.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">device</td><td>A device from which to create the ShaderModule</td></tr>
    <tr><td class="paramname">shaderSource</td><td>A stream containing the shader source text data</td></tr>
    <tr><td class="paramname">shaderStageFlags</td><td>The type (stage) of the shader (vertex, fragment...)</td></tr>
    <tr><td class="paramname">flags</td><td>A set of pvrvk::ShaderModuleCreateFlags controlling how the ShaderModule will be created</td></tr>
    <tr><td class="paramname">defines</td><td>A number of preprocessor definitions that will be passed to the shader</td></tr>
    <tr><td class="paramname">numDefines</td><td>The number of defines</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The created ShaderModule object</dd></dl>

</div>
</div>
<a class="anchor" id="af094283fa2ed1a4434130f9eaf16feb6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">GLuint pvr::utils::createShaderProgram </td>
          <td>(</td>
          <td class="paramtype">const GLuint&#160;</td>
          <td class="paramname"><em>pShaders</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>shadersCount</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char **const&#160;</td>
          <td class="paramname"><em>attribNames</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint16_t *&#160;</td>
          <td class="paramname"><em>attribIndices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>attribsCount</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string *&#160;</td>
          <td class="paramname"><em>infolog</em> = <code>NULL</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a native shader program from an array of native shader handles. Will implicitly load on the current context.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pShaders</td><td>An array of shaders</td></tr>
    <tr><td class="paramname">shadersCount</td><td>The number shaders in <em>pShaders</em> pShaders</td></tr>
    <tr><td class="paramname">attribNames</td><td>The list of names of the attributes in the shader, as a c-style array of c-style strings</td></tr>
    <tr><td class="paramname">attribIndices</td><td>The list of attribute binding indices, corresponding to <em>attribNames</em> attribNames</td></tr>
    <tr><td class="paramname">attribsCount</td><td>Number of attributes in <em>attribNames</em> attribNames and <em>attribIndices</em> attribIndices.</td></tr>
    <tr><td class="paramname">infolog</td><td>OPTIONAL Output, the infolog of the shader</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The program object</dd></dl>

</div>
</div>
<a class="anchor" id="a42a0675b91a9e04cfcf514db85a8af81"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">GLuint pvr::utils::createShaderProgram </td>
          <td>(</td>
          <td class="paramtype">IAssetProvider &amp;&#160;</td>
          <td class="paramname"><em>app</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>vertShaderFilename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>tessCtrlShaderFilename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>tessEvalShaderFilename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>geometryShaderFilename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>fragShaderFilename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char **&#160;</td>
          <td class="paramname"><em>attribNames</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint16_t *&#160;</td>
          <td class="paramname"><em>attribIndices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>numAttribs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *const *&#160;</td>
          <td class="paramname"><em>defines</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>numDefines</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a native shader program from a vertex, fragment, tessellation control, tessellation evaluation and geometry shader</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">app</td><td>An AssetProvider to use for loading shaders from memory</td></tr>
    <tr><td class="paramname">vertShaderFilename</td><td>The filename of a vertex shader</td></tr>
    <tr><td class="paramname">tessCtrlShaderFilename</td><td>The filename of a tessellation control shader</td></tr>
    <tr><td class="paramname">tessEvalShaderFilename</td><td>The filename of a tessellation evaluation shader</td></tr>
    <tr><td class="paramname">geometryShaderFilename</td><td>The filename of a geometry shader</td></tr>
    <tr><td class="paramname">fragShaderFilename</td><td>The filename of a fragment shader</td></tr>
    <tr><td class="paramname">attribNames</td><td>The list of names of the attributes in the shader, as a c-style array of c-style strings</td></tr>
    <tr><td class="paramname">attribIndices</td><td>The list of attribute binding indices, corresponding to <em>attribNames</em> attribNames</td></tr>
    <tr><td class="paramname">numAttribs</td><td>Number of attributes in <em>attribNames</em> attribNames and <em>attribIndices</em> attribIndices.</td></tr>
    <tr><td class="paramname">defines</td><td>A list of defines to be added to the shaders</td></tr>
    <tr><td class="paramname">numDefines</td><td>The number of defines to be added to the shaders</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The program object</dd></dl>

</div>
</div>
<a class="anchor" id="ad8ae577267c30e8c9ac6de425a7201cd"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">GLuint pvr::utils::createShaderProgram </td>
          <td>(</td>
          <td class="paramtype">IAssetProvider &amp;&#160;</td>
          <td class="paramname"><em>app</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>vertShaderFilename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>fragShaderFilename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char **&#160;</td>
          <td class="paramname"><em>attribNames</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint16_t *&#160;</td>
          <td class="paramname"><em>attribIndices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>numAttribs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *const *&#160;</td>
          <td class="paramname"><em>defines</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>numDefines</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a native shader program from a vertex and fragment shader</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">app</td><td>An AssetProvider to use for loading shaders from memory</td></tr>
    <tr><td class="paramname">vertShaderFilename</td><td>The filename of a vertex shader</td></tr>
    <tr><td class="paramname">fragShaderFilename</td><td>The filename of a fragment shader</td></tr>
    <tr><td class="paramname">attribNames</td><td>The list of names of the attributes in the shader, as a c-style array of c-style strings</td></tr>
    <tr><td class="paramname">attribIndices</td><td>The list of attribute binding indices, corresponding to <em>attribNames</em> attribNames</td></tr>
    <tr><td class="paramname">numAttribs</td><td>Number of attributes in <em>attribNames</em> attribNames and <em>attribIndices</em> attribIndices.</td></tr>
    <tr><td class="paramname">defines</td><td>A list of defines to be added to the shaders</td></tr>
    <tr><td class="paramname">numDefines</td><td>The number of defines to be added to the shaders</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The program object</dd></dl>

</div>
</div>
<a class="anchor" id="ae6934715b675cba2e0a7454813b431a3"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void pvr::utils::createSingleBuffersFromMesh </td>
          <td>(</td>
          <td class="paramtype">pvrvk::Device &amp;&#160;</td>
          <td class="paramname"><em>device</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const assets::Mesh &amp;&#160;</td>
          <td class="paramname"><em>mesh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">pvrvk::Buffer &amp;&#160;</td>
          <td class="paramname"><em>outVbo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">pvrvk::Buffer &amp;&#160;</td>
          <td class="paramname"><em>outIbo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">pvrvk::CommandBuffer &amp;&#160;</td>
          <td class="paramname"><em>uploadCmdBuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool &amp;&#160;</td>
          <td class="paramname"><em>requiresCommandBufferSubmission</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vma::Allocator *&#160;</td>
          <td class="paramname"><em>bufferAllocator</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vma::AllocationCreateFlags&#160;</td>
          <td class="paramname"><em>vmaAllocationCreateFlags</em> = <code>vma::AllocationCreateFlags::e_MAPPED_BIT</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Auto generates a single VBO and a single IBO from all the vertex data of a mesh.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">device</td><td>The device where the buffers will be generated on</td></tr>
    <tr><td class="paramname">mesh</td><td>The mesh whose data will populate the buffers</td></tr>
    <tr><td class="paramname">outVbo</td><td>The VBO handle where the data will be put.</td></tr>
    <tr><td class="paramname">outIbo</td><td>The IBO handle where the data will be put. If no face data is present on the mesh, the handle will be null.</td></tr>
    <tr><td class="paramname">uploadCmdBuffer</td><td>A command buffer into which commands may be recorded for uploading mesh data to the created buffers. This command buffer will only be used when memory without e_HOST_VISIBLE_BIT memory property flags was allocated for the vbos or ibos.</td></tr>
    <tr><td class="paramname">requiresCommandBufferSubmission</td><td>Indicates whether commands have been recorded into the given command buffer.</td></tr>
    <tr><td class="paramname">bufferAllocator</td><td>A VMA allocator used to allocate memory for the created buffer.</td></tr>
    <tr><td class="paramname">vmaAllocationCreateFlags</td><td>VMA Allocation creation flags. These flags can be used to control how and where the memory is allocated from. Valid flags include e_DEDICATED_MEMORY_BIT and e_MAPPED_BIT. e_DEDICATED_MEMORY_BIT indicates that the allocation should have its own memory block. e_MAPPED_BIT indicates memory will be persistently mapped respectively. The default vma::AllocationCreateFlags::e_MAPPED_BIT is valid even if HOST_VISIBLE is not used - these flags will be ignored in this case.</td></tr>
  </table>
  </dd>
</dl>
<p>This utility function will read all vertex data from a mesh's data elements and create a single VBO. It is commonly used for a single set of interleaved data. If data are not interleaved, they will be packed on the same VBO, each interleaved block (Data element on the mesh) will be appended at the end of the buffer, and the offsets will need to be calculated by the user when binding the buffer.</p>

</div>
</div>
<a class="anchor" id="a06f94be9a865755c8bafaac56f286b01"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MeshIterator_ , typename VboInsertIterator_ , typename IboInsertIterator_ &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void pvr::utils::createSingleBuffersFromMeshes </td>
          <td>(</td>
          <td class="paramtype">pvrvk::Device &amp;&#160;</td>
          <td class="paramname"><em>device</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MeshIterator_&#160;</td>
          <td class="paramname"><em>meshIter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MeshIterator_&#160;</td>
          <td class="paramname"><em>meshIterEnd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VboInsertIterator_&#160;</td>
          <td class="paramname"><em>outVbos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IboInsertIterator_&#160;</td>
          <td class="paramname"><em>outIbos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">pvrvk::CommandBuffer &amp;&#160;</td>
          <td class="paramname"><em>uploadCmdBuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool &amp;&#160;</td>
          <td class="paramname"><em>requiresCommandBufferSubmission</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vma::Allocator *&#160;</td>
          <td class="paramname"><em>bufferAllocator</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vma::AllocationCreateFlags&#160;</td>
          <td class="paramname"><em>vmaAllocationCreateFlags</em> = <code>vma::AllocationCreateFlags::e_MAPPED_BIT</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Auto generates a set of VBOs and a set of IBOs from the vertex data of multiple meshes and uses std::inserter provided by the user to insert them to any container.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">device</td><td>The device where the buffers will be generated on</td></tr>
    <tr><td class="paramname">meshIter</td><td>Iterator for a collection of meshes.</td></tr>
    <tr><td class="paramname">meshIterEnd</td><td>End Iterator for meshIter.</td></tr>
    <tr><td class="paramname">outVbos</td><td>std::inserter for a collection of pvrvk::Buffer handles. It will be used to insert one VBO per mesh.</td></tr>
    <tr><td class="paramname">outIbos</td><td>std::inserter for a collection of pvrvk::Buffer handles. It will be used to insert one IBO per mesh. If face data is not present on the mesh, a null handle will be inserted.</td></tr>
    <tr><td class="paramname">uploadCmdBuffer</td><td>A command buffer into which commands may be recorded for uploading mesh data to the created buffers. This command buffer will only be used when memory without e_HOST_VISIBLE_BIT memory property flags was allocated for the vbos or ibos.</td></tr>
    <tr><td class="paramname">requiresCommandBufferSubmission</td><td>Indicates whether commands have been recorded into the given command buffer.</td></tr>
    <tr><td class="paramname">bufferAllocator</td><td>A VMA allocator used to allocate memory for the created buffer.</td></tr>
    <tr><td class="paramname">vmaAllocationCreateFlags</td><td>VMA Allocation creation flags. These flags can be used to control how and where the memory is allocated from. Valid flags include e_DEDICATED_MEMORY_BIT and e_MAPPED_BIT. e_DEDICATED_MEMORY_BIT indicates that the allocation should have its own memory block. e_MAPPED_BIT indicates memory will be persistently mapped respectively. The default vma::AllocationCreateFlags::e_MAPPED_BIT is valid even if HOST_VISIBLE is not used - these flags will be ignored in this case.</td></tr>
  </table>
  </dd>
</dl>
<p>This utility function will read all vertex data from a mesh's data elements and create a single VBO. It is commonly used for a single set of interleaved data (mesh.getNumDataElements() == 1). If more data elements are present (i.e. more than a single interleaved data element) , they will be packed in the sameVBO, with each interleaved block (Data element ) appended at the end of the buffer. It is then the user's responsibility to use the buffer correctly with the API (for example use bindbufferbase and similar) with the correct offsets. The std::inserter this function requires can be created from any container with an insert() function with (for example, for insertion at the end of a vector) std::inserter(std::vector, std::vector::end()) .</p>

</div>
</div>
<a class="anchor" id="a4493b0c69e45e8b7af4d2fa32f763f23"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MeshIterator_ , typename VboContainer_ , typename IboContainer_ &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void pvr::utils::createSingleBuffersFromMeshes </td>
          <td>(</td>
          <td class="paramtype">pvrvk::Device &amp;&#160;</td>
          <td class="paramname"><em>device</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MeshIterator_&#160;</td>
          <td class="paramname"><em>meshIter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MeshIterator_&#160;</td>
          <td class="paramname"><em>meshIterEnd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VboContainer_ &amp;&#160;</td>
          <td class="paramname"><em>outVbos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename VboContainer_::iterator&#160;</td>
          <td class="paramname"><em>vbos_where</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IboContainer_ &amp;&#160;</td>
          <td class="paramname"><em>outIbos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename IboContainer_::iterator&#160;</td>
          <td class="paramname"><em>ibos_where</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">pvrvk::CommandBuffer &amp;&#160;</td>
          <td class="paramname"><em>uploadCmdBuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool &amp;&#160;</td>
          <td class="paramname"><em>requiresCommandBufferSubmission</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vma::Allocator *&#160;</td>
          <td class="paramname"><em>bufferAllocator</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vma::AllocationCreateFlags&#160;</td>
          <td class="paramname"><em>vmaAllocationCreateFlags</em> = <code>vma::AllocationCreateFlags::e_MAPPED_BIT</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Auto generates a set of VBOs and a set of IBOs from the vertex data of multiple meshes and insert them at the specified spot in a user-provided container.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">device</td><td>The device where the buffers will be generated on</td></tr>
    <tr><td class="paramname">meshIter</td><td>Iterator for a collection of meshes.</td></tr>
    <tr><td class="paramname">meshIterEnd</td><td>End Iterator for meshIter.</td></tr>
    <tr><td class="paramname">outVbos</td><td>Collection of pvrvk::Buffer handles. It will be used to insert one VBO per mesh.</td></tr>
    <tr><td class="paramname">outIbos</td><td>Collection of pvrvk::Buffer handles. It will be used to insert one IBO per mesh. If face data is not present on the mesh, a null handle will be inserted.</td></tr>
    <tr><td class="paramname">vbos_where</td><td>Iterator on outVbos - the position where the insertion will happen.</td></tr>
    <tr><td class="paramname">ibos_where</td><td>Iterator on outIbos - the position where the insertion will happen.</td></tr>
    <tr><td class="paramname">uploadCmdBuffer</td><td>A command buffer into which commands may be recorded for uploading mesh data to the created buffers. This command buffer will only be used when memory without e_HOST_VISIBLE_BIT memory property flags was allocated for the vbos or ibos.</td></tr>
    <tr><td class="paramname">requiresCommandBufferSubmission</td><td>Indicates whether commands have been recorded into the given command buffer.</td></tr>
    <tr><td class="paramname">bufferAllocator</td><td>A VMA allocator used to allocate memory for the created buffer.</td></tr>
    <tr><td class="paramname">vmaAllocationCreateFlags</td><td>VMA Allocation creation flags. These flags can be used to control how and where the memory is allocated from. Valid flags include e_DEDICATED_MEMORY_BIT and e_MAPPED_BIT. e_DEDICATED_MEMORY_BIT indicates that the allocation should have its own memory block. e_MAPPED_BIT indicates memory will be persistently mapped respectively. The default vma::AllocationCreateFlags::e_MAPPED_BIT is valid even if HOST_VISIBLE is not used - these flags will be ignored in this case.</td></tr>
  </table>
  </dd>
</dl>
<p>This utility function will read all vertex data from a mesh's data elements and create a single VBO. It is commonly used for a single set of interleaved data (mesh.getNumDataElements() == 1). If more data elements are present (i.e. more than a single interleaved data element) , they will be packed in the sameVBO, with each interleaved block (Data element ) appended at the end of the buffer. It is then the user's responsibility to use the buffer correctly with the API (for example use bindbufferbase and similar) with the correct offsets.</p>

</div>
</div>
<a class="anchor" id="a8b77d306417876f431ed11fffde3a84f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VboInsertIterator_ , typename IboInsertIterator_ &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void pvr::utils::createSingleBuffersFromModel </td>
          <td>(</td>
          <td class="paramtype">pvrvk::Device &amp;&#160;</td>
          <td class="paramname"><em>device</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const assets::Model &amp;&#160;</td>
          <td class="paramname"><em>model</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VboInsertIterator_&#160;</td>
          <td class="paramname"><em>vbos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IboInsertIterator_&#160;</td>
          <td class="paramname"><em>ibos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">pvrvk::CommandBuffer &amp;&#160;</td>
          <td class="paramname"><em>uploadCmdBuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool &amp;&#160;</td>
          <td class="paramname"><em>requiresCommandBufferSubmission</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vma::Allocator *&#160;</td>
          <td class="paramname"><em>bufferAllocator</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vma::AllocationCreateFlags&#160;</td>
          <td class="paramname"><em>vmaAllocationCreateFlags</em> = <code>vma::AllocationCreateFlags::e_MAPPED_BIT</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Auto generates a set of VBOs and a set of IBOs from the vertex data of the meshes of a model and inserts them into containers provided by the user using std::inserters.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">device</td><td>The device device where the buffers will be generated on</td></tr>
    <tr><td class="paramname">model</td><td>The model whose meshes will be used to generate the Buffers</td></tr>
    <tr><td class="paramname">vbos</td><td>An insert iterator to a std::pvrvk::Buffer container for the VBOs. Vbos will be inserted using this iterator.</td></tr>
    <tr><td class="paramname">ibos</td><td>An insert iterator to an std::pvrvk::Buffer container for the IBOs. Ibos will be inserted using this iterator.</td></tr>
    <tr><td class="paramname">uploadCmdBuffer</td><td>A command buffer into which commands may be recorded for uploading mesh data to the created buffers. This command buffer will only be used when memory without e_HOST_VISIBLE_BIT memory property flags was allocated for the vbos or ibos.</td></tr>
    <tr><td class="paramname">requiresCommandBufferSubmission</td><td>Indicates whether commands have been recorded into the given command buffer.</td></tr>
    <tr><td class="paramname">bufferAllocator</td><td>A VMA allocator used to allocate memory for the created buffer.</td></tr>
    <tr><td class="paramname">vmaAllocationCreateFlags</td><td>VMA Allocation creation flags. These flags can be used to control how and where the memory is allocated from. Valid flags include e_DEDICATED_MEMORY_BIT and e_MAPPED_BIT. e_DEDICATED_MEMORY_BIT indicates that the allocation should have its own memory block. e_MAPPED_BIT indicates memory will be persistently mapped respectively. The default vma::AllocationCreateFlags::e_MAPPED_BIT is valid even if HOST_VISIBLE is not used - these flags will be ignored in this case.</td></tr>
  </table>
  </dd>
</dl>
<p>This utility function will read all vertex data from the VBO. It is usually preferred for meshes meshes containing a single set of interleaved data. If multiple data elements (i.e. sets of interleaved data), each block will be successively placed after the other. The std::inserter this function requires can be created from any container with an insert() function with (for example, for insertion at the end of a vector) std::inserter(std::vector, std::vector::end()) .</p>

</div>
</div>
<a class="anchor" id="aa583027696be258fc78dd3156ffaece5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">pvrvk::Surface pvr::utils::createSurface </td>
          <td>(</td>
          <td class="paramtype">pvrvk::Instance &amp;&#160;</td>
          <td class="paramname"><em>instance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">pvrvk::PhysicalDevice &amp;&#160;</td>
          <td class="paramname"><em>physicalDevice</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>window</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>display</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates an abstract vulkan native platform surface.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">instance</td><td>The instance from which to create the native platform surface.</td></tr>
    <tr><td class="paramname">physicalDevice</td><td>A physical device from which to create the native platform surface.</td></tr>
    <tr><td class="paramname">window</td><td>A pointer to a NativeWindow used to create the windowing surface.</td></tr>
    <tr><td class="paramname">display</td><td>A pointer to a NativeDisplay used to create the windowing surface.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to an abstract vulkan native platform surface.</dd></dl>

</div>
</div>
<a class="anchor" id="a3d992b548d4b9d5617bc2766f1dbdda9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">pvrvk::Swapchain pvr::utils::createSwapchain </td>
          <td>(</td>
          <td class="paramtype">pvrvk::Device &amp;&#160;</td>
          <td class="paramname"><em>device</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const pvrvk::Surface &amp;&#160;</td>
          <td class="paramname"><em>surface</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">pvr::DisplayAttributes &amp;&#160;</td>
          <td class="paramname"><em>displayAttributes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; pvrvk::Format &gt; &amp;&#160;</td>
          <td class="paramname"><em>preferredColorFormats</em> = <code>std::vector&lt;&#160;pvrvk::Format&#160;&gt;()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">pvrvk::ImageUsageFlags&#160;</td>
          <td class="paramname"><em>swapchainImageUsageFlags</em> = <code>pvrvk::ImageUsageFlags::e_COLOR_ATTACHMENT_BIT</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a pvrvk::Swapchain using a pre-initialised pvrvk::Device and pvrvk::Surface choosing the color format of the swapchain images created from the specified list of preferred color formats.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">device</td><td>A logical device to use for creating the pvrvk::Swapchain.</td></tr>
    <tr><td class="paramname">surface</td><td>A pvrvk::Surface from which surface capabilities, supported formats and presentation modes will be derived.</td></tr>
    <tr><td class="paramname">displayAttributes</td><td>A set of display attributes from which certain properties will be taken such as width, height, vsync mode and preferences for the number of pixels per channel.</td></tr>
    <tr><td class="paramname">preferredColorFormats</td><td>A list of preferred color formats from which the pvrvk::Swapchain color image format will be taken. Note that this list must be exhaustive as if none are supported then no pvrvk::Swapchain will be created.</td></tr>
    <tr><td class="paramname">swapchainImageUsageFlags</td><td>Specifies for what the swapchain images can be used for.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Return the created pvrvk::Swapchain</dd></dl>

</div>
</div>
<a class="anchor" id="acb02e95824004b5bf3b80049ec0a3e40"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">pvrvk::Swapchain pvr::utils::createSwapchain </td>
          <td>(</td>
          <td class="paramtype">pvrvk::Device &amp;&#160;</td>
          <td class="paramname"><em>device</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const pvrvk::Surface &amp;&#160;</td>
          <td class="paramname"><em>surface</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">pvr::DisplayAttributes &amp;&#160;</td>
          <td class="paramname"><em>displayAttributes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">pvrvk::ImageUsageFlags&#160;</td>
          <td class="paramname"><em>swapchainImageUsageFlags</em> = <code>pvrvk::ImageUsageFlags::e_COLOR_ATTACHMENT_BIT</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a pvrvk::Swapchain using a pre-initialised pvrvk::Device and pvrvk::Surface.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">device</td><td>A logical device to use for creating the pvrvk::Swapchain.</td></tr>
    <tr><td class="paramname">surface</td><td>A pvrvk::Surface from which surface capabilities, supported formats and presentation modes will be derived.</td></tr>
    <tr><td class="paramname">displayAttributes</td><td>A set of display attributes from which certain properties will be taken such as width, height, vsync mode and preferences for the number of pixels per channel.</td></tr>
    <tr><td class="paramname">swapchainImageUsageFlags</td><td>Specifies for what the swapchain images can be used for.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Return the created pvrvk::Swapchain</dd></dl>

</div>
</div>
<a class="anchor" id="a391224081fe950b01072c76a7a33fbac"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pvr::utils::createSwapchainAndDepthStencilImageAndViews </td>
          <td>(</td>
          <td class="paramtype">pvrvk::Device &amp;&#160;</td>
          <td class="paramname"><em>device</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const pvrvk::Surface &amp;&#160;</td>
          <td class="paramname"><em>surface</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">pvr::DisplayAttributes &amp;&#160;</td>
          <td class="paramname"><em>displayAttributes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">pvrvk::Swapchain &amp;&#160;</td>
          <td class="paramname"><em>outSwapchain</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Multi&lt; pvrvk::ImageView &gt; &amp;&#160;</td>
          <td class="paramname"><em>outDepthStencilImages</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; pvrvk::Format &gt; &amp;&#160;</td>
          <td class="paramname"><em>preferredColorFormats</em> = <code>std::vector&lt;&#160;pvrvk::Format&#160;&gt;()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; pvrvk::Format &gt; &amp;&#160;</td>
          <td class="paramname"><em>preferredDepthStencilFormats</em> = <code>std::vector&lt;&#160;pvrvk::Format&#160;&gt;()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const pvrvk::ImageUsageFlags &amp;&#160;</td>
          <td class="paramname"><em>swapchainImageUsageFlags</em> = <code>pvrvk::ImageUsageFlags::e_COLOR_ATTACHMENT_BIT</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const pvrvk::ImageUsageFlags &amp;&#160;</td>
          <td class="paramname"><em>dsImageUsageFlags</em> = <code>pvrvk::ImageUsageFlags::e_DEPTH_STENCIL_ATTACHMENT_BIT|pvrvk::ImageUsageFlags::e_TRANSIENT_ATTACHMENT_BIT</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vma::Allocator *&#160;</td>
          <td class="paramname"><em>dsImageAllocator</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vma::AllocationCreateFlags&#160;</td>
          <td class="paramname"><em>dsImageAllocationCreateFlags</em> = <code>vma::AllocationCreateFlags::e_DEDICATED_MEMORY_BIT</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a pvrvk::Swapchain and corresponding number of depth stencil images using a pre-initialised pvrvk::Device and pvrvk::Surface choosing the color and depth stencil format of the images created from the specified list of preferred color and depth stencil formats.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">device</td><td>A logical device to use for creating the pvrvk::Swapchain and depth stencil images.</td></tr>
    <tr><td class="paramname">surface</td><td>A pvrvk::Surface from which surface capabilities, supported formats and presentation modes will be derived.</td></tr>
    <tr><td class="paramname">displayAttributes</td><td>A set of display attributes from which certain properties will be taken such as width, height, vsync mode and preferences for the number of pixels per channel.</td></tr>
    <tr><td class="paramname">outSwapchain</td><td>The created swapchain will be returned by reference.</td></tr>
    <tr><td class="paramname">outDepthStencilImages</td><td>A Multi&lt;pvrvk::ImageView&gt; containing the created depth stencil images. This <a class="el" href="classpvr_1_1_multi.html" title="A small statically allocated array This class represents a small array of items. The array is statica...">Multi</a> will have size equal to the number of swapchain images.</td></tr>
    <tr><td class="paramname">preferredColorFormats</td><td>A list of preferred color formats from which the pvrvk::Swapchain color image format will be taken. Note that this list must be exhaustive as if none are supported then no pvrvk::Swapchain will be created.</td></tr>
    <tr><td class="paramname">preferredDepthStencilFormats</td><td>A list of preferred depth stencil formats from which the depth stencil image format will be taken. Note that this list must be exhaustive as if none are supported then no depth stencil images will be created.</td></tr>
    <tr><td class="paramname">swapchainImageUsageFlags</td><td>Specifies for what the swapchain images can be used for.</td></tr>
    <tr><td class="paramname">dsImageUsageFlags</td><td>Specifies for what the depth stencil images can be used for.</td></tr>
    <tr><td class="paramname">dsImageAllocator</td><td>A VMA allocator used to allocate memory for the created image.</td></tr>
    <tr><td class="paramname">dsImageAllocationCreateFlags</td><td>VMA Allocation creation flags. These flags can be used to control how and where the memory is allocated from. Valid flags include e_DEDICATED_MEMORY_BIT and e_MAPPED_BIT. e_DEDICATED_MEMORY_BIT indicates that the allocation should have its own memory block. e_MAPPED_BIT indicates memory will be persistently mapped respectively.</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="afb4cbed57981943e18958f5d6708caac"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pvr::utils::createSwapchainAndDepthStencilImageAndViews </td>
          <td>(</td>
          <td class="paramtype">pvrvk::Device &amp;&#160;</td>
          <td class="paramname"><em>device</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const pvrvk::Surface &amp;&#160;</td>
          <td class="paramname"><em>surface</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">pvr::DisplayAttributes &amp;&#160;</td>
          <td class="paramname"><em>displayAttributes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">pvrvk::Swapchain &amp;&#160;</td>
          <td class="paramname"><em>outSwapchain</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Multi&lt; pvrvk::ImageView &gt; &amp;&#160;</td>
          <td class="paramname"><em>outDepthStencilImages</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const pvrvk::ImageUsageFlags &amp;&#160;</td>
          <td class="paramname"><em>swapchainImageUsageFlags</em> = <code>pvrvk::ImageUsageFlags::e_COLOR_ATTACHMENT_BIT</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const pvrvk::ImageUsageFlags &amp;&#160;</td>
          <td class="paramname"><em>dsImageUsageFlags</em> = <code>pvrvk::ImageUsageFlags::e_DEPTH_STENCIL_ATTACHMENT_BIT|pvrvk::ImageUsageFlags::e_TRANSIENT_ATTACHMENT_BIT</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vma::Allocator *&#160;</td>
          <td class="paramname"><em>dsImageAllocator</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vma::AllocationCreateFlags&#160;</td>
          <td class="paramname"><em>dsImageAllocationCreateFlags</em> = <code>vma::AllocationCreateFlags::e_DEDICATED_MEMORY_BIT</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a pvrvk::Swapchain and corresponding number of depth stencil images using a pre-initialised pvrvk::Device and pvrvk::Surface.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">device</td><td>A logical device to use for creating the pvrvk::Swapchain.</td></tr>
    <tr><td class="paramname">surface</td><td>A pvrvk::Surface from which surface capabilities, supported formats and presentation modes will be derived.</td></tr>
    <tr><td class="paramname">displayAttributes</td><td>A set of display attributes from which certain properties will be taken such as width, height, vsync mode and preferences for the number of pixels per channel.</td></tr>
    <tr><td class="paramname">outSwapchain</td><td>The created swapchain will be returned by reference.</td></tr>
    <tr><td class="paramname">outDepthStencilImages</td><td>A Multi&lt;pvrvk::ImageView&gt; containing the created depth stencil images. This <a class="el" href="classpvr_1_1_multi.html" title="A small statically allocated array This class represents a small array of items. The array is statica...">Multi</a> will have size equal to the number of swapchain images.</td></tr>
    <tr><td class="paramname">swapchainImageUsageFlags</td><td>Specifies for what the swapchain images can be used for.</td></tr>
    <tr><td class="paramname">dsImageUsageFlags</td><td>Specifies for what the depth stencil images can be used for.</td></tr>
    <tr><td class="paramname">dsImageAllocator</td><td>A VMA allocator used to allocate memory for the created image.</td></tr>
    <tr><td class="paramname">dsImageAllocationCreateFlags</td><td>VMA Allocation creation flags. These flags can be used to control how and where the memory is allocated from. Valid flags include e_DEDICATED_MEMORY_BIT and e_MAPPED_BIT. e_DEDICATED_MEMORY_BIT indicates that the allocation should have its own memory block. e_MAPPED_BIT indicates memory will be persistently mapped respectively.</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a12e6adce5bcec23564fd67553c9f4088"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void pvr::utils::endCommandBufferDebugLabel </td>
          <td>(</td>
          <td class="paramtype">pvrvk::CommandBufferBase&#160;</td>
          <td class="paramname"><em>commandBufferBase</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Ends a label region of work submitted to this base command buffer.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">commandBufferBase</td><td>The command buffer base to which the debug label region should be ended</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a2da693f264b2b719a77fc84bf0a32ec5"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void pvr::utils::endCommandBufferDebugLabel </td>
          <td>(</td>
          <td class="paramtype">pvrvk::CommandBuffer &amp;&#160;</td>
          <td class="paramname"><em>commandBuffer</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Ends a label region of work submitted to this command buffer.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">commandBuffer</td><td>The command buffer to which the debug label region should be ended</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="adee1c88c7937b7a16127e810b75b2ab7"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void pvr::utils::endCommandBufferDebugLabel </td>
          <td>(</td>
          <td class="paramtype">pvrvk::SecondaryCommandBuffer &amp;&#160;</td>
          <td class="paramname"><em>secondaryCommandBuffer</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Ends a label region of work submitted to this secondary command buffer.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">secondaryCommandBuffer</td><td>The secondary command buffer to which the debug label region should be ended</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a605300322093e44b7cd509533f14b4fa"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void pvr::utils::endQueueDebugLabel </td>
          <td>(</td>
          <td class="paramtype">pvrvk::Queue&#160;</td>
          <td class="paramname"><em>queue</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Ends a label region of work submitted to this queue.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">queue</td><td>The queue to which the debug label region should be ended</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a12bdf9f718d984f14166f6b91b254b4c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">pvr::Texture pvr::utils::generateCookTorranceBRDFLUT </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>mapDim</em> = <code>256</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Generates BRDF lookup table image.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mapDim</td><td>Out put image size. Default 256</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A generated texture containing a Cook Torrance BRDF Lookup table</dd></dl>

</div>
</div>
<a class="anchor" id="af47a86d6668e712e353dd8aea5e984c2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pvr::utils::generateIrradianceMap </td>
          <td>(</td>
          <td class="paramtype">GLuint&#160;</td>
          <td class="paramname"><em>environmentMap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">pvr::Texture &amp;&#160;</td>
          <td class="paramname"><em>outTexture</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">GLuint &amp;&#160;</td>
          <td class="paramname"><em>outTextureGles</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>mapSize</em> = <code>64</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>mapNumSamples</em> = <code>128</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generates a mipmapped diffuse irradiance map.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">environmentMap</td><td>The OpenGL ES texture to use as the source for the diffuse irradiance map.</td></tr>
    <tr><td class="paramname">outTexture</td><td>a pvr::Texture to use for the output diffuse irradiance map.</td></tr>
    <tr><td class="paramname">outTextureGles</td><td>An OpenGL ES texture to use as the output for the diffuse irradiance map.</td></tr>
    <tr><td class="paramname">mapSize</td><td>The size of the prefiltered environment map</td></tr>
    <tr><td class="paramname">mapNumSamples</td><td>The number of samples to use when generating the diffuse irradiance map</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ab24c4e93b0c93756506ebd6f2ca1b399"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Texture pvr::utils::generateIrradianceMap </td>
          <td>(</td>
          <td class="paramtype">pvrvk::Queue&#160;</td>
          <td class="paramname"><em>queue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">pvrvk::ImageView&#160;</td>
          <td class="paramname"><em>environmentMap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">pvr::PixelFormat&#160;</td>
          <td class="paramname"><em>outputPixelFormat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">pvr::VariableType&#160;</td>
          <td class="paramname"><em>outputVariableType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>mapSize</em> = <code>64</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>mapNumSamples</em> = <code>16384</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generates a mipmapped diffuse irradiance map.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">queue</td><td>A queue to which command buffers containing commands for generating the diffuse irradiance map will be added.</td></tr>
    <tr><td class="paramname">environmentMap</td><td>The source environment map to use in the generation</td></tr>
    <tr><td class="paramname">outputPixelFormat</td><td>The format to use for the diffuse irradiance map generated using this function.</td></tr>
    <tr><td class="paramname">outputVariableType</td><td>The variable type to use for the generated irradiance map generated using this function.</td></tr>
    <tr><td class="paramname">mapSize</td><td>The size of the map to generate</td></tr>
    <tr><td class="paramname">mapNumSamples</td><td>The number of samples to use when generating the diffuse irradiance map</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The pvr::Texture generated</dd></dl>

</div>
</div>
<a class="anchor" id="a8b892efb9cd1baa5753d0d180a2d3d94"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Texture pvr::utils::generatePreFilteredMapMipmapStyle </td>
          <td>(</td>
          <td class="paramtype">pvrvk::Queue&#160;</td>
          <td class="paramname"><em>queue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">pvrvk::ImageView&#160;</td>
          <td class="paramname"><em>environmentMap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">pvr::PixelFormat&#160;</td>
          <td class="paramname"><em>outputPixelFormat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">pvr::VariableType&#160;</td>
          <td class="paramname"><em>outputVariableType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>mapSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>zeroRoughnessIsExternal</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>numMipLevelsToDiscard</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>mapNumSamples</em> = <code>65536</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generate specular irradiance map. Each level of the specular mip map gets blurred corresponding to a roughness value from 0 to 1.0.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">queue</td><td>A queue to which command buffers containing commands for generating the diffuse irradiance map will be added.</td></tr>
    <tr><td class="paramname">environmentMap</td><td>The source environment map to use in the generation</td></tr>
    <tr><td class="paramname">outputPixelFormat</td><td>The format to use for the diffuse irradiance map generated using this function.</td></tr>
    <tr><td class="paramname">outputVariableType</td><td>The variable type to use for the generated irradiance map generated using this function</td></tr>
    <tr><td class="paramname">mapSize</td><td>The size of the map to generate</td></tr>
    <tr><td class="paramname">zeroRoughnessIsExternal</td><td>Denotes that the source environment map itself will be used for the prefiltered environment map mip map level corresponding to a roughness of 0.</td></tr>
    <tr><td class="paramname">numMipLevelsToDiscard</td><td>Denotes the number of mip map levels to discard from the bottom of the chain. Generally using the last n mip maps may introduce artifacts.</td></tr>
    <tr><td class="paramname">mapNumSamples</td><td>The number of samples to use when generating the prefiltered environment map</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The pvr::Texture generated</dd></dl>

</div>
</div>
<a class="anchor" id="afc8a7f6f6edde3ee63bffd29af44b0e8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pvr::utils::generatePreFilteredMapMipMapStyle </td>
          <td>(</td>
          <td class="paramtype">GLuint&#160;</td>
          <td class="paramname"><em>environmentMap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">pvr::Texture &amp;&#160;</td>
          <td class="paramname"><em>outTexture</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">GLuint &amp;&#160;</td>
          <td class="paramname"><em>outTextureGles</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>mapSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>zeroRoughnessIsExternal</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>numMipLevelsToDiscard</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>mapNumSamples</em> = <code>65536</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generate specular irradiance map. Each level of the specular mip map gets blurred corresponding to a roughness value from 0 to 1.0.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">environmentMap</td><td>The OpenGL ES texture to use as the source for the prefiltered environment map.</td></tr>
    <tr><td class="paramname">outTexture</td><td>a pvr::Texture to use for the output prefiltered environment map.</td></tr>
    <tr><td class="paramname">outTextureGles</td><td>An OpenGL ES texture to use as the output for the prefiltered environment map.</td></tr>
    <tr><td class="paramname">mapSize</td><td>The size of the prefiltered environment map</td></tr>
    <tr><td class="paramname">zeroRoughnessIsExternal</td><td>Denotes that the source environment map itself will be used for the prefiltered environment map mip map level corresponding to a roughness of 0.</td></tr>
    <tr><td class="paramname">numMipLevelsToDiscard</td><td>Denotes the number of mip map levels to discard from the bottom of the chain. Generally using the last n mip maps may introduce artifacts.</td></tr>
    <tr><td class="paramname">mapNumSamples</td><td>The number of samples to use when generating the prefiltered environment map</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a5d3d1522b9db9f69b91090f918ccc8c0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pvr::utils::generateTextureAtlas </td>
          <td>(</td>
          <td class="paramtype">pvrvk::Device &amp;&#160;</td>
          <td class="paramname"><em>device</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const pvrvk::Image *&#160;</td>
          <td class="paramname"><em>inputImages</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">pvrvk::Rect2Df *&#160;</td>
          <td class="paramname"><em>outUVs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>numImages</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">pvrvk::ImageLayout&#160;</td>
          <td class="paramname"><em>inputImageLayout</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">pvrvk::ImageView *&#160;</td>
          <td class="paramname"><em>outImageView</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TextureHeader *&#160;</td>
          <td class="paramname"><em>outDescriptor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">pvrvk::CommandBufferBase&#160;</td>
          <td class="paramname"><em>cmdBuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">pvrvk::ImageLayout&#160;</td>
          <td class="paramname"><em>finalLayout</em> = <code>pvrvk::ImageLayout::e_SHADER_READ_ONLY_OPTIMAL</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vma::Allocator *&#160;</td>
          <td class="paramname"><em>imageAllocator</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vma::AllocationCreateFlags&#160;</td>
          <td class="paramname"><em>imageAllocationCreateFlags</em> = <code>vma::AllocationCreateFlags::e_NONE</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Utility function for generating a texture atlas based on a set of images.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">device</td><td>The device used to create the texture atlas.</td></tr>
    <tr><td class="paramname">inputImages</td><td>A list of input images used to generate the texture atlas from.</td></tr>
    <tr><td class="paramname">outUVs</td><td>A pointer to a set of UVs corresponding to the position of the images within the generated texture atlas.</td></tr>
    <tr><td class="paramname">numImages</td><td>The number of textures used for generating the texture atlas.</td></tr>
    <tr><td class="paramname">inputImageLayout</td><td>The current layout of the input images. All input images must be in the layout specified.</td></tr>
    <tr><td class="paramname">outImageView</td><td>The generated texture atlas returned by the function</td></tr>
    <tr><td class="paramname">outDescriptor</td><td>The texture header for the generated texture atlas</td></tr>
    <tr><td class="paramname">cmdBuffer</td><td>A previously constructured command buffer which will be used by the utility function for various operations such as creating images.</td></tr>
    <tr><td class="paramname">finalLayout</td><td>The final image layout the image will be transitioned to.</td></tr>
    <tr><td class="paramname">imageAllocator</td><td>A VMA allocator used to allocate memory for the created image.</td></tr>
    <tr><td class="paramname">imageAllocationCreateFlags</td><td>VMA Allocation creation flags. These flags can be used to control how and where the memory is allocated from. Valid flags include e_DEDICATED_MEMORY_BIT and e_MAPPED_BIT. e_DEDICATED_MEMORY_BIT indicates that the allocation should have its own memory block. e_MAPPED_BIT indicates memory will be persistently mapped respectively.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Return true if success</dd></dl>

</div>
</div>
<a class="anchor" id="a56ce1f5bcf625224715988176c3519a2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pvr::utils::getColorBits </td>
          <td>(</td>
          <td class="paramtype">pvrvk::Format&#160;</td>
          <td class="paramname"><em>format</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t &amp;&#160;</td>
          <td class="paramname"><em>redBits</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t &amp;&#160;</td>
          <td class="paramname"><em>greenBits</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t &amp;&#160;</td>
          <td class="paramname"><em>blueBits</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t &amp;&#160;</td>
          <td class="paramname"><em>alphaBits</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determines the number of color bits per pixel for the given pvrvk::Format.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">format</td><td>A format to calculate the number of bits for</td></tr>
    <tr><td class="paramname">redBits</td><td>The number of red bits per pixel</td></tr>
    <tr><td class="paramname">greenBits</td><td>The number of green bits per pixel</td></tr>
    <tr><td class="paramname">blueBits</td><td>The number of blue bits per pixel</td></tr>
    <tr><td class="paramname">alphaBits</td><td>The number of alpha channel bits per pixel</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a1bcac1e9af1869244329d12c291200a5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pvr::utils::getDepthStencilBits </td>
          <td>(</td>
          <td class="paramtype">pvrvk::Format&#160;</td>
          <td class="paramname"><em>format</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t &amp;&#160;</td>
          <td class="paramname"><em>depthBits</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t &amp;&#160;</td>
          <td class="paramname"><em>stencilBits</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determines the number of depth and stencil bits per pixel for the given pvrvk::Format.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">format</td><td>A format to calculate the number of bits for</td></tr>
    <tr><td class="paramname">depthBits</td><td>The number of depth bits per pixel</td></tr>
    <tr><td class="paramname">stencilBits</td><td>The number of stencil bits per pixel</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a811320035b806bb4e727d9ffc7f68873"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char* pvr::utils::getGlErrorString </td>
          <td>(</td>
          <td class="paramtype">GLuint&#160;</td>
          <td class="paramname"><em>apiError</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieves a string representation of an OpenGLES error code.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">apiError</td><td>The OpenGLES error code to stringify.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The string representation of the given OpenGLES error code.</dd></dl>

</div>
</div>
<a class="anchor" id="a6bbf98fde377992e9e7e0d23f38a9dcc"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pvr::utils::getMemoryTypeIndex </td>
          <td>(</td>
          <td class="paramtype">const pvrvk::PhysicalDevice &amp;&#160;</td>
          <td class="paramname"><em>physicalDevice</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint32_t&#160;</td>
          <td class="paramname"><em>allowedMemoryTypeBits</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const pvrvk::MemoryPropertyFlags&#160;</td>
          <td class="paramname"><em>requiredMemoryProperties</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const pvrvk::MemoryPropertyFlags&#160;</td>
          <td class="paramname"><em>optimalMemoryProperties</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t &amp;&#160;</td>
          <td class="paramname"><em>outMemoryTypeIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">pvrvk::MemoryPropertyFlags &amp;&#160;</td>
          <td class="paramname"><em>outMemoryPropertyFlags</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Utility function for retrieving a memory type index for a suitable memory type which supports the memory type bits specified. If the optimal set of memory properties are supported then return the corresponding memory type index otherwise check for availablility of the required set of memory properties. This allows for implementations to optionally request the use of a more optimal set of memory properties whilst still preserving the ability to retrieve the required set of memory properties as a fallback.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">physicalDevice</td><td>The physical device whose set of pvrvk::PhysicalDeviceMemoryProperties will be used to determine support for the requested memory properties.</td></tr>
    <tr><td class="paramname">allowedMemoryTypeBits</td><td>The memory type bits allowed. The required memory type chosen must be one of those allowed.</td></tr>
    <tr><td class="paramname">optimalMemoryProperties</td><td>A set of optimal memory properties which may be preferred by the application.</td></tr>
    <tr><td class="paramname">requiredMemoryProperties</td><td>The set of memory properties which must be present.</td></tr>
    <tr><td class="paramname">outMemoryTypeIndex</td><td>The returned memory type index.</td></tr>
    <tr><td class="paramname">outMemoryPropertyFlags</td><td>The returned set of memory property flags.</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a7b2d4df80d31e3e63923ab1d68152ace"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t pvr::utils::getNumSamplesFromSampleCountFlags </td>
          <td>(</td>
          <td class="paramtype">pvrvk::SampleCountFlags&#160;</td>
          <td class="paramname"><em>sampleCountFlags</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert pvrvk sample count to the number of samples it is equivalent to</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sampleCountFlags</td><td>The pvrvk sample count to determine the number of samples for</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of samples equivalent to the pvrvk sample count flags</dd></dl>

</div>
</div>
<a class="anchor" id="ad17214254f1b21d40271dac7b2a4b691"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pvr::utils::getOpenGLFormat </td>
          <td>(</td>
          <td class="paramtype">PixelFormat&#160;</td>
          <td class="paramname"><em>pixelFormat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ColorSpace&#160;</td>
          <td class="paramname"><em>colorSpace</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VariableType&#160;</td>
          <td class="paramname"><em>dataType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t &amp;&#160;</td>
          <td class="paramname"><em>glInternalFormat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t &amp;&#160;</td>
          <td class="paramname"><em>glFormat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t &amp;&#160;</td>
          <td class="paramname"><em>glType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t &amp;&#160;</td>
          <td class="paramname"><em>glTypeSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool &amp;&#160;</td>
          <td class="paramname"><em>isCompressedFormat</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieves the OpenGL ES texture formats for a texture with pvr::PixelFormat pixelFormat, pvr::ColorSpace colorSpace and pvr::VariableType dataType.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pixelFormat</td><td>The pvr::PixelFormat to retrieve a corresponding set of OpenGL ES texture formats for.</td></tr>
    <tr><td class="paramname">colorSpace</td><td>The pvr::ColorSpace to retrieve a corresponding set of OpenGL ES texture formats for.</td></tr>
    <tr><td class="paramname">dataType</td><td>The pvr::VariableTypeto retrieve a corresponding set of OpenGL ES texture formats for.</td></tr>
    <tr><td class="paramname">glInternalFormat</td><td>The internal OpenGL ES format corresponding to the provided pvr::PixelFormat pixelFormat, pvr::ColorSpace colorSpace and pvr::VariableType dataType.</td></tr>
    <tr><td class="paramname">glFormat</td><td>The OpenGL ES format corresponding to the provided pvr::PixelFormat pixelFormat, pvr::ColorSpace colorSpace and pvr::VariableType dataType.</td></tr>
    <tr><td class="paramname">glType</td><td>The OpenGL ES type corresponding to the provided pvr::PixelFormat pixelFormat, pvr::ColorSpace colorSpace and pvr::VariableType dataType.</td></tr>
    <tr><td class="paramname">glTypeSize</td><td>The OpenGL ES type size corresponding to the provided pvr::PixelFormat pixelFormat, pvr::ColorSpace colorSpace and pvr::VariableType dataType.</td></tr>
    <tr><td class="paramname">isCompressedFormat</td><td>Specifies whether the OpenGL ES format retrieved is a compressed format.</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a291e4ede9083ee35cc595b7775a6f41c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void pvr::utils::getOpenGLFormat </td>
          <td>(</td>
          <td class="paramtype">ImageStorageFormat&#160;</td>
          <td class="paramname"><em>storageFormat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t &amp;&#160;</td>
          <td class="paramname"><em>glInternalFormat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t &amp;&#160;</td>
          <td class="paramname"><em>glFormat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t &amp;&#160;</td>
          <td class="paramname"><em>glType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t &amp;&#160;</td>
          <td class="paramname"><em>glTypeSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool &amp;&#160;</td>
          <td class="paramname"><em>isCompressedFormat</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Retrieves the OpenGL ES texture formats for a texture with the provided ImageStorageFormat.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">storageFormat</td><td>The pvr::ImageStorageFormat to retrieve a corresponding set of OpenGL ES texture formats for.</td></tr>
    <tr><td class="paramname">glInternalFormat</td><td>The internal OpenGL ES format corresponding to the provided pvr::ImageStorageFormat storageFormat</td></tr>
    <tr><td class="paramname">glFormat</td><td>The OpenGL ES format corresponding to the provided pvr::ImageStorageFormat storageFormat</td></tr>
    <tr><td class="paramname">glType</td><td>The OpenGL ES type corresponding to the provided pvr::ImageStorageFormat storageFormat</td></tr>
    <tr><td class="paramname">glTypeSize</td><td>The OpenGL ES type size corresponding to the provided pvr::ImageStorageFormat storageFormat</td></tr>
    <tr><td class="paramname">isCompressedFormat</td><td>Specifies whether the OpenGL ES format retrieved is a compressed format.</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a9faeae4c6a35b0080b0b6031151e53e2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pvr::utils::getOpenGLStorageFormat </td>
          <td>(</td>
          <td class="paramtype">PixelFormat&#160;</td>
          <td class="paramname"><em>pixelFormat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ColorSpace&#160;</td>
          <td class="paramname"><em>colorSpace</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VariableType&#160;</td>
          <td class="paramname"><em>dataType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">GLenum &amp;&#160;</td>
          <td class="paramname"><em>glInternalFormat</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieves the internal OpenGL ES texture format for a texture with pvr::PixelFormat pixelFormat, pvr::ColorSpace colorSpace and pvr::VariableType dataType.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pixelFormat</td><td>The pvr::PixelFormat to retrieve a corresponding internal OpenGL ES texture format for.</td></tr>
    <tr><td class="paramname">colorSpace</td><td>The pvr::ColorSpace to retrieve a corresponding internal OpenGL ES texture format for.</td></tr>
    <tr><td class="paramname">dataType</td><td>The pvr::VariableTypeto retrieve a corresponding internal OpenGL ES texture format for.</td></tr>
    <tr><td class="paramname">glInternalFormat</td><td>The internal OpenGL ES format corresponding to the provided pvr::PixelFormat pixelFormat, pvr::ColorSpace colorSpace and pvr::VariableType dataType</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a71a6472c33618ce49ded8e029b463429"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void pvr::utils::getOpenGLStorageFormat </td>
          <td>(</td>
          <td class="paramtype">ImageStorageFormat&#160;</td>
          <td class="paramname"><em>storageFormat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">GLenum &amp;&#160;</td>
          <td class="paramname"><em>glInternalFormat</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Retrieves the internal OpenGL ES texture formats for a texture with the provided ImageStorageFormat.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">storageFormat</td><td>The pvr::ImageStorageFormat to retrieve a the internal OpenGL ES texture format for.</td></tr>
    <tr><td class="paramname">glInternalFormat</td><td>The internal OpenGL ES format corresponding to the provided pvr::ImageStorageFormat storageFormat</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns 'True' if the utility function was able to successfully determin the internal OpenGL ES format corresponding to the provided pvr::ImageStorageFormat storageFormat.</dd></dl>

</div>
</div>
<a class="anchor" id="a3555f264beaaf83ff1b84853a87a40fe"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">glm::mat4 pvr::utils::getPerspectiveMatrix </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>fovy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>aspect</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>near1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>far1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>rotate</em> = <code>.0f</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create perspective matrix that trasform scenes that use Opengl Convention (+y up) to Vulkan Convention (+y down).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fovy</td><td>The field of view in the y dimension or the vertical angle.</td></tr>
    <tr><td class="paramname">aspect</td><td>The aspect ratio.</td></tr>
    <tr><td class="paramname">near1</td><td>The near z plane.</td></tr>
    <tr><td class="paramname">far1</td><td>The far z plane.</td></tr>
    <tr><td class="paramname">rotate</td><td>An amount to rotate the generated matrix by around the z axis.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A created perspective matrix based on the fovy, aspect, near, far and rotated values.</dd></dl>

</div>
</div>
<a class="anchor" id="aeb45f4b332ee2574510ef0155a590b8f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void pvr::utils::imageUploadAsyncWorker </td>
          <td>(</td>
          <td class="paramtype">ImageUploadFuture&#160;</td>
          <td class="paramname"><em>uploadFuture</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Provides a mechanism for kicking an asynchronous image upload worker</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">uploadFuture</td><td>An image upload future to be uploaded on a separate thread.</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a93735fa36d5aedc03cf746dfa208a4b5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">pvrvk::ImageAspectFlags pvr::utils::inferAspectFromFormat </td>
          <td>(</td>
          <td class="paramtype">pvrvk::Format&#160;</td>
          <td class="paramname"><em>format</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Infers the pvrvk::ImageAspectFlags from the pvrvk::Format.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">format</td><td>A format to infer pvrvk::ImageAspectFlags from</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>pvrvk::ImageAspectFlags inferred based on the pvrvk::Format provided</dd></dl>

</div>
</div>
<a class="anchor" id="ae3adba7320aa2b924adc48cfa5e043ed"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void pvr::utils::insertDebugUtilsLabel </td>
          <td>(</td>
          <td class="paramtype">pvrvk::CommandBufferBase&#160;</td>
          <td class="paramname"><em>commandBufferBase</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const pvrvk::DebugUtilsLabel &amp;&#160;</td>
          <td class="paramname"><em>labelInfo</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inserts a single debug label any time.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">commandBufferBase</td><td>The base command buffer to which the debug label should be inserted</td></tr>
    <tr><td class="paramname">labelInfo</td><td>Specifies the parameters of the label region to insert</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ab77d5528ee9f9dc1f4dda381175b89eb"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void pvr::utils::insertDebugUtilsLabel </td>
          <td>(</td>
          <td class="paramtype">pvrvk::CommandBuffer &amp;&#160;</td>
          <td class="paramname"><em>commandBuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const pvrvk::DebugUtilsLabel &amp;&#160;</td>
          <td class="paramname"><em>labelInfo</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inserts a single debug label any time.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">commandBuffer</td><td>The command buffer to which the debug label should be inserted</td></tr>
    <tr><td class="paramname">labelInfo</td><td>Specifies the parameters of the label region to insert</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a2938b3543ae68e23f0f2eb348a786ae9"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void pvr::utils::insertDebugUtilsLabel </td>
          <td>(</td>
          <td class="paramtype">pvrvk::SecondaryCommandBuffer &amp;&#160;</td>
          <td class="paramname"><em>secondaryCommandBuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const pvrvk::DebugUtilsLabel &amp;&#160;</td>
          <td class="paramname"><em>labelInfo</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inserts a single debug label any time.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">secondaryCommandBuffer</td><td>The secondary command buffer to which the debug label should be inserted</td></tr>
    <tr><td class="paramname">labelInfo</td><td>Specifies the parameters of the label region to insert</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a7151c7b74ff657fc17ff09c0ab114a07"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool pvr::utils::isFormatDepthStencil </td>
          <td>(</td>
          <td class="paramtype">pvrvk::Format&#160;</td>
          <td class="paramname"><em>format</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return true if the format is a depth stencil format</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">format</td><td>Format to querry</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the pvrvk::Format specified is a depth or stencil format</dd></dl>

</div>
</div>
<a class="anchor" id="a59222cc49624a76fab4d4f65e3337ac3"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool pvr::utils::isImageUsageSupportedBySurface </td>
          <td>(</td>
          <td class="paramtype">const pvrvk::SurfaceCapabilitiesKHR &amp;&#160;</td>
          <td class="paramname"><em>surfaceCapabilities</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">pvrvk::ImageUsageFlags&#160;</td>
          <td class="paramname"><em>imageUsage</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Utility function used to determine whether the SurfaceCapabilitiesKHR supportedUsageFlags member contains the specified image usage and therefore can be used in the intended way.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">surfaceCapabilities</td><td>A SurfaceCapabilitiesKHR structure returned via a call to PhysicalDevice-&gt;getSurfaceCapabilities().</td></tr>
    <tr><td class="paramname">imageUsage</td><td>A set of image usage flags which should be checked for support.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>"true" if the supportedUsageFlags member of the SurfaceCapabilitiesKHR structure contains the specified imageUsage flag bits.</dd></dl>

</div>
</div>
<a class="anchor" id="a9bf319f2a39bf8149f2c8c4b36b1382a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">pvrvk::Image pvr::utils::loadAndUploadImage </td>
          <td>(</td>
          <td class="paramtype">pvrvk::Device &amp;&#160;</td>
          <td class="paramname"><em>device</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>fileName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>allowDecompress</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">pvrvk::CommandBuffer &amp;&#160;</td>
          <td class="paramname"><em>commandBuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IAssetProvider &amp;&#160;</td>
          <td class="paramname"><em>assetProvider</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">pvrvk::ImageUsageFlags&#160;</td>
          <td class="paramname"><em>usageFlags</em> = <code>pvrvk::ImageUsageFlags::e_SAMPLED_BIT</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">pvrvk::ImageLayout&#160;</td>
          <td class="paramname"><em>finalLayout</em> = <code>pvrvk::ImageLayout::e_SHADER_READ_ONLY_OPTIMAL</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Texture *&#160;</td>
          <td class="paramname"><em>outAssetTexture</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vma::Allocator *&#160;</td>
          <td class="paramname"><em>stagingBufferAllocator</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vma::Allocator *&#160;</td>
          <td class="paramname"><em>imageAllocator</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vma::AllocationCreateFlags&#160;</td>
          <td class="paramname"><em>imageAllocationCreateFlags</em> = <code>vma::AllocationCreateFlags::e_NONE</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Load and upload image to gpu. The upload command and staging buffers are recorded in the commandbuffer.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">device</td><td>The device to use to create the image and image view.</td></tr>
    <tr><td class="paramname">fileName</td><td>The filename of a source texture from which to take the texture data.</td></tr>
    <tr><td class="paramname">allowDecompress</td><td>Specifies whether the texture can be decompressed as part of the image upload.</td></tr>
    <tr><td class="paramname">commandBuffer</td><td>A command buffer to which the upload operations should be added. Note that the upload will not be guranteed to be complete until the command buffer is submitted to a queue with appropriate synchronisation.</td></tr>
    <tr><td class="paramname">assetProvider</td><td>Specifies an asset provider to use for loading the texture from system memory.</td></tr>
    <tr><td class="paramname">usageFlags</td><td>Specifies the usage flags for the image being created.</td></tr>
    <tr><td class="paramname">finalLayout</td><td>The final image layout the image will be transitioned to.</td></tr>
    <tr><td class="paramname">outAssetTexture</td><td>A pointer to a created pvr::texture.</td></tr>
    <tr><td class="paramname">stagingBufferAllocator</td><td>A VMA allocator used to allocate memory for the created staging buffer.</td></tr>
    <tr><td class="paramname">imageAllocator</td><td>A VMA allocator used to allocate memory for the created image.</td></tr>
    <tr><td class="paramname">imageAllocationCreateFlags</td><td>VMA Allocation creation flags. These flags can be used to control how and where the memory is allocated from. Valid flags include e_DEDICATED_MEMORY_BIT and e_MAPPED_BIT. e_DEDICATED_MEMORY_BIT indicates that the allocation should have its own memory block. e_MAPPED_BIT indicates memory will be persistently mapped respectively.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The Image Object uploaded.</dd></dl>

</div>
</div>
<a class="anchor" id="a88581dc8fdfc8d1f32d8a272e5c24a75"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">pvrvk::Image pvr::utils::loadAndUploadImage </td>
          <td>(</td>
          <td class="paramtype">pvrvk::Device &amp;&#160;</td>
          <td class="paramname"><em>device</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>fileName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>allowDecompress</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">pvrvk::CommandBuffer &amp;&#160;</td>
          <td class="paramname"><em>commandBuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IAssetProvider &amp;&#160;</td>
          <td class="paramname"><em>assetProvider</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">pvrvk::ImageUsageFlags&#160;</td>
          <td class="paramname"><em>usageFlags</em> = <code>pvrvk::ImageUsageFlags::e_SAMPLED_BIT</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">pvrvk::ImageLayout&#160;</td>
          <td class="paramname"><em>finalLayout</em> = <code>pvrvk::ImageLayout::e_SHADER_READ_ONLY_OPTIMAL</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Texture *&#160;</td>
          <td class="paramname"><em>outAssetTexture</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vma::Allocator *&#160;</td>
          <td class="paramname"><em>stagingBufferAllocator</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vma::Allocator *&#160;</td>
          <td class="paramname"><em>imageAllocator</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vma::AllocationCreateFlags&#160;</td>
          <td class="paramname"><em>imageAllocationCreateFlags</em> = <code>vma::AllocationCreateFlags::e_NONE</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Load and upload image to gpu. The upload command and staging buffers are recorded in the commandbuffer.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">device</td><td>The device to use to create the image and image view.</td></tr>
    <tr><td class="paramname">fileName</td><td>The filename of a source texture from which to take the texture data.</td></tr>
    <tr><td class="paramname">allowDecompress</td><td>Specifies whether the texture can be decompressed as part of the image upload.</td></tr>
    <tr><td class="paramname">commandBuffer</td><td>A command buffer to which the upload operations should be added. Note that the upload will not be guranteed to be complete until the command buffer is submitted to a queue with appropriate synchronisation.</td></tr>
    <tr><td class="paramname">assetProvider</td><td>Specifies an asset provider to use for loading the texture from system memory.</td></tr>
    <tr><td class="paramname">usageFlags</td><td>Specifies the usage flags for the image being created.</td></tr>
    <tr><td class="paramname">finalLayout</td><td>The final image layout the image will be transitioned to.</td></tr>
    <tr><td class="paramname">outAssetTexture</td><td>A pointer to a created pvr::texture.</td></tr>
    <tr><td class="paramname">stagingBufferAllocator</td><td>A VMA allocator used to allocate memory for the created staging buffer.</td></tr>
    <tr><td class="paramname">imageAllocator</td><td>A VMA allocator used to allocate memory for the created image.</td></tr>
    <tr><td class="paramname">imageAllocationCreateFlags</td><td>VMA Allocation creation flags. These flags can be used to control how and where the memory is allocated from. Valid flags include e_DEDICATED_MEMORY_BIT and e_MAPPED_BIT. e_DEDICATED_MEMORY_BIT indicates that the allocation should have its own memory block. e_MAPPED_BIT indicates memory will be persistently mapped respectively.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The Image Object uploaded.</dd></dl>

</div>
</div>
<a class="anchor" id="ae13b551250f56033c7e3c17e67602ad6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">pvrvk::Image pvr::utils::loadAndUploadImage </td>
          <td>(</td>
          <td class="paramtype">pvrvk::Device &amp;&#160;</td>
          <td class="paramname"><em>device</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>fileName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>allowDecompress</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">pvrvk::SecondaryCommandBuffer &amp;&#160;</td>
          <td class="paramname"><em>commandBuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IAssetProvider &amp;&#160;</td>
          <td class="paramname"><em>assetProvider</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">pvrvk::ImageUsageFlags&#160;</td>
          <td class="paramname"><em>usageFlags</em> = <code>pvrvk::ImageUsageFlags::e_SAMPLED_BIT</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">pvrvk::ImageLayout&#160;</td>
          <td class="paramname"><em>finalLayout</em> = <code>pvrvk::ImageLayout::e_SHADER_READ_ONLY_OPTIMAL</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Texture *&#160;</td>
          <td class="paramname"><em>outAssetTexture</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vma::Allocator *&#160;</td>
          <td class="paramname"><em>stagingBufferAllocator</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vma::Allocator *&#160;</td>
          <td class="paramname"><em>imageAllocator</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vma::AllocationCreateFlags&#160;</td>
          <td class="paramname"><em>imageAllocationCreateFlags</em> = <code>vma::AllocationCreateFlags::e_NONE</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Load and upload image to gpu. The upload command and staging buffers are recorded in the commandbuffer.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">device</td><td>The device to use to create the image and image view.</td></tr>
    <tr><td class="paramname">fileName</td><td>The filename of a source texture from which to take the texture data.</td></tr>
    <tr><td class="paramname">allowDecompress</td><td>Specifies whether the texture can be decompressed as part of the image upload.</td></tr>
    <tr><td class="paramname">commandBuffer</td><td>A secondary command buffer to which the upload operations should be added. Note that the upload will not be guranteed to be complete until the command buffer is submitted to a queue with appropriate synchronisation.</td></tr>
    <tr><td class="paramname">assetProvider</td><td>Specifies an asset provider to use for loading the texture from system memory.</td></tr>
    <tr><td class="paramname">usageFlags</td><td>Specifies the usage flags for the image being created.</td></tr>
    <tr><td class="paramname">finalLayout</td><td>The final image layout the image will be transitioned to.</td></tr>
    <tr><td class="paramname">outAssetTexture</td><td>A pointer to a created pvr::texture.</td></tr>
    <tr><td class="paramname">stagingBufferAllocator</td><td>A VMA allocator used to allocate memory for the created staging buffer.</td></tr>
    <tr><td class="paramname">imageAllocator</td><td>A VMA allocator used to allocate memory for the created image.</td></tr>
    <tr><td class="paramname">imageAllocationCreateFlags</td><td>VMA Allocation creation flags. These flags can be used to control how and where the memory is allocated from. Valid flags include e_DEDICATED_MEMORY_BIT and e_MAPPED_BIT. e_DEDICATED_MEMORY_BIT indicates that the allocation should have its own memory block. e_MAPPED_BIT indicates memory will be persistently mapped respectively.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The Image Object uploaded.</dd></dl>

</div>
</div>
<a class="anchor" id="ad7010e7802edc5e1cc101034ac386d37"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">pvrvk::ImageView pvr::utils::loadAndUploadImageAndView </td>
          <td>(</td>
          <td class="paramtype">pvrvk::Device &amp;&#160;</td>
          <td class="paramname"><em>device</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>fileName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>allowDecompress</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">pvrvk::CommandBuffer &amp;&#160;</td>
          <td class="paramname"><em>commandBuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IAssetProvider &amp;&#160;</td>
          <td class="paramname"><em>assetProvider</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">pvrvk::ImageUsageFlags&#160;</td>
          <td class="paramname"><em>usageFlags</em> = <code>pvrvk::ImageUsageFlags::e_SAMPLED_BIT</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">pvrvk::ImageLayout&#160;</td>
          <td class="paramname"><em>finalLayout</em> = <code>pvrvk::ImageLayout::e_SHADER_READ_ONLY_OPTIMAL</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Texture *&#160;</td>
          <td class="paramname"><em>outAssetTexture</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vma::Allocator *&#160;</td>
          <td class="paramname"><em>stagingBufferAllocator</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vma::Allocator *&#160;</td>
          <td class="paramname"><em>imageAllocator</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vma::AllocationCreateFlags&#160;</td>
          <td class="paramname"><em>imageAllocationCreateFlags</em> = <code>vma::AllocationCreateFlags::e_NONE</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Load and upload image to gpu. The upload command and staging buffers are recorded in the commandbuffer.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">device</td><td>The device to use to create the image and image view.</td></tr>
    <tr><td class="paramname">fileName</td><td>The filename of a source texture from which to take the texture data.</td></tr>
    <tr><td class="paramname">allowDecompress</td><td>Specifies whether the texture can be decompressed as part of the image upload.</td></tr>
    <tr><td class="paramname">commandBuffer</td><td>A command buffer to which the upload operations should be added. Note that the upload will not be guranteed to be complete until the command buffer is submitted to a queue with appropriate synchronisation.</td></tr>
    <tr><td class="paramname">assetProvider</td><td>Specifies an asset provider to use for loading the texture from system memory.</td></tr>
    <tr><td class="paramname">usageFlags</td><td>Specifies the usage flags for the image being created.</td></tr>
    <tr><td class="paramname">finalLayout</td><td>The final image layout the image will be transitioned to.</td></tr>
    <tr><td class="paramname">outAssetTexture</td><td>A pointer to a created pvr::texture.</td></tr>
    <tr><td class="paramname">stagingBufferAllocator</td><td>A VMA allocator used to allocate memory for the created staging buffer.</td></tr>
    <tr><td class="paramname">imageAllocator</td><td>A VMA allocator used to allocate memory for the created image.</td></tr>
    <tr><td class="paramname">imageAllocationCreateFlags</td><td>VMA Allocation creation flags. These flags can be used to control how and where the memory is allocated from. Valid flags include e_DEDICATED_MEMORY_BIT and e_MAPPED_BIT. e_DEDICATED_MEMORY_BIT indicates that the allocation should have its own memory block. e_MAPPED_BIT indicates memory will be persistently mapped respectively.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The Image Object uploaded.</dd></dl>

</div>
</div>
<a class="anchor" id="ab1fd64515fccd74310bb74070b669339"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">pvrvk::ImageView pvr::utils::loadAndUploadImageAndView </td>
          <td>(</td>
          <td class="paramtype">pvrvk::Device &amp;&#160;</td>
          <td class="paramname"><em>device</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>fileName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>allowDecompress</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">pvrvk::SecondaryCommandBuffer &amp;&#160;</td>
          <td class="paramname"><em>commandBuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IAssetProvider &amp;&#160;</td>
          <td class="paramname"><em>assetProvider</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">pvrvk::ImageUsageFlags&#160;</td>
          <td class="paramname"><em>usageFlags</em> = <code>pvrvk::ImageUsageFlags::e_SAMPLED_BIT</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">pvrvk::ImageLayout&#160;</td>
          <td class="paramname"><em>finalLayout</em> = <code>pvrvk::ImageLayout::e_SHADER_READ_ONLY_OPTIMAL</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Texture *&#160;</td>
          <td class="paramname"><em>outAssetTexture</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vma::Allocator *&#160;</td>
          <td class="paramname"><em>stagingBufferAllocator</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vma::Allocator *&#160;</td>
          <td class="paramname"><em>imageAllocator</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vma::AllocationCreateFlags&#160;</td>
          <td class="paramname"><em>imageAllocationCreateFlags</em> = <code>vma::AllocationCreateFlags::e_NONE</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Load and upload image to gpu. The upload command and staging buffers are recorded in the commandbuffer.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">device</td><td>The device to use to create the image and image view.</td></tr>
    <tr><td class="paramname">fileName</td><td>The filename of a source texture from which to take the texture data.</td></tr>
    <tr><td class="paramname">allowDecompress</td><td>Specifies whether the texture can be decompressed as part of the image upload.</td></tr>
    <tr><td class="paramname">commandBuffer</td><td>A secondary command buffer to which the upload operations should be added. Note that the upload will not be guranteed to be complete until the command buffer is submitted to a queue with appropriate synchronisation.</td></tr>
    <tr><td class="paramname">assetProvider</td><td>Specifies an asset provider to use for loading the texture from system memory.</td></tr>
    <tr><td class="paramname">usageFlags</td><td>Specifies the usage flags for the image being created.</td></tr>
    <tr><td class="paramname">finalLayout</td><td>The final image layout the image will be transitioned to.</td></tr>
    <tr><td class="paramname">outAssetTexture</td><td>A pointer to a created pvr::texture.</td></tr>
    <tr><td class="paramname">stagingBufferAllocator</td><td>A VMA allocator used to allocate memory for the created staging buffer.</td></tr>
    <tr><td class="paramname">imageAllocator</td><td>A VMA allocator used to allocate memory for the created image.</td></tr>
    <tr><td class="paramname">imageAllocationCreateFlags</td><td>VMA Allocation creation flags. These flags can be used to control how and where the memory is allocated from. Valid flags include e_DEDICATED_MEMORY_BIT and e_MAPPED_BIT. e_DEDICATED_MEMORY_BIT indicates that the allocation should have its own memory block. e_MAPPED_BIT indicates memory will be persistently mapped respectively.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The Image Object uploaded.</dd></dl>

</div>
</div>
<a class="anchor" id="ab6587db0405c15cfceeb768f0a740dca"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">GLuint pvr::utils::loadShader </td>
          <td>(</td>
          <td class="paramtype">const Stream &amp;&#160;</td>
          <td class="paramname"><em>shaderSource</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ShaderType&#160;</td>
          <td class="paramname"><em>shaderType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *const *&#160;</td>
          <td class="paramname"><em>defines</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>numDefines</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Load shader from shader source. Will implicitly load on the current context.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">shaderSource</td><td>A stream containing the shader source text data</td></tr>
    <tr><td class="paramname">shaderType</td><td>The type (stage) of the shader (vertex, fragment...)</td></tr>
    <tr><td class="paramname">defines</td><td>A number of preprocessor definitions that will be passed to the shader</td></tr>
    <tr><td class="paramname">numDefines</td><td>The number of defines</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The shader object</dd></dl>

</div>
</div>
<a class="anchor" id="a8cb2e88f9124d29c4a2498783cf4e1c9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">GLuint pvr::utils::loadShader </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>shaderSource</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ShaderType&#160;</td>
          <td class="paramname"><em>shaderType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *const *&#160;</td>
          <td class="paramname"><em>defines</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>numDefines</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Load shader from shader source. Will implicitly load on the current context.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">shaderSource</td><td>A string containing the shader source text data</td></tr>
    <tr><td class="paramname">shaderType</td><td>The type (stage) of the shader (vertex, fragment...)</td></tr>
    <tr><td class="paramname">defines</td><td>A number of preprocessor definitions that will be passed to the shader</td></tr>
    <tr><td class="paramname">numDefines</td><td>The number of defines</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The shader object</dd></dl>

</div>
</div>
<a class="anchor" id="a1cbbbd1665449ea70d772de63595c806"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VKAPI_ATTR VkBool32 VKAPI_CALL pvr::utils::logMessageDebugReportCallback </td>
          <td>(</td>
          <td class="paramtype">VkDebugReportFlagsEXT&#160;</td>
          <td class="paramname"><em>flags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VkDebugReportObjectTypeEXT&#160;</td>
          <td class="paramname"><em>objectType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>object</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>location</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>messageCode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pLayerPrefix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pMessage</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>pUserData</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>An application DebugReportCallback function providing logging for various events.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">flags</td><td>Indicates the VkDebugReportFlagsEXT triggering the callback.</td></tr>
    <tr><td class="paramname">objectType</td><td>The type of the object being used/created when the event was triggered.</td></tr>
    <tr><td class="paramname">object</td><td>The object where the issue was detected</td></tr>
    <tr><td class="paramname">location</td><td>A component defined value indicating the location of the trigger</td></tr>
    <tr><td class="paramname">messageCode</td><td>A layer defined value indicating the test which triggered the callback</td></tr>
    <tr><td class="paramname">pLayerPrefix</td><td>Abbreviation of the component making the callback</td></tr>
    <tr><td class="paramname">pMessage</td><td>String detailing the trigger conditions</td></tr>
    <tr><td class="paramname">pUserData</td><td>User data given when the callback was created</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns an indication to the calling layer as to whether the Vulkan call should be aborted or not. Applications should always return VK_FALSE so that they see the same behavior with and without validation layers enabled.</dd></dl>

</div>
</div>
<a class="anchor" id="a5e37e4f2f8723d81f2f60ff7c9ffebdf"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VKAPI_ATTR VkBool32 VKAPI_CALL pvr::utils::logMessageDebugUtilsMessengerCallback </td>
          <td>(</td>
          <td class="paramtype">VkDebugUtilsMessageSeverityFlagBitsEXT&#160;</td>
          <td class="paramname"><em>messageSeverity</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VkDebugUtilsMessageTypeFlagsEXT&#160;</td>
          <td class="paramname"><em>messageTypes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const VkDebugUtilsMessengerCallbackDataEXT *&#160;</td>
          <td class="paramname"><em>pCallbackData</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>pUserData</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>An application DebugUtilsMessengerCallback function providing logging for various events.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">messageSeverity</td><td>Indicates the VkDebugUtilsMessageSeverityFlagBitsEXT which define the severity of any message.</td></tr>
    <tr><td class="paramname">messageTypes</td><td>A set of VkDebugUtilsMessageTypeFlagsEXT which define the type of the message.</td></tr>
    <tr><td class="paramname">pCallbackData</td><td>Contains all the callback related data in the VkDebugUtilsMessengerCallbackDataEXT structure</td></tr>
    <tr><td class="paramname">pUserData</td><td>The user data provided when the VkDebugUtilsMessengerEXT was created</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns an indication to the calling layer as to whether the Vulkan call should be aborted or not. Applications should always return VK_FALSE so that they see the same behavior with and without validation layers enabled.</dd></dl>

</div>
</div>
<a class="anchor" id="aee21903727c73558ad8e3cf936917344"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">LogLevel pvr::utils::mapDebugReportFlagsToLogLevel </td>
          <td>(</td>
          <td class="paramtype">pvrvk::DebugReportFlagsEXT&#160;</td>
          <td class="paramname"><em>flags</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Maps a set of DebugReportFlagsEXT to a particular type of log message.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">flags</td><td>The DebugReportFlagsEXT to map to a LogLevel.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns a LogLevel deemed to correspond to the given pvrvk::DebugReportFlagsEXT.</dd></dl>

</div>
</div>
<a class="anchor" id="abbd1f30f49a0d36c9d932437e902d2bb"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">LogLevel pvr::utils::mapDebugUtilsMessageSeverityFlagsToLogLevel </td>
          <td>(</td>
          <td class="paramtype">pvrvk::DebugUtilsMessageSeverityFlagsEXT&#160;</td>
          <td class="paramname"><em>flags</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Maps a set of DebugUtilsMessageSeverityFlagsEXT to a particular type of log message.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">flags</td><td>The DebugUtilsMessageSeverityFlagsEXT to map to a LogLevel.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns a LogLevel deemed to correspond to the given pvrvk::DebugUtilsMessageSeverityFlagsEXT.</dd></dl>

</div>
</div>
<a class="anchor" id="a9c0c12df7c704cd669d4bef29942555e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">PackedSamplerFilter pvr::utils::packSamplerFilter </td>
          <td>(</td>
          <td class="paramtype">pvrvk::Filter&#160;</td>
          <td class="paramname"><em>mini</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">pvrvk::Filter&#160;</td>
          <td class="paramname"><em>magni</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">pvrvk::SamplerMipmapMode&#160;</td>
          <td class="paramname"><em>mip</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Created a packed sampler filter</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mini</td><td>The minification filter</td></tr>
    <tr><td class="paramname">magni</td><td>The magnification filter</td></tr>
    <tr><td class="paramname">mip</td><td>The sampler mipmap mode</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The packed sampler filter</dd></dl>

</div>
</div>
<a class="anchor" id="a98e4ac9990af6eaf6b9bf0928f2bd07d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void pvr::utils::populateClearValues </td>
          <td>(</td>
          <td class="paramtype">const pvrvk::RenderPass &amp;&#160;</td>
          <td class="paramname"><em>renderpass</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const pvrvk::ClearValue &amp;&#160;</td>
          <td class="paramname"><em>clearColor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const pvrvk::ClearValue &amp;&#160;</td>
          <td class="paramname"><em>clearDepthStencilValue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">pvrvk::ClearValue *&#160;</td>
          <td class="paramname"><em>outClearValues</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Populate color and depthstencil clear values</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">renderpass</td><td>The renderpass is used to determine the number of attachments and their formats from which a decision will be as to whether the provided clearColor or clearDepthStencilValue will be used for the corresponding pvrvk::ClearValue structure for each attachment.</td></tr>
    <tr><td class="paramname">clearColor</td><td>A pvrvk::ClearValue which will be used as the clear color value for the renderpass attachments with color formats</td></tr>
    <tr><td class="paramname">clearDepthStencilValue</td><td>A pvrvk::ClearValue which will be used as the depth stencil value for the renderpass attachments with depth stencil formats</td></tr>
    <tr><td class="paramname">outClearValues</td><td>A pointer to an array of pvrvk::ClearValue structures which should have size greater than or equal to the number of renderpass attachments.</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ae0c2fd1a13ff3b5e9086e13ea4608c43"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void pvr::utils::populateInputAssemblyFromMesh </td>
          <td>(</td>
          <td class="paramtype">const assets::Mesh &amp;&#160;</td>
          <td class="paramname"><em>mesh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const VertexBindings *&#160;</td>
          <td class="paramname"><em>bindingMap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>numBindings</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">pvrvk::PipelineVertexInputStateCreateInfo &amp;&#160;</td>
          <td class="paramname"><em>vertexCreateInfo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">pvrvk::PipelineInputAssemblerStateCreateInfo &amp;&#160;</td>
          <td class="paramname"><em>inputAssemblerCreateInfo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t *&#160;</td>
          <td class="paramname"><em>numOutBuffers</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Fills out input assembly and vertex input state structures using a mesh and a list of corresponding <a class="el" href="structpvr_1_1utils_1_1_vertex_bindings.html" title="Represents a shader Explicit binding, tying a Semantic name to an Attribute Index.">VertexBindings</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mesh</td><td>A mesh from which to retrieve vertex attributes, vertex buffer strides and primitive topology information from.</td></tr>
    <tr><td class="paramname">bindingMap</td><td>A pointer to an array of <a class="el" href="structpvr_1_1utils_1_1_vertex_bindings.html" title="Represents a shader Explicit binding, tying a Semantic name to an Attribute Index.">VertexBindings</a> structures which specify the semantic names and binding indices of any vertex attributes to retrieve.</td></tr>
    <tr><td class="paramname">numBindings</td><td>Specifies the number of <a class="el" href="structpvr_1_1utils_1_1_vertex_bindings.html" title="Represents a shader Explicit binding, tying a Semantic name to an Attribute Index.">VertexBindings</a> structures in the array pointed to by bindingMap.</td></tr>
    <tr><td class="paramname">vertexCreateInfo</td><td>A pvrvk::PipelineVertexInputStateCreateInfo structure which will be filled by this utility function.</td></tr>
    <tr><td class="paramname">inputAssemblerCreateInfo</td><td>A pvrvk::InputAssemblerStateCreateInfo structure which will be filled by this utility function.</td></tr>
    <tr><td class="paramname">numOutBuffers</td><td>A pointer to an unsigned integer which will set to specify the number of buffers required to create buffers for to use the mesh vertex attributes.</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a5b4a65db2498eb2d073a7af233bb1367"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void pvr::utils::populateInputAssemblyFromMesh </td>
          <td>(</td>
          <td class="paramtype">const assets::Mesh &amp;&#160;</td>
          <td class="paramname"><em>mesh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const VertexBindings_Name *&#160;</td>
          <td class="paramname"><em>bindingMap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>numBindings</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">pvrvk::PipelineVertexInputStateCreateInfo &amp;&#160;</td>
          <td class="paramname"><em>vertexCreateInfo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">pvrvk::PipelineInputAssemblerStateCreateInfo &amp;&#160;</td>
          <td class="paramname"><em>inputAssemblerCreateInfo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t *&#160;</td>
          <td class="paramname"><em>numOutBuffers</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Fills out input assembly and vertex input state structures using a mesh and a list of corresponding <a class="el" href="structpvr_1_1utils_1_1_vertex_bindings___name.html" title="Represents a shader Reflective binding, tying a Semantic name to an Attribute variable name...">VertexBindings_Name</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mesh</td><td>A mesh from which to retrieve vertex attributes, vertex buffer strides and primitive topology information from.</td></tr>
    <tr><td class="paramname">bindingMap</td><td>A pointer to an array of <a class="el" href="structpvr_1_1utils_1_1_vertex_bindings___name.html" title="Represents a shader Reflective binding, tying a Semantic name to an Attribute variable name...">VertexBindings_Name</a> structures which specify the semantic and binding names of any vertex attributes to retrieve.</td></tr>
    <tr><td class="paramname">numBindings</td><td>Specifies the number of <a class="el" href="structpvr_1_1utils_1_1_vertex_bindings.html" title="Represents a shader Explicit binding, tying a Semantic name to an Attribute Index.">VertexBindings</a> structures in the array pointed to by bindingMap.</td></tr>
    <tr><td class="paramname">vertexCreateInfo</td><td>A pvrvk::PipelineVertexInputStateCreateInfo structure which will be filled by this utility function.</td></tr>
    <tr><td class="paramname">inputAssemblerCreateInfo</td><td>A pvrvk::InputAssemblerStateCreateInfo structure which will be filled by this utility function.</td></tr>
    <tr><td class="paramname">numOutBuffers</td><td>A pointer to an unsigned integer which will set to specify the number of buffers required to create buffers for to use the mesh vertex attributes.</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a1e9a18d03439c5efe7d88dbb3c16b783"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void pvr::utils::populateViewportStateCreateInfo </td>
          <td>(</td>
          <td class="paramtype">const pvrvk::Framebuffer &amp;&#160;</td>
          <td class="paramname"><em>framebuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">pvrvk::PipelineViewportStateCreateInfo &amp;&#160;</td>
          <td class="paramname"><em>outCreateInfo</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Fills out a pvrvk::ViewportStateCreateInfo structure setting parameters for a 'default' viewport and scissor based on the specified frame buffer dimensions.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">framebuffer</td><td>An input Framebuffer object from which to take dimensions used to initialise a pvrvk::ViewportStateCreateInfo structure.</td></tr>
    <tr><td class="paramname">outCreateInfo</td><td>A pvrvk::ViewportStateCreateInfo structure which will have its viewport and scissor members set based on the framebuffers dimensions.</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="acd56ceb5a0ccd36437b833a00a1bd9c5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pvr::utils::saveImage </td>
          <td>(</td>
          <td class="paramtype">pvrvk::Queue &amp;&#160;</td>
          <td class="paramname"><em>queue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">pvrvk::CommandPool &amp;&#160;</td>
          <td class="paramname"><em>commandPool</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">pvrvk::Image &amp;&#160;</td>
          <td class="paramname"><em>image</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const pvrvk::ImageLayout&#160;</td>
          <td class="paramname"><em>imageInitialLayout</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const pvrvk::ImageLayout&#160;</td>
          <td class="paramname"><em>imageFinalLayout</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>filename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vma::Allocator *&#160;</td>
          <td class="paramname"><em>bufferAllocator</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vma::Allocator *&#160;</td>
          <td class="paramname"><em>imageAllocator</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint32_t&#160;</td>
          <td class="paramname"><em>screenshotScale</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Saves the input image as a TGA file with the filename specified. Note that the image must have been created with the pvrvk::ImageUsageFlags::e_TRANSFER_SRC_BIT set.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">queue</td><td>A queue to submit the generated command buffer to. This queue must be compatible with the command pool provided.</td></tr>
    <tr><td class="paramname">commandPool</td><td>A command pool from which to allocate a temporary command buffer to carry out the transfer operations.</td></tr>
    <tr><td class="paramname">image</td><td>The image to save as a TGA file.</td></tr>
    <tr><td class="paramname">imageInitialLayout</td><td>The initial layout of the image from which a transition will be made to pvrvk::ImageLayout::e_TRANSFER_SRC_OPTIMAL.</td></tr>
    <tr><td class="paramname">imageFinalLayout</td><td>The final layout of the image to which a transition will be made.</td></tr>
    <tr><td class="paramname">filename</td><td>The filename to use for the saved TGA image.</td></tr>
    <tr><td class="paramname">bufferAllocator</td><td>A VMA allocator used to allocate memory for the created the buffer used as the target of an imageToBufferCopy.</td></tr>
    <tr><td class="paramname">imageAllocator</td><td>A VMA allocator used to allocate memory for the created image.</td></tr>
    <tr><td class="paramname">screenshotScale</td><td>A scaling factor to use for increasing the size of the saved screenshot.</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a076fe31eafd575f7f2a10f27f6130935"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void pvr::utils::setImageLayout </td>
          <td>(</td>
          <td class="paramtype">pvrvk::Image &amp;&#160;</td>
          <td class="paramname"><em>image</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">pvrvk::ImageLayout&#160;</td>
          <td class="paramname"><em>oldLayout</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">pvrvk::ImageLayout&#160;</td>
          <td class="paramname"><em>newLayout</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">pvrvk::CommandBufferBase&#160;</td>
          <td class="paramname"><em>transitionCmdBuffer</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set image layout</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">image</td><td>The image to transition</td></tr>
    <tr><td class="paramname">oldLayout</td><td>An old image layout to transition from</td></tr>
    <tr><td class="paramname">newLayout</td><td>A new image layout to transition to</td></tr>
    <tr><td class="paramname">transitionCmdBuffer</td><td>A command buffer to add the pipelineBarrier for the image transition.</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a19f7af5558e7afc812edc1e8899d8f50"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pvr::utils::setImageLayoutAndQueueFamilyOwnership </td>
          <td>(</td>
          <td class="paramtype">pvrvk::CommandBufferBase&#160;</td>
          <td class="paramname"><em>srccmd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">pvrvk::CommandBufferBase&#160;</td>
          <td class="paramname"><em>dstcmd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>srcQueueFamily</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>dstQueueFamily</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">pvrvk::ImageLayout&#160;</td>
          <td class="paramname"><em>oldLayout</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">pvrvk::ImageLayout&#160;</td>
          <td class="paramname"><em>newLayout</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">pvrvk::Image &amp;&#160;</td>
          <td class="paramname"><em>image</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>baseMipLevel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>numMipLevels</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>baseArrayLayer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>numArrayLayers</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">pvrvk::ImageAspectFlags&#160;</td>
          <td class="paramname"><em>aspect</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set image layout and queue family ownership</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">srccmd</td><td>The source command buffer from which to transition the image from.</td></tr>
    <tr><td class="paramname">dstcmd</td><td>The destination command buffer from which to transition the image to.</td></tr>
    <tr><td class="paramname">srcQueueFamily</td><td>srcQueueFamily is the source queue family for a queue family ownership transfer.</td></tr>
    <tr><td class="paramname">dstQueueFamily</td><td>dstQueueFamily is the destination queue family for a queue family ownership transfer.</td></tr>
    <tr><td class="paramname">oldLayout</td><td>An old image layout to transition from</td></tr>
    <tr><td class="paramname">newLayout</td><td>A new image layout to transition to</td></tr>
    <tr><td class="paramname">image</td><td>The image to transition</td></tr>
    <tr><td class="paramname">baseMipLevel</td><td>The base mip level of the image to transition</td></tr>
    <tr><td class="paramname">numMipLevels</td><td>The number of mip levels of the image to transition</td></tr>
    <tr><td class="paramname">baseArrayLayer</td><td>The base array layer level of the image to transition</td></tr>
    <tr><td class="paramname">numArrayLayers</td><td>The number of array layers of the image to transition</td></tr>
    <tr><td class="paramname">aspect</td><td>The pvrvk::ImageAspectFlags of the image to transition</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="af132fea9e3e9e5b4bc87004a4228096a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool pvr::utils::takeScreenshot </td>
          <td>(</td>
          <td class="paramtype">pvrvk::Queue &amp;&#160;</td>
          <td class="paramname"><em>queue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">pvrvk::CommandPool &amp;&#160;</td>
          <td class="paramname"><em>commandPool</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">pvrvk::Swapchain &amp;&#160;</td>
          <td class="paramname"><em>swapchain</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint32_t&#160;</td>
          <td class="paramname"><em>swapIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>screenshotFileName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vma::Allocator *&#160;</td>
          <td class="paramname"><em>bufferAllocator</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vma::Allocator *&#160;</td>
          <td class="paramname"><em>imageAllocator</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint32_t&#160;</td>
          <td class="paramname"><em>screenshotScale</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Saves a particular swapchain image corresponding to the swapchain image at index swapIndex for the swapchain.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">queue</td><td>A queue to submit the generated command buffer to. This queue must be compatible with the command pool provided.</td></tr>
    <tr><td class="paramname">commandPool</td><td>A command pool from which to allocate a temporary command buffer to carry out the transfer operations.</td></tr>
    <tr><td class="paramname">swapchain</td><td>The swapchain from which a particular image will be saved.</td></tr>
    <tr><td class="paramname">swapIndex</td><td>The swapchain image at index swapIndex will be saved as a TGA file.</td></tr>
    <tr><td class="paramname">screenshotFileName</td><td>The filename to use for the saved TGA image.</td></tr>
    <tr><td class="paramname">bufferAllocator</td><td>A VMA allocator used to allocate memory for the created the buffer used as the target of an imageToBufferCopy.</td></tr>
    <tr><td class="paramname">imageAllocator</td><td>A VMA allocator used to allocate memory for the created image.</td></tr>
    <tr><td class="paramname">screenshotScale</td><td>A scaling factor to use for increasing the size of the saved screenshot.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the screenshot could be taken successfully</dd></dl>

</div>
</div>
<a class="anchor" id="adac9f0af2d041d5efe3f668f87c6932b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structpvr_1_1utils_1_1_texture_upload_results.html">TextureUploadResults</a> pvr::utils::textureUpload </td>
          <td>(</td>
          <td class="paramtype">const Texture &amp;&#160;</td>
          <td class="paramname"><em>texture</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>isEs2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>allowDecompress</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Upload a texture to the GPU on the current context, and return it as part of the <a class="el" href="structpvr_1_1utils_1_1_texture_upload_results.html" title="The TextureUploadResults structure provides the results for texture upload functions in a simple to u...">TextureUploadResults</a> structure.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">texture</td><td>The pvr::Texture to upload to the GPU</td></tr>
    <tr><td class="paramname">isEs2</td><td>Signifies whether the current context being used for the texture upload is ES2 only. If the context is ES2 only then the texture upload should not use ES3+ functionality as it will be unsupported via this context.</td></tr>
    <tr><td class="paramname">allowDecompress</td><td>Set to true to allow to attempt to de-compress unsupported compressed textures. The textures will be decompressed if ALL of the following are true: The texture is in a compressed format that can be decompressed by the framework (PVRTC), the platform does NOT support this format (if it is hardware supported, it will never be decompressed), and this flag is set to true. Default:true.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A <a class="el" href="structpvr_1_1utils_1_1_texture_upload_results.html" title="The TextureUploadResults structure provides the results for texture upload functions in a simple to u...">TextureUploadResults</a> object containing the uploaded texture and all necessary information (size, formats, whether it was actually decompressed. The "result" field will contain Result::Success on success, errorcode otherwise. See the Texture</dd></dl>

</div>
</div>
<a class="anchor" id="a54f2bb511b50d2c11ddc7377a60714ad"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VKAPI_ATTR VkBool32 VKAPI_CALL pvr::utils::throwOnErrorDebugReportCallback </td>
          <td>(</td>
          <td class="paramtype">VkDebugReportFlagsEXT&#160;</td>
          <td class="paramname"><em>flags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VkDebugReportObjectTypeEXT&#160;</td>
          <td class="paramname"><em>objectType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>object</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>location</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>messageCode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pLayerPrefix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pMessage</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>pUserData</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>An application DebugReportCallback function providing logging for various events. The callback will also throw an exception when VkDebugReportFlagsEXT includes the VK_DEBUG_REPORT_ERROR_BIT_EXT.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">flags</td><td>Indicates the VkDebugReportFlagsEXT triggering the callback.</td></tr>
    <tr><td class="paramname">objectType</td><td>The type of the object being used/created when the event was triggered.</td></tr>
    <tr><td class="paramname">object</td><td>The object where the issue was detected</td></tr>
    <tr><td class="paramname">location</td><td>A component defined value indicating the location of the trigger</td></tr>
    <tr><td class="paramname">messageCode</td><td>A layer defined value indicating the test which triggered the callback</td></tr>
    <tr><td class="paramname">pLayerPrefix</td><td>Abbreviation of the component making the callback</td></tr>
    <tr><td class="paramname">pMessage</td><td>String detailing the trigger conditions</td></tr>
    <tr><td class="paramname">pUserData</td><td>User data given when the callback was created</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns an indication to the calling layer as to whether the Vulkan call should be aborted or not. Applications should always return VK_FALSE so that they see the same behavior with and without validation layers enabled.</dd></dl>

</div>
</div>
<a class="anchor" id="aaf3d187bfb119271fea887f28268699a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VKAPI_ATTR VkBool32 VKAPI_CALL pvr::utils::throwOnErrorDebugUtilsMessengerCallback </td>
          <td>(</td>
          <td class="paramtype">VkDebugUtilsMessageSeverityFlagBitsEXT&#160;</td>
          <td class="paramname"><em>messageSeverity</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VkDebugUtilsMessageTypeFlagsEXT&#160;</td>
          <td class="paramname"><em>messageTypes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const VkDebugUtilsMessengerCallbackDataEXT *&#160;</td>
          <td class="paramname"><em>pCallbackData</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>pUserData</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>An application DebugUtilsMessengerCallback function providing logging for various events. The callback will also throw an exception when VkDebugUtilsMessageSeverityFlagBitsEXT includes the VK_DEBUG_UTILS_MESSAGE_SEVERITY_ERROR_BIT_EXT.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">messageSeverity</td><td>Indicates the VkDebugUtilsMessageSeverityFlagBitsEXT which define the severity of any message.</td></tr>
    <tr><td class="paramname">messageTypes</td><td>A set of VkDebugUtilsMessageTypeFlagsEXT which define the type of the message.</td></tr>
    <tr><td class="paramname">pCallbackData</td><td>Contains all the callback related data in the VkDebugUtilsMessengerCallbackDataEXT structure</td></tr>
    <tr><td class="paramname">pUserData</td><td>The user data provided when the VkDebugUtilsMessengerEXT was created</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns an indication to the calling layer as to whether the Vulkan call should be aborted or not. Applications should always return VK_FALSE so that they see the same behavior with and without validation layers enabled.</dd></dl>

</div>
</div>
<a class="anchor" id="a60f28cc84ae08ec7d3c050c8f9725d88"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pvr::utils::throwOnGlError </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>note</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">LogLevel&#160;</td>
          <td class="paramname"><em>severity</em> = <code>LogLevel::Error</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks and logs api errors if appropriate.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">note</td><td>A c-style std::string that will be prepended to the error description if an error is found.</td></tr>
    <tr><td class="paramname">severity</td><td>that the error will be reported with, if an error is found</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="abf553ba402ff80bc721c72d3a831a703"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void pvr::utils::unpackSamplerFilter </td>
          <td>(</td>
          <td class="paramtype">PackedSamplerFilter&#160;</td>
          <td class="paramname"><em>packed</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">pvrvk::Filter &amp;&#160;</td>
          <td class="paramname"><em>mini</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">pvrvk::Filter &amp;&#160;</td>
          <td class="paramname"><em>magni</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">pvrvk::SamplerMipmapMode &amp;&#160;</td>
          <td class="paramname"><em>mip</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Unpack a packed sampler filter</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">packed</td><td>The packed sampler filter</td></tr>
    <tr><td class="paramname">mini</td><td>The minification filter</td></tr>
    <tr><td class="paramname">magni</td><td>The magnification filter</td></tr>
    <tr><td class="paramname">mip</td><td>The sampler mipmap mode</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ac885b6f537cb86c114be6696c3dc2fb6"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void pvr::utils::updateBufferUsingStagingBuffer </td>
          <td>(</td>
          <td class="paramtype">pvrvk::Device &amp;&#160;</td>
          <td class="paramname"><em>device</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">pvrvk::Buffer &amp;&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">pvrvk::CommandBufferBase&#160;</td>
          <td class="paramname"><em>uploadCmdBuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VkDeviceSize&#160;</td>
          <td class="paramname"><em>offset</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VkDeviceSize&#160;</td>
          <td class="paramname"><em>size</em> = <code>VK_WHOLE_SIZE</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vma::Allocator *&#160;</td>
          <td class="paramname"><em>stagingBufferAllocator</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Utility function to update a buffer's data via an indirect copy from a temporary staging buffer. Updating memory via the use of a staging buffer is necessary when using memory without e_HOST_VISIBLE_BIT memory property flags meaning the buffer itself cannot be mapped to host memory.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">device</td><td>The device used to create the staging buffer</td></tr>
    <tr><td class="paramname">buffer</td><td>The destination buffer.</td></tr>
    <tr><td class="paramname">uploadCmdBuffer</td><td>A command buffer into which commands will be recorded for carrying out the buffer copy</td></tr>
    <tr><td class="paramname">data</td><td>The data to use in the update</td></tr>
    <tr><td class="paramname">offset</td><td>The offset to use for the map -&gt; update -&gt; unmap</td></tr>
    <tr><td class="paramname">size</td><td>The size of the data to be updated</td></tr>
    <tr><td class="paramname">stagingBufferAllocator</td><td>A VMA allocator used to allocate memory for the created staging buffer.</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a618e4160bd8c24d9e0d394dc9511f4a3"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void pvr::utils::updateHostVisibleBuffer </td>
          <td>(</td>
          <td class="paramtype">pvrvk::Buffer &amp;&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VkDeviceSize&#160;</td>
          <td class="paramname"><em>offset</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VkDeviceSize&#160;</td>
          <td class="paramname"><em>size</em> = <code>VK_WHOLE_SIZE</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>flushMemory</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Utility function to update a buffer's data. This function maps and unmap the buffer only if the buffer is not already mapped.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buffer</td><td>The buffer to map -&gt; update -&gt; unmap.</td></tr>
    <tr><td class="paramname">data</td><td>The data to use in the update</td></tr>
    <tr><td class="paramname">offset</td><td>The offset to use for the map -&gt; update -&gt; unmap</td></tr>
    <tr><td class="paramname">size</td><td>The size of the data to be updated</td></tr>
    <tr><td class="paramname">flushMemory</td><td>Boolean flag determining whether to flush the memory prior to the unmap</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a71cc4019e6c6315a8a714f4103bfe503"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pvr::utils::updateImage </td>
          <td>(</td>
          <td class="paramtype">pvrvk::Device &amp;&#160;</td>
          <td class="paramname"><em>device</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">pvrvk::CommandBufferBase&#160;</td>
          <td class="paramname"><em>transferCommandBuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ImageUpdateInfo *&#160;</td>
          <td class="paramname"><em>updateInfos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>numUpdateInfos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">pvrvk::Format&#160;</td>
          <td class="paramname"><em>format</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">pvrvk::ImageLayout&#160;</td>
          <td class="paramname"><em>layout</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>isCubeMap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">pvrvk::Image &amp;&#160;</td>
          <td class="paramname"><em>image</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vma::Allocator *&#160;</td>
          <td class="paramname"><em>bufferAllocator</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Utility function to update an image's data. This function will record the update of the image in the supplied command buffer but NOT submit the command buffer, hence allowing the user to submit it at his own time. IMPORTANT. Assumes image layout is pvrvk::ImageLayout::e_DST_OPTIMAL IMPORTANT. The cleanup object that is the return value of the function must be kept alive as long until the moment that the relevant command buffer submission is finished. Then it can be destroyed (or the cleanup function be called) to free any relevant resources.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">device</td><td>The device used to create the image</td></tr>
    <tr><td class="paramname">transferCommandBuffer</td><td>The command buffer into which the image update operations will be added.</td></tr>
    <tr><td class="paramname">updateInfos</td><td>This object is a c-style array of areas and the data to upload.</td></tr>
    <tr><td class="paramname">numUpdateInfos</td><td>The number of <a class="el" href="structpvr_1_1utils_1_1_image_update_info.html" title="The ImageUpdateInfo struct.">ImageUpdateInfo</a> objects in</td></tr>
    <tr><td class="paramname">format</td><td>The format of the image.</td></tr>
    <tr><td class="paramname">layout</td><td>The final image layout for the image being updated.</td></tr>
    <tr><td class="paramname">isCubeMap</td><td>Is the image a cubemap</td></tr>
    <tr><td class="paramname">image</td><td>The image to update</td></tr>
    <tr><td class="paramname">bufferAllocator</td><td>A VMA allocator used to allocate memory for the created buffer.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns a pvrvk::Image update results structure - ImageUpdateResults</dd></dl>

</div>
</div>
<a class="anchor" id="a94564335e1a4bb4afe501e4b90c9c25e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">pvrvk::Image pvr::utils::uploadImage </td>
          <td>(</td>
          <td class="paramtype">pvrvk::Device &amp;&#160;</td>
          <td class="paramname"><em>device</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Texture &amp;&#160;</td>
          <td class="paramname"><em>texture</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>allowDecompress</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">pvrvk::CommandBuffer &amp;&#160;</td>
          <td class="paramname"><em>commandBuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">pvrvk::ImageUsageFlags&#160;</td>
          <td class="paramname"><em>usageFlags</em> = <code>pvrvk::ImageUsageFlags::e_SAMPLED_BIT</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">pvrvk::ImageLayout&#160;</td>
          <td class="paramname"><em>finalLayout</em> = <code>pvrvk::ImageLayout::e_SHADER_READ_ONLY_OPTIMAL</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vma::Allocator *&#160;</td>
          <td class="paramname"><em>stagingBufferAllocator</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vma::Allocator *&#160;</td>
          <td class="paramname"><em>imageAllocator</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vma::AllocationCreateFlags&#160;</td>
          <td class="paramname"><em>imageAllocationCreateFlags</em> = <code>vma::AllocationCreateFlags::e_NONE</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Upload image to gpu. The upload command and staging buffers are recorded in the commandbuffer.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">device</td><td>The device to use to create the image.</td></tr>
    <tr><td class="paramname">texture</td><td>The source pvr::Texture object from which to take the texture data.</td></tr>
    <tr><td class="paramname">allowDecompress</td><td>Specifies whether the texture can be decompressed as part of the image upload.</td></tr>
    <tr><td class="paramname">commandBuffer</td><td>A command buffer to which the upload operations should be added. Note that the upload will not be guranteed to be complete until the command buffer is submitted to a queue with appropriate synchronisation.</td></tr>
    <tr><td class="paramname">usageFlags</td><td>A command buffer to add the pipelineBarrier for the image transition.</td></tr>
    <tr><td class="paramname">finalLayout</td><td>The final image layout the image will be transitioned to.</td></tr>
    <tr><td class="paramname">stagingBufferAllocator</td><td>A VMA allocator used to allocate memory for the created staging buffer.</td></tr>
    <tr><td class="paramname">imageAllocator</td><td>A VMA allocator used to allocate memory for the created image.</td></tr>
    <tr><td class="paramname">imageAllocationCreateFlags</td><td>VMA Allocation creation flags. These flags can be used to control how and where the memory is allocated from. Valid flags include e_DEDICATED_MEMORY_BIT and e_MAPPED_BIT. e_DEDICATED_MEMORY_BIT indicates that the allocation should have its own memory block. e_MAPPED_BIT indicates memory will be persistently mapped respectively.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The image object.</dd></dl>

</div>
</div>
<a class="anchor" id="a0bd6e8b8a62c678202323873aeda6115"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">pvrvk::ImageView pvr::utils::uploadImageAndView </td>
          <td>(</td>
          <td class="paramtype">pvrvk::Device &amp;&#160;</td>
          <td class="paramname"><em>device</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Texture &amp;&#160;</td>
          <td class="paramname"><em>texture</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>allowDecompress</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">pvrvk::SecondaryCommandBuffer &amp;&#160;</td>
          <td class="paramname"><em>commandBuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">pvrvk::ImageUsageFlags&#160;</td>
          <td class="paramname"><em>usageFlags</em> = <code>pvrvk::ImageUsageFlags::e_SAMPLED_BIT</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">pvrvk::ImageLayout&#160;</td>
          <td class="paramname"><em>finalLayout</em> = <code>pvrvk::ImageLayout::e_SHADER_READ_ONLY_OPTIMAL</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vma::Allocator *&#160;</td>
          <td class="paramname"><em>stagingBufferAllocator</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vma::Allocator *&#160;</td>
          <td class="paramname"><em>imageAllocator</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vma::AllocationCreateFlags&#160;</td>
          <td class="paramname"><em>imageAllocationCreateFlags</em> = <code>vma::AllocationCreateFlags::e_NONE</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Uploads an image to gpu. The upload command and staging buffers are recorded in the commandbuffer.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">device</td><td>The device to use to create the image and image view.</td></tr>
    <tr><td class="paramname">texture</td><td>The source pvr::Texture object from which to take the texture data.</td></tr>
    <tr><td class="paramname">allowDecompress</td><td>Specifies whether the texture can be decompressed as part of the image upload.</td></tr>
    <tr><td class="paramname">commandBuffer</td><td>A secondary command buffer to which the upload operations are be added. Note that the upload will not be guranteed to be complete until the command buffer is submitted to a queue with appropriate synchronisation.</td></tr>
    <tr><td class="paramname">usageFlags</td><td>A command buffer to add the pipelineBarrier for the image transition.</td></tr>
    <tr><td class="paramname">finalLayout</td><td>The final image layout the image will be transitioned to.</td></tr>
    <tr><td class="paramname">stagingBufferAllocator</td><td>A VMA allocator used to allocate memory for the created staging buffer.</td></tr>
    <tr><td class="paramname">imageAllocator</td><td>A VMA allocator used to allocate memory for the created image.</td></tr>
    <tr><td class="paramname">imageAllocationCreateFlags</td><td>VMA Allocation creation flags. These flags can be used to control how and where the memory is allocated from. Valid flags include e_DEDICATED_MEMORY_BIT and e_MAPPED_BIT. e_DEDICATED_MEMORY_BIT indicates that the allocation should have its own memory block. e_MAPPED_BIT indicates memory will be persistently mapped respectively.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The loaded image object.</dd></dl>

</div>
</div>
<a class="anchor" id="aaabab7a3b0f9d671f39fd5d6cb9e5fad"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">pvrvk::ImageView pvr::utils::uploadImageAndView </td>
          <td>(</td>
          <td class="paramtype">pvrvk::Device &amp;&#160;</td>
          <td class="paramname"><em>device</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Texture &amp;&#160;</td>
          <td class="paramname"><em>texture</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>allowDecompress</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">pvrvk::CommandBuffer &amp;&#160;</td>
          <td class="paramname"><em>commandBuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">pvrvk::ImageUsageFlags&#160;</td>
          <td class="paramname"><em>usageFlags</em> = <code>pvrvk::ImageUsageFlags::e_SAMPLED_BIT</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">pvrvk::ImageLayout&#160;</td>
          <td class="paramname"><em>finalLayout</em> = <code>pvrvk::ImageLayout::e_SHADER_READ_ONLY_OPTIMAL</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vma::Allocator *&#160;</td>
          <td class="paramname"><em>stagingBufferAllocator</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vma::Allocator *&#160;</td>
          <td class="paramname"><em>imageAllocator</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vma::AllocationCreateFlags&#160;</td>
          <td class="paramname"><em>imageAllocationCreateFlags</em> = <code>vma::AllocationCreateFlags::e_NONE</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Upload image to gpu. The upload command and staging buffers are recorded in the commandbuffer.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">device</td><td>The device to use to create the image and image view.</td></tr>
    <tr><td class="paramname">texture</td><td>The source pvr::Texture object from which to take the texture data.</td></tr>
    <tr><td class="paramname">allowDecompress</td><td>Specifies whether the texture can be decompressed as part of the image upload.</td></tr>
    <tr><td class="paramname">commandBuffer</td><td>A command buffer to which the upload operations should be added. Note that the upload will not be guranteed to be complete until the command buffer is submitted to a queue with appropriate synchronisation.</td></tr>
    <tr><td class="paramname">usageFlags</td><td>A command buffer to add the pipelineBarrier for the image transition.</td></tr>
    <tr><td class="paramname">finalLayout</td><td>The final image layout the image will be transitioned to.</td></tr>
    <tr><td class="paramname">stagingBufferAllocator</td><td>A VMA allocator used to allocate memory for the created staging buffer.</td></tr>
    <tr><td class="paramname">imageAllocator</td><td>A VMA allocator used to allocate memory for the created image.</td></tr>
    <tr><td class="paramname">imageAllocationCreateFlags</td><td>VMA Allocation creation flags. These flags can be used to control how and where the memory is allocated from. Valid flags include e_DEDICATED_MEMORY_BIT and e_MAPPED_BIT. e_DEDICATED_MEMORY_BIT indicates that the allocation should have its own memory block. e_MAPPED_BIT indicates memory will be persistently mapped respectively.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The image object.</dd></dl>

</div>
</div>
<a class="anchor" id="a4275d35b8141132ad949ef9d8ad0f5a2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">pvrvk::ImageView pvr::utils::uploadImageAndViewSubmit </td>
          <td>(</td>
          <td class="paramtype">pvrvk::Device &amp;&#160;</td>
          <td class="paramname"><em>device</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Texture &amp;&#160;</td>
          <td class="paramname"><em>texture</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>allowDecompress</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">pvrvk::CommandPool &amp;&#160;</td>
          <td class="paramname"><em>commandPool</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">pvrvk::Queue &amp;&#160;</td>
          <td class="paramname"><em>queue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">pvrvk::ImageUsageFlags&#160;</td>
          <td class="paramname"><em>usageFlags</em> = <code>pvrvk::ImageUsageFlags::e_SAMPLED_BIT</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">pvrvk::ImageLayout&#160;</td>
          <td class="paramname"><em>finalLayout</em> = <code>pvrvk::ImageLayout::e_SHADER_READ_ONLY_OPTIMAL</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vma::Allocator *&#160;</td>
          <td class="paramname"><em>stagingBufferAllocator</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vma::Allocator *&#160;</td>
          <td class="paramname"><em>imageAllocator</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vma::AllocationCreateFlags&#160;</td>
          <td class="paramname"><em>imageAllocationCreateFlags</em> = <code>vma::AllocationCreateFlags::e_NONE</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Uploads an image to GPU memory and returns the created image view and associated image.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">device</td><td>The device to use to create the image and image view.</td></tr>
    <tr><td class="paramname">texture</td><td>The source pvr::Texture object from which to take the texture data.</td></tr>
    <tr><td class="paramname">allowDecompress</td><td>Specifies whether the texture can be decompressed as part of the image upload.</td></tr>
    <tr><td class="paramname">commandPool</td><td>A command pool from which to allocate a temporary command buffer to carry out the upload operations.</td></tr>
    <tr><td class="paramname">queue</td><td>A queue to which the upload operations should be submitted to.</td></tr>
    <tr><td class="paramname">usageFlags</td><td>A set of image usage flags for which the created image can be used for.</td></tr>
    <tr><td class="paramname">finalLayout</td><td>The final image layout the image will be transitioned to.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The result of the image upload will be a created image view with its associated pvrvk::Image.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">stagingBufferAllocator</td><td>A VMA allocator used to allocate memory for the created staging buffer.</td></tr>
    <tr><td class="paramname">imageAllocator</td><td>A VMA allocator used to allocate memory for the created image.</td></tr>
    <tr><td class="paramname">imageAllocationCreateFlags</td><td>VMA Allocation creation flags. These flags can be used to control how and where the memory is allocated from. Valid flags include e_DEDICATED_MEMORY_BIT and e_MAPPED_BIT. e_DEDICATED_MEMORY_BIT indicates that the allocation should have its own memory block. e_MAPPED_BIT indicates memory will be persistently mapped respectively.</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.8.4-->
<!-- start footer part (NON TREEVIEW ONLY!!) -->
<!--BEGIN GENERATE_TREEVIEW-->
<div id="FooterMainContainer">
	<div id="FooterContainer">
		<div class="footerlogo">
			<a href="http://www.imgtec.com" target="_blank"><img src="img-footer-logo-grey.png" width="100%" height="100%" border="none" /></a>
		</div>
		<div class="copyright"><p>&copy; Imagination Technologies Limited<br> All rights reserved</p></div>
	</div>
</div>
</body>
</html>
