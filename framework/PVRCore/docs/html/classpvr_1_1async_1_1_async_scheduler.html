<!-- HTML header for doxygen 1.8.4-->
<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="generator" content="Doxygen 1.8.13"/>
<title>PVRCore: pvr::async::AsyncScheduler&lt; ValueType, FutureType, worker &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="IMGdoxygen.css" rel="stylesheet" type="text/css"/>
<link rel="shortcut icon" type="image/x-icon" href="img.ico">
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
  <div class="headercontent">
    <div class="PVRlogo">
      <a href="https://www.imgtec.com/developers/" target="_blank"><img src="PVRlogo.png" width="80%" height="80%"  border="none" /></a>
    </div>
    <a class="SiteTitle"><span id="projectname">PVRCore</span> Documentation</a>
   <tbody>
  </div>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacepvr.html">pvr</a></li><li class="navelem"><b>async</b></li><li class="navelem"><a class="el" href="classpvr_1_1async_1_1_async_scheduler.html">AsyncScheduler</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> &#124;
<a href="classpvr_1_1async_1_1_async_scheduler-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">pvr::async::AsyncScheduler&lt; ValueType, FutureType, worker &gt; Class Template Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>The <a class="el" href="classpvr_1_1async_1_1_async_scheduler.html" title="The AsyncScheduler is an abstract Scheduling system of a homogeneous task queue running on a backgrou...">AsyncScheduler</a> is an abstract Scheduling system of a homogeneous task queue running on a background thread, i.e. a queue of work of a particular type. It provides its child classes wioth access to the actual queue and the synchronization semaphores in order to facilitate easier implementation. Specifically, it is expected that the user will provide functions to enqueue and dequeue work, while this class provides the running loop (actually executing the tasks, calling the callbacks etc 
 <a href="classpvr_1_1async_1_1_async_scheduler.html#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a2e69fbb0066ef55fcca43cd95df576b6"><td class="memItemLeft" align="right" valign="top">typedef std::shared_ptr&lt; <a class="el" href="classpvr_1_1async_1_1_i_framework_async_result.html">IFrameworkAsyncResult</a>&lt; ValueType &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1async_1_1_async_scheduler.html#a2e69fbb0066ef55fcca43cd95df576b6">AsyncResult</a></td></tr>
<tr class="memdesc:a2e69fbb0066ef55fcca43cd95df576b6"><td class="mdescLeft">&#160;</td><td class="mdescRight">The type of result throughout this class. <a href="#a2e69fbb0066ef55fcca43cd95df576b6">More...</a><br /></td></tr>
<tr class="separator:a2e69fbb0066ef55fcca43cd95df576b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a28fff9985089484ab8625f3fb00f442b"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1async_1_1_async_scheduler.html#a28fff9985089484ab8625f3fb00f442b">~AsyncScheduler</a> ()</td></tr>
<tr class="memdesc:a28fff9985089484ab8625f3fb00f442b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor (virtual) <a href="#a28fff9985089484ab8625f3fb00f442b">More...</a><br /></td></tr>
<tr class="separator:a28fff9985089484ab8625f3fb00f442b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a372da49b4546f3b3cd5b95051e9ac5d0"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1async_1_1_async_scheduler.html#a372da49b4546f3b3cd5b95051e9ac5d0">getNumApproxQueuedItem</a> ()</td></tr>
<tr class="memdesc:a372da49b4546f3b3cd5b95051e9ac5d0"><td class="mdescLeft">&#160;</td><td class="mdescRight">The approximate number of queued items. (Unsynchronized for performance). <a href="#a372da49b4546f3b3cd5b95051e9ac5d0">More...</a><br /></td></tr>
<tr class="separator:a372da49b4546f3b3cd5b95051e9ac5d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad3ff290f8906a799226fbc0fafad617c"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1async_1_1_async_scheduler.html#ad3ff290f8906a799226fbc0fafad617c">getNumQueuedItems</a> ()</td></tr>
<tr class="memdesc:ad3ff290f8906a799226fbc0fafad617c"><td class="mdescLeft">&#160;</td><td class="mdescRight">The precise number of queued items at the time of calling. Although it is poosible that (if the queue is currently producing or consuming) the number has changed by the time it is used (even if immediately), nevertheless getting the number is synchronized hence precise at the time of querying it. <a href="#ad3ff290f8906a799226fbc0fafad617c">More...</a><br /></td></tr>
<tr class="separator:ad3ff290f8906a799226fbc0fafad617c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:a581fb77bad8a5d6cf09864f3c2dff476"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1async_1_1_async_scheduler.html#a581fb77bad8a5d6cf09864f3c2dff476">AsyncScheduler</a> ()</td></tr>
<tr class="memdesc:a581fb77bad8a5d6cf09864f3c2dff476"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor (empty, spawns worker thread and waits) <a href="#a581fb77bad8a5d6cf09864f3c2dff476">More...</a><br /></td></tr>
<tr class="separator:a581fb77bad8a5d6cf09864f3c2dff476"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:a746911b5838589ee35704d36cb4c80d9"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1async_1_1_async_scheduler.html#a746911b5838589ee35704d36cb4c80d9">_myInfo</a></td></tr>
<tr class="memdesc:a746911b5838589ee35704d36cb4c80d9"><td class="mdescLeft">&#160;</td><td class="mdescRight">String information regarding the tasks operations. <a href="#a746911b5838589ee35704d36cb4c80d9">More...</a><br /></td></tr>
<tr class="separator:a746911b5838589ee35704d36cb4c80d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4038070a929677fbd22c5c269784ab7b"><td class="memItemLeft" align="right" valign="top">std::deque&lt; FutureType &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1async_1_1_async_scheduler.html#a4038070a929677fbd22c5c269784ab7b">_queue</a></td></tr>
<tr class="memdesc:a4038070a929677fbd22c5c269784ab7b"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is the work queue. Each item enqueued will be processed by worker. <a href="#a4038070a929677fbd22c5c269784ab7b">More...</a><br /></td></tr>
<tr class="separator:a4038070a929677fbd22c5c269784ab7b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a99b7686e1550615ebfa117796c35a529"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_threading_8h.html#a59c51d287496bea247f3d3e2503cb396">Semaphore</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1async_1_1_async_scheduler.html#a99b7686e1550615ebfa117796c35a529">_queueSemaphore</a></td></tr>
<tr class="memdesc:a99b7686e1550615ebfa117796c35a529"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is basically a mutex for the queue. Wait on it to lock the queue, then signal it when done. <a href="#a99b7686e1550615ebfa117796c35a529">More...</a><br /></td></tr>
<tr class="separator:a99b7686e1550615ebfa117796c35a529"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a75acf07584edd98f0f5b837d90445f4e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_threading_8h.html#a59c51d287496bea247f3d3e2503cb396">Semaphore</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1async_1_1_async_scheduler.html#a75acf07584edd98f0f5b837d90445f4e">_workSemaphore</a></td></tr>
<tr class="memdesc:a75acf07584edd98f0f5b837d90445f4e"><td class="mdescLeft">&#160;</td><td class="mdescRight">This semaphore is the counter for enqueued work. Signal it once when adding work to the queue. <a href="#a75acf07584edd98f0f5b837d90445f4e">More...</a><br /></td></tr>
<tr class="separator:a75acf07584edd98f0f5b837d90445f4e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;typename ValueType, typename FutureType, void(*)(FutureType) worker&gt;<br />
class pvr::async::AsyncScheduler&lt; ValueType, FutureType, worker &gt;</h3>

<p>The <a class="el" href="classpvr_1_1async_1_1_async_scheduler.html" title="The AsyncScheduler is an abstract Scheduling system of a homogeneous task queue running on a backgrou...">AsyncScheduler</a> is an abstract Scheduling system of a homogeneous task queue running on a background thread, i.e. a queue of work of a particular type. It provides its child classes wioth access to the actual queue and the synchronization semaphores in order to facilitate easier implementation. Specifically, it is expected that the user will provide functions to enqueue and dequeue work, while this class provides the running loop (actually executing the tasks, calling the callbacks etc</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">ValueType</td><td>The type of the return value that will be returned by the functions</td></tr>
    <tr><td class="paramname">FutureType</td><td>The type of the future (which will also be the input to the worker function)</td></tr>
    <tr><td class="paramname">worker</td><td>The function pointer that will be called to perform the work</td></tr>
  </table>
  </dd>
</dl>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a id="a2e69fbb0066ef55fcca43cd95df576b6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2e69fbb0066ef55fcca43cd95df576b6">&#9670;&nbsp;</a></span>AsyncResult</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ValueType, typename FutureType, void(*)(FutureType) worker&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef std::shared_ptr&lt;<a class="el" href="classpvr_1_1async_1_1_i_framework_async_result.html">IFrameworkAsyncResult</a>&lt;ValueType&gt; &gt; <a class="el" href="classpvr_1_1async_1_1_async_scheduler.html">pvr::async::AsyncScheduler</a>&lt; ValueType, FutureType, worker &gt;::<a class="el" href="classpvr_1_1async_1_1_async_scheduler.html#a2e69fbb0066ef55fcca43cd95df576b6">AsyncResult</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The type of result throughout this class.</p>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a28fff9985089484ab8625f3fb00f442b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a28fff9985089484ab8625f3fb00f442b">&#9670;&nbsp;</a></span>~AsyncScheduler()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ValueType, typename FutureType, void(*)(FutureType) worker&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classpvr_1_1async_1_1_async_scheduler.html">pvr::async::AsyncScheduler</a>&lt; ValueType, FutureType, worker &gt;::~<a class="el" href="classpvr_1_1async_1_1_async_scheduler.html">AsyncScheduler</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Destructor (virtual)</p>

</div>
</div>
<a id="a581fb77bad8a5d6cf09864f3c2dff476"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a581fb77bad8a5d6cf09864f3c2dff476">&#9670;&nbsp;</a></span>AsyncScheduler()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ValueType, typename FutureType, void(*)(FutureType) worker&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpvr_1_1async_1_1_async_scheduler.html">pvr::async::AsyncScheduler</a>&lt; ValueType, FutureType, worker &gt;::<a class="el" href="classpvr_1_1async_1_1_async_scheduler.html">AsyncScheduler</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructor (empty, spawns worker thread and waits)</p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a372da49b4546f3b3cd5b95051e9ac5d0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a372da49b4546f3b3cd5b95051e9ac5d0">&#9670;&nbsp;</a></span>getNumApproxQueuedItem()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ValueType, typename FutureType, void(*)(FutureType) worker&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t <a class="el" href="classpvr_1_1async_1_1_async_scheduler.html">pvr::async::AsyncScheduler</a>&lt; ValueType, FutureType, worker &gt;::getNumApproxQueuedItem </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The approximate number of queued items. (Unsynchronized for performance).</p>
<dl class="section return"><dt>Returns</dt><dd>The number of queued items (currently visible to this thread)</dd></dl>

</div>
</div>
<a id="ad3ff290f8906a799226fbc0fafad617c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad3ff290f8906a799226fbc0fafad617c">&#9670;&nbsp;</a></span>getNumQueuedItems()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ValueType, typename FutureType, void(*)(FutureType) worker&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t <a class="el" href="classpvr_1_1async_1_1_async_scheduler.html">pvr::async::AsyncScheduler</a>&lt; ValueType, FutureType, worker &gt;::getNumQueuedItems </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The precise number of queued items at the time of calling. Although it is poosible that (if the queue is currently producing or consuming) the number has changed by the time it is used (even if immediately), nevertheless getting the number is synchronized hence precise at the time of querying it.</p>
<dl class="section return"><dt>Returns</dt><dd>The number of queued items (access is synchronized)</dd></dl>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="a746911b5838589ee35704d36cb4c80d9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a746911b5838589ee35704d36cb4c80d9">&#9670;&nbsp;</a></span>_myInfo</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ValueType, typename FutureType, void(*)(FutureType) worker&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string <a class="el" href="classpvr_1_1async_1_1_async_scheduler.html">pvr::async::AsyncScheduler</a>&lt; ValueType, FutureType, worker &gt;::_myInfo</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>String information regarding the tasks operations.</p>

</div>
</div>
<a id="a4038070a929677fbd22c5c269784ab7b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4038070a929677fbd22c5c269784ab7b">&#9670;&nbsp;</a></span>_queue</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ValueType, typename FutureType, void(*)(FutureType) worker&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::deque&lt;FutureType&gt; <a class="el" href="classpvr_1_1async_1_1_async_scheduler.html">pvr::async::AsyncScheduler</a>&lt; ValueType, FutureType, worker &gt;::_queue</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This is the work queue. Each item enqueued will be processed by worker.</p>

</div>
</div>
<a id="a99b7686e1550615ebfa117796c35a529"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a99b7686e1550615ebfa117796c35a529">&#9670;&nbsp;</a></span>_queueSemaphore</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ValueType, typename FutureType, void(*)(FutureType) worker&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_threading_8h.html#a59c51d287496bea247f3d3e2503cb396">Semaphore</a> <a class="el" href="classpvr_1_1async_1_1_async_scheduler.html">pvr::async::AsyncScheduler</a>&lt; ValueType, FutureType, worker &gt;::_queueSemaphore</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This is basically a mutex for the queue. Wait on it to lock the queue, then signal it when done.</p>

</div>
</div>
<a id="a75acf07584edd98f0f5b837d90445f4e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a75acf07584edd98f0f5b837d90445f4e">&#9670;&nbsp;</a></span>_workSemaphore</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ValueType, typename FutureType, void(*)(FutureType) worker&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_threading_8h.html#a59c51d287496bea247f3d3e2503cb396">Semaphore</a> <a class="el" href="classpvr_1_1async_1_1_async_scheduler.html">pvr::async::AsyncScheduler</a>&lt; ValueType, FutureType, worker &gt;::_workSemaphore</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This semaphore is the counter for enqueued work. Signal it once when adding work to the queue.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>/usr/buildxl/buildroot/sdk/branch/SDK/framework/PVRCore/<a class="el" href="_threading_8h_source.html">Threading.h</a></li>
</ul>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.8.4-->
<!-- start footer part (NON TREEVIEW ONLY!!) -->
<!--BEGIN GENERATE_TREEVIEW-->
<div id="FooterMainContainer">
	<div id="FooterContainer">
		<div class="footerlogo">
			<a href="http://www.imgtec.com" target="_blank"><img src="img-footer-logo-grey.png" width="20%" height="20%" border="none" /></a>
		</div>
		<div class="copyright"><p>&copy; Imagination Technologies Limited<br> All rights reserved</p></div>
	</div>
</div>
</body>
</html>
