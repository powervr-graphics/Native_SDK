<!-- HTML header for doxygen 1.8.4-->
<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="generator" content="Doxygen 1.8.13"/>
<title>PVRCore: pvr::async::IFrameworkAsyncResult&lt; T &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="IMGdoxygen.css" rel="stylesheet" type="text/css"/>
<link rel="shortcut icon" type="image/x-icon" href="img.ico">
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
  <div class="headercontent">
    <div class="PVRlogo">
      <a href="https://www.imgtec.com/developers/" target="_blank"><img src="PVRlogo.png" width="40%" height="40%"  border="none" /></a>
    </div>
    <a class="SiteTitle"><span id="projectname">PVRCore</span> Documentation</a>
   <tbody>
  </div>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacepvr.html">pvr</a></li><li class="navelem"><b>async</b></li><li class="navelem"><a class="el" href="classpvr_1_1async_1_1_i_framework_async_result.html">IFrameworkAsyncResult</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> &#124;
<a href="classpvr_1_1async_1_1_i_framework_async_result-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">pvr::async::IFrameworkAsyncResult&lt; T &gt; Class Template Reference<span class="mlabels"><span class="mlabel">abstract</span></span></div>  </div>
</div><!--header-->
<div class="contents">

<p>An object that is intended to be used as an asynchronous return value. When you wish to perform a task in another thread, when "kicking" that task you should "immediately" (before the task is complete) return such an object, and use it to check when the task is complete, and retrieve its return value. Will provide both cleanup semantics (which should at least ensure the objects are safe to destroy and operations are pending on them), and functions to both query completion and (blockingly) get the return value. To implement this class, you must implement the abstract functions get_ (that actually waits for and returns the result, and _isComplete, which actually queries if the result is ready. 
 <a href="classpvr_1_1async_1_1_i_framework_async_result.html#details">More...</a></p>
<div class="dynheader">
Inheritance diagram for pvr::async::IFrameworkAsyncResult&lt; T &gt;:</div>
<div class="dyncontent">
<div class="center"><img src="classpvr_1_1async_1_1_i_framework_async_result__inherit__graph.png" border="0" usemap="#pvr_1_1async_1_1_i_framework_async_result_3_01_t_01_4_inherit__map" alt="Inheritance graph"/></div>
<map name="pvr_1_1async_1_1_i_framework_async_result_3_01_t_01_4_inherit__map" id="pvr_1_1async_1_1_i_framework_async_result_3_01_t_01_4_inherit__map">
<area shape="rect" id="node2" href="classpvr_1_1async_1_1_i_framework_cleanup_object.html" title="A wrapper object with explicit clean up semantics that is intended to be used as the return value in ..." alt="" coords="5,5,232,47"/>
</map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:aaaaab98799521063c73492b20839d8c1"><td class="memItemLeft" align="right" valign="top">typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1async_1_1_i_framework_async_result.html#aaaaab98799521063c73492b20839d8c1">Callback</a>) (<a class="el" href="classpvr_1_1async_1_1_i_framework_async_result.html#a66968d22333ae07fbe05b241efc5f2db">PointerType</a>)</td></tr>
<tr class="memdesc:aaaaab98799521063c73492b20839d8c1"><td class="mdescLeft">&#160;</td><td class="mdescRight">A function pointer type that can be used as a callback to call when the return value is ready <a href="#aaaaab98799521063c73492b20839d8c1">More...</a><br /></td></tr>
<tr class="separator:aaaaab98799521063c73492b20839d8c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a66968d22333ae07fbe05b241efc5f2db"><td class="memItemLeft" align="right" valign="top">typedef std::shared_ptr&lt; <a class="el" href="classpvr_1_1async_1_1_i_framework_async_result.html">IFrameworkAsyncResult</a>&lt; T &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1async_1_1_i_framework_async_result.html#a66968d22333ae07fbe05b241efc5f2db">PointerType</a></td></tr>
<tr class="memdesc:a66968d22333ae07fbe05b241efc5f2db"><td class="mdescLeft">&#160;</td><td class="mdescRight">A smart pointer to this result object (not the wrapped value) <a href="#a66968d22333ae07fbe05b241efc5f2db">More...</a><br /></td></tr>
<tr class="separator:a66968d22333ae07fbe05b241efc5f2db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a443532fc20e721cbf2ffa8a15e180f56"><td class="memItemLeft" align="right" valign="top">typedef T&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1async_1_1_i_framework_async_result.html#a443532fc20e721cbf2ffa8a15e180f56">ValueType</a></td></tr>
<tr class="memdesc:a443532fc20e721cbf2ffa8a15e180f56"><td class="mdescLeft">&#160;</td><td class="mdescRight">The type of the return value <a href="#a443532fc20e721cbf2ffa8a15e180f56">More...</a><br /></td></tr>
<tr class="separator:a443532fc20e721cbf2ffa8a15e180f56"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a2eeb9f821e79c7fc311b54d2640a9831"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1async_1_1_i_framework_cleanup_object.html#a2eeb9f821e79c7fc311b54d2640a9831">cleanup</a> ()</td></tr>
<tr class="memdesc:a2eeb9f821e79c7fc311b54d2640a9831"><td class="mdescLeft">&#160;</td><td class="mdescRight">Call this function when you are done using this object. <a href="#a2eeb9f821e79c7fc311b54d2640a9831">More...</a><br /></td></tr>
<tr class="separator:a2eeb9f821e79c7fc311b54d2640a9831"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c729bc2846556f45ccdc5fb65103a44"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpvr_1_1async_1_1_i_framework_async_result.html#a443532fc20e721cbf2ffa8a15e180f56">ValueType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1async_1_1_i_framework_async_result.html#a3c729bc2846556f45ccdc5fb65103a44">get</a> ()</td></tr>
<tr class="memdesc:a3c729bc2846556f45ccdc5fb65103a44"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is the most important function of <a class="el" href="classpvr_1_1async_1_1_i_framework_async_result.html" title="An object that is intended to be used as an asynchronous return value. When you wish to perform a tas...">IFrameworkAsyncResult</a>: it actually gets the return value. If the value is not yet ready (the task is not complete), it will wait for the task completion. Use this immediately when other operations depend on the value. Otherwise, in order to avoid any wait, you can first check <a class="el" href="classpvr_1_1async_1_1_i_framework_async_result.html#ab0c3a00d9475c7dcbf3459eeb5c81541" title="Query is the return value is ready to be used">isComplete()</a> and only call this function after <a class="el" href="classpvr_1_1async_1_1_i_framework_async_result.html#ab0c3a00d9475c7dcbf3459eeb5c81541" title="Query is the return value is ready to be used">isComplete()</a> has returned true. If the task may fail, you should call <a class="el" href="classpvr_1_1async_1_1_i_framework_async_result.html#a09d5a0dedd7e71e68591ed5513206ab0" title="Returns true if the operation was successful. An operation that is not complete cannot be successful...">isSuccessful()</a> before using the value to ensure it is what you expect. <a href="#a3c729bc2846556f45ccdc5fb65103a44">More...</a><br /></td></tr>
<tr class="separator:a3c729bc2846556f45ccdc5fb65103a44"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab0c3a00d9475c7dcbf3459eeb5c81541"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1async_1_1_i_framework_async_result.html#ab0c3a00d9475c7dcbf3459eeb5c81541">isComplete</a> () const</td></tr>
<tr class="memdesc:ab0c3a00d9475c7dcbf3459eeb5c81541"><td class="mdescLeft">&#160;</td><td class="mdescRight">Query is the return value is ready to be used <a href="#ab0c3a00d9475c7dcbf3459eeb5c81541">More...</a><br /></td></tr>
<tr class="separator:ab0c3a00d9475c7dcbf3459eeb5c81541"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09d5a0dedd7e71e68591ed5513206ab0"><td class="memItemLeft" align="right" valign="top"><a id="a09d5a0dedd7e71e68591ed5513206ab0"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1async_1_1_i_framework_async_result.html#a09d5a0dedd7e71e68591ed5513206ab0">isSuccessful</a> () const</td></tr>
<tr class="memdesc:a09d5a0dedd7e71e68591ed5513206ab0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the operation was successful. An operation that is not complete cannot be successful, so check isComplete to ensure that a return value of false means that the operation actually failed<dl class="section return"><dt>Returns</dt><dd>True if the operation is complete and successful, false if the operation failed or has not yet completed</dd></dl>
<br /></td></tr>
<tr class="separator:a09d5a0dedd7e71e68591ed5513206ab0"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:ad11fe888126058746669ec00b98d33a2"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1async_1_1_i_framework_async_result.html#ad11fe888126058746669ec00b98d33a2">executeCallBack</a> (<a class="el" href="classpvr_1_1async_1_1_i_framework_async_result.html#a66968d22333ae07fbe05b241efc5f2db">PointerType</a> thisPtr)</td></tr>
<tr class="memdesc:ad11fe888126058746669ec00b98d33a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Execute the callback (overridable) <a href="#ad11fe888126058746669ec00b98d33a2">More...</a><br /></td></tr>
<tr class="separator:ad11fe888126058746669ec00b98d33a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad9484ee12974a95ce286429f04d82c4b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1async_1_1_i_framework_async_result.html#ad9484ee12974a95ce286429f04d82c4b">setTheCallback</a> (<a class="el" href="classpvr_1_1async_1_1_i_framework_async_result.html#aaaaab98799521063c73492b20839d8c1">Callback</a> completionCallback)</td></tr>
<tr class="memdesc:ad9484ee12974a95ce286429f04d82c4b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the callback (a function pointer that will be called whenever processing an item is done) <a href="#ad9484ee12974a95ce286429f04d82c4b">More...</a><br /></td></tr>
<tr class="separator:ad9484ee12974a95ce286429f04d82c4b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:a3b8008b722bead0caf64f2766d5fb37d"><td class="memItemLeft" align="right" valign="top"><a id="a3b8008b722bead0caf64f2766d5fb37d"></a>
<a class="el" href="classpvr_1_1async_1_1_i_framework_async_result.html#aaaaab98799521063c73492b20839d8c1">Callback</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1async_1_1_i_framework_async_result.html#a3b8008b722bead0caf64f2766d5fb37d">_completionCallback</a></td></tr>
<tr class="memdesc:a3b8008b722bead0caf64f2766d5fb37d"><td class="mdescLeft">&#160;</td><td class="mdescRight">The callback that will be called on completion. <br /></td></tr>
<tr class="separator:a3b8008b722bead0caf64f2766d5fb37d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d3dac58ec5cafe521e7816eb22334c1"><td class="memItemLeft" align="right" valign="top"><a id="a8d3dac58ec5cafe521e7816eb22334c1"></a>
std::atomic&lt; bool &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1async_1_1_i_framework_async_result.html#a8d3dac58ec5cafe521e7816eb22334c1">_inCallback</a></td></tr>
<tr class="memdesc:a8d3dac58ec5cafe521e7816eb22334c1"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is a mechanism to query if a function is actually called BY the callback to avoid deadlocking. <br /></td></tr>
<tr class="separator:a8d3dac58ec5cafe521e7816eb22334c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e6065186c0708bf0efabd8dca3d138b"><td class="memItemLeft" align="right" valign="top"><a id="a2e6065186c0708bf0efabd8dca3d138b"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1async_1_1_i_framework_async_result.html#a2e6065186c0708bf0efabd8dca3d138b">_successful</a></td></tr>
<tr class="memdesc:a2e6065186c0708bf0efabd8dca3d138b"><td class="mdescLeft">&#160;</td><td class="mdescRight">This will / should be set to true when the work is successfully completed. <br /></td></tr>
<tr class="separator:a2e6065186c0708bf0efabd8dca3d138b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;typename T&gt;<br />
class pvr::async::IFrameworkAsyncResult&lt; T &gt;</h3>

<p>An object that is intended to be used as an asynchronous return value. When you wish to perform a task in another thread, when "kicking" that task you should "immediately" (before the task is complete) return such an object, and use it to check when the task is complete, and retrieve its return value. Will provide both cleanup semantics (which should at least ensure the objects are safe to destroy and operations are pending on them), and functions to both query completion and (blockingly) get the return value. To implement this class, you must implement the abstract functions get_ (that actually waits for and returns the result, and _isComplete, which actually queries if the result is ready.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The type of the return value of the task (for example, <a class="el" href="classpvr_1_1_texture.html" title="A 2D Texture asset, together with Information, Metadata and actual Pixel data. Only represents the ac...">Texture</a>)</td></tr>
  </table>
  </dd>
</dl>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a id="aaaaab98799521063c73492b20839d8c1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaaaab98799521063c73492b20839d8c1">&#9670;&nbsp;</a></span>Callback</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef void(* <a class="el" href="classpvr_1_1async_1_1_i_framework_async_result.html">pvr::async::IFrameworkAsyncResult</a>&lt; T &gt;::Callback) (<a class="el" href="classpvr_1_1async_1_1_i_framework_async_result.html#a66968d22333ae07fbe05b241efc5f2db">PointerType</a>)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A function pointer type that can be used as a callback to call when the return value is ready</p>

</div>
</div>
<a id="a66968d22333ae07fbe05b241efc5f2db"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a66968d22333ae07fbe05b241efc5f2db">&#9670;&nbsp;</a></span>PointerType</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef std::shared_ptr&lt;<a class="el" href="classpvr_1_1async_1_1_i_framework_async_result.html">IFrameworkAsyncResult</a>&lt;T&gt; &gt; <a class="el" href="classpvr_1_1async_1_1_i_framework_async_result.html">pvr::async::IFrameworkAsyncResult</a>&lt; T &gt;::<a class="el" href="classpvr_1_1async_1_1_i_framework_async_result.html#a66968d22333ae07fbe05b241efc5f2db">PointerType</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A smart pointer to this result object (not the wrapped value)</p>

</div>
</div>
<a id="a443532fc20e721cbf2ffa8a15e180f56"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a443532fc20e721cbf2ffa8a15e180f56">&#9670;&nbsp;</a></span>ValueType</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef T <a class="el" href="classpvr_1_1async_1_1_i_framework_async_result.html">pvr::async::IFrameworkAsyncResult</a>&lt; T &gt;::<a class="el" href="classpvr_1_1async_1_1_i_framework_async_result.html#a443532fc20e721cbf2ffa8a15e180f56">ValueType</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The type of the return value</p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a2eeb9f821e79c7fc311b54d2640a9831"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2eeb9f821e79c7fc311b54d2640a9831">&#9670;&nbsp;</a></span>cleanup()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classpvr_1_1async_1_1_i_framework_cleanup_object.html">pvr::async::IFrameworkCleanupObject</a>&lt; T &gt;::cleanup </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Call this function when you are done using this object.</p>

</div>
</div>
<a id="ad11fe888126058746669ec00b98d33a2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad11fe888126058746669ec00b98d33a2">&#9670;&nbsp;</a></span>executeCallBack()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classpvr_1_1async_1_1_i_framework_async_result.html">pvr::async::IFrameworkAsyncResult</a>&lt; T &gt;::executeCallBack </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classpvr_1_1async_1_1_i_framework_async_result.html#a66968d22333ae07fbe05b241efc5f2db">PointerType</a>&#160;</td>
          <td class="paramname"><em>thisPtr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Execute the callback (overridable)</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">thisPtr</td><td>The object with which the callback will be executed as a parameter.</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3c729bc2846556f45ccdc5fb65103a44"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3c729bc2846556f45ccdc5fb65103a44">&#9670;&nbsp;</a></span>get()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpvr_1_1async_1_1_i_framework_async_result.html#a443532fc20e721cbf2ffa8a15e180f56">ValueType</a> <a class="el" href="classpvr_1_1async_1_1_i_framework_async_result.html">pvr::async::IFrameworkAsyncResult</a>&lt; T &gt;::get </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This is the most important function of <a class="el" href="classpvr_1_1async_1_1_i_framework_async_result.html" title="An object that is intended to be used as an asynchronous return value. When you wish to perform a tas...">IFrameworkAsyncResult</a>: it actually gets the return value. If the value is not yet ready (the task is not complete), it will wait for the task completion. Use this immediately when other operations depend on the value. Otherwise, in order to avoid any wait, you can first check <a class="el" href="classpvr_1_1async_1_1_i_framework_async_result.html#ab0c3a00d9475c7dcbf3459eeb5c81541" title="Query is the return value is ready to be used">isComplete()</a> and only call this function after <a class="el" href="classpvr_1_1async_1_1_i_framework_async_result.html#ab0c3a00d9475c7dcbf3459eeb5c81541" title="Query is the return value is ready to be used">isComplete()</a> has returned true. If the task may fail, you should call <a class="el" href="classpvr_1_1async_1_1_i_framework_async_result.html#a09d5a0dedd7e71e68591ed5513206ab0" title="Returns true if the operation was successful. An operation that is not complete cannot be successful...">isSuccessful()</a> before using the value to ensure it is what you expect.</p>
<dl class="section return"><dt>Returns</dt><dd>The return value of the operation.</dd></dl>

</div>
</div>
<a id="ab0c3a00d9475c7dcbf3459eeb5c81541"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab0c3a00d9475c7dcbf3459eeb5c81541">&#9670;&nbsp;</a></span>isComplete()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classpvr_1_1async_1_1_i_framework_async_result.html">pvr::async::IFrameworkAsyncResult</a>&lt; T &gt;::isComplete </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Query is the return value is ready to be used</p>
<dl class="section return"><dt>Returns</dt><dd>True if the value is ready, otherwise false</dd></dl>

</div>
</div>
<a id="ad9484ee12974a95ce286429f04d82c4b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad9484ee12974a95ce286429f04d82c4b">&#9670;&nbsp;</a></span>setTheCallback()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classpvr_1_1async_1_1_i_framework_async_result.html">pvr::async::IFrameworkAsyncResult</a>&lt; T &gt;::setTheCallback </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classpvr_1_1async_1_1_i_framework_async_result.html#aaaaab98799521063c73492b20839d8c1">Callback</a>&#160;</td>
          <td class="paramname"><em>completionCallback</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the callback (a function pointer that will be called whenever processing an item is done)</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">completionCallback</td><td>The callback to set</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>/usr/buildxl/buildroot/sdk/branch/SDK/framework/PVRCore/<a class="el" href="_threading_8h_source.html">Threading.h</a></li>
</ul>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.8.4-->
<!-- start footer part (NON TREEVIEW ONLY!!) -->
<!--BEGIN GENERATE_TREEVIEW-->
<div id="FooterMainContainer">
	<div id="FooterContainer">
		<div class="footerlogo">
			<a href="http://www.imgtec.com" target="_blank"><img src="img-footer-logo-grey.png" width="100%" height="100%" border="none" /></a>
		</div>
		<div class="copyright"><p>&copy; Imagination Technologies Limited<br> All rights reserved</p></div>
	</div>
</div>
</body>
</html>
