<!-- HTML header for doxygen 1.8.4-->
<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="generator" content="Doxygen 1.8.13"/>
<title>PVRCore: pvr Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="IMGdoxygen.css" rel="stylesheet" type="text/css"/>
<link rel="shortcut icon" type="image/x-icon" href="img.ico">
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
  <div class="headercontent">
    <div class="PVRlogo">
      <a href="https://www.imgtec.com/developers/" target="_blank"><img src="PVRlogo.png" width="40%" height="40%"  border="none" /></a>
    </div>
    <a class="SiteTitle"><span id="projectname">PVRCore</span> Documentation</a>
   <tbody>
  </div>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a> &#124;
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">pvr Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Main PowerVR Framework Namespace 
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="namespaces"></a>
Namespaces</h2></td></tr>
<tr class="memitem:namespacepvr_1_1asset_readers"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr_1_1asset_readers.html">assetReaders</a></td></tr>
<tr class="memdesc:namespacepvr_1_1asset_readers"><td class="mdescLeft">&#160;</td><td class="mdescRight">Contains classes whose purpose is to read specific storage formats (bmp, POD, pfx, pvr etc.) into PVRAssets classes (<a class="el" href="classpvr_1_1_texture.html" title="A 2D Texture asset, together with Information, Metadata and actual Pixel data. Only represents the ac...">Texture</a>, Model, Effect etc.).<br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacepvr_1_1_gpu_datatypes_helper"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr_1_1_gpu_datatypes_helper.html">GpuDatatypesHelper</a></td></tr>
<tr class="memdesc:namespacepvr_1_1_gpu_datatypes_helper"><td class="mdescLeft">&#160;</td><td class="mdescRight">Groups functionality that has to do with bit calculations/sizes/offsets of glsl types<br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacepvr_1_1math"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr_1_1math.html">math</a></td></tr>
<tr class="memdesc:namespacepvr_1_1math"><td class="mdescLeft">&#160;</td><td class="mdescRight">Contains mathematical functionality and classes, such as bounding box calculations, intersections etc.<br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacepvr_1_1strings"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr_1_1strings.html">strings</a></td></tr>
<tr class="memdesc:namespacepvr_1_1strings"><td class="mdescLeft">&#160;</td><td class="mdescRight">Contains several valuable helpers to assist with common std::string operations: Starts with, ends with, create with printf-style formatting and others.<br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacepvr_1_1utils"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr_1_1utils.html">utils</a></td></tr>
<tr class="memdesc:namespacepvr_1_1utils"><td class="mdescLeft">&#160;</td><td class="mdescRight">Contains assorted utility functions (test endianness, unicode conversions etc.)<br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1_android_asset_stream.html">AndroidAssetStream</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A <a class="el" href="classpvr_1_1_stream.html" title="This class is used to abstract streams of data (files, blocks of memory, resources etc...">Stream</a> implementation that is used to access resources built in an Android package (apk).  <a href="classpvr_1_1_android_asset_stream.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpvr_1_1_blending_config.html">BlendingConfig</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add blending configuration for a color attachment. Some API's only support one blending state for all attachments, in which case the 1st such configuration will be used for all. <a href="structpvr_1_1_blending_config.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1_buffer_stream.html">BufferStream</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class is used to access a block of memory as a <a class="el" href="classpvr_1_1_stream.html" title="This class is used to abstract streams of data (files, blocks of memory, resources etc...">Stream</a>. <a href="classpvr_1_1_buffer_stream.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpvr_1_1_camera_animation_controller.html">CameraAnimationController</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A simple structure for controlling camera animations <a href="structpvr_1_1_camera_animation_controller.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpvr_1_1_camera_key_frame.html">CameraKeyFrame</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A simple structure for handling key camera frames <a href="structpvr_1_1_camera_key_frame.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpvr_1_1_compressed_image_data_format.html">CompressedImageDataFormat</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Describes a Compressed format. Compressed formats provide less information than the uncompressed format, as they can only be accessed "black box". <a href="structpvr_1_1_compressed_image_data_format.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1_display_attributes.html">DisplayAttributes</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Contains display configuration information (width, height, position, title, bpp etc.). <a href="classpvr_1_1_display_attributes.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1_file_e_o_f_error.html">FileEOFError</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A simple std::runtime_error wrapper for throwing exceptions when attempting to read past the End Of File <a href="classpvr_1_1_file_e_o_f_error.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1_file_i_o_error.html">FileIOError</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A simple std::runtime_error wrapper for throwing exceptions when undertaking File IO operations <a href="classpvr_1_1_file_i_o_error.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1_file_not_found_error.html">FileNotFoundError</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A simple std::runtime_error wrapper for throwing exceptions when file not found errors occur <a href="classpvr_1_1_file_not_found_error.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1_file_path.html">FilePath</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Filepath represents a Path + Filename + Extension. <a href="classpvr_1_1_file_path.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1_file_stream.html">FileStream</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A <a class="el" href="classpvr_1_1_file_stream.html" title="A FileStream is a Stream that is used to access a File in the filesystem of the platform.">FileStream</a> is a <a class="el" href="classpvr_1_1_stream.html" title="This class is used to abstract streams of data (files, blocks of memory, resources etc...">Stream</a> that is used to access a File in the filesystem of the platform. <a href="classpvr_1_1_file_stream.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1_f_p_s_camera.html">FPSCamera</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A simple first person camera implementation <a href="classpvr_1_1_f_p_s_camera.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpvr_1_1_free_value.html">FreeValue</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A Free Value View that is backed by a 64-byte statically allocated array: Enough to hold one item of any GPU-datatype, up to a mat4x4 <a href="structpvr_1_1_free_value.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1_free_value_view.html">FreeValueView</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents a runtime-known number of elements of a runtime-known type, with functions to handle and convert them. Very commonly used to dynamically represent data that will eventually need to be used by the GPU, such as uniforms, vectors and matrices. Does not contain methods to actually be populated, as this should be done through subclasses. <a href="classpvr_1_1_free_value_view.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1_generate_pixel_type1.html">GeneratePixelType1</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Use this template class to generate a 1 channel PixelID. <a href="classpvr_1_1_generate_pixel_type1.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1_generate_pixel_type2.html">GeneratePixelType2</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Use this template class to generate a 2 channel PixelID. <a href="classpvr_1_1_generate_pixel_type2.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1_generate_pixel_type3.html">GeneratePixelType3</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Use this template class to generate a 3 channel PixelID. <a href="classpvr_1_1_generate_pixel_type3.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1_generate_pixel_type4.html">GeneratePixelType4</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Use this template class to generate a 4 channel PixelID. <a href="classpvr_1_1_generate_pixel_type4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpvr_1_1_generic_extent2_d.html">GenericExtent2D</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Contains a 2d Integer size (width, height) <a href="structpvr_1_1_generic_extent2_d.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpvr_1_1_generic_extent3_d.html">GenericExtent3D</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Contains a 3D Integer size (width, height, depth) <a href="structpvr_1_1_generic_extent3_d.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpvr_1_1_generic_offset2_d.html">GenericOffset2D</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <a class="el" href="structpvr_1_1_generic_offset2_d.html" title="The GenericOffset2D contains a 16-bit 2D offset (offsetX, offsetY)">GenericOffset2D</a> contains a 16-bit 2D offset (offsetX, offsetY) <a href="structpvr_1_1_generic_offset2_d.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpvr_1_1_generic_offset3_d.html">GenericOffset3D</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <a class="el" href="structpvr_1_1_generic_offset3_d.html" title="The GenericOffset3D contains the offsets in 3 dimension (offsetX, offsetY, offsetZ)">GenericOffset3D</a> contains the offsets in 3 dimension (offsetX, offsetY, offsetZ) <a href="structpvr_1_1_generic_offset3_d.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpvr_1_1hash.html">hash</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class template denoting a hash. Specializations only - no default implementation. (int32_t/int64_t/uint32_t/uint64_t/string) <a href="structpvr_1_1hash.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpvr_1_1hash_3_01int32__t_01_4.html">hash&lt; int32_t &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Template specialization of hash specifically for int32_t <a href="structpvr_1_1hash_3_01int32__t_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpvr_1_1hash_3_01int64__t_01_4.html">hash&lt; int64_t &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Template specialization of hash specifically for int64_t <a href="structpvr_1_1hash_3_01int64__t_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpvr_1_1hash_3_01std_1_1basic__string_3_01_t_01_4_01_4.html">hash&lt; std::basic_string&lt; T &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Template specialization of hash specifically for an std::basic_string <a href="structpvr_1_1hash_3_01std_1_1basic__string_3_01_t_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpvr_1_1hash_3_01uint32__t_01_4.html">hash&lt; uint32_t &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Template specialization of hash specifically for uint32_t <a href="structpvr_1_1hash_3_01uint32__t_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpvr_1_1hash_3_01uint64__t_01_4.html">hash&lt; uint64_t &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Template specialization of hash specifically for uint64_t <a href="structpvr_1_1hash_3_01uint64__t_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1_hash_compile_time.html">HashCompileTime</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Template specialization for unsigned char values. <a href="classpvr_1_1_hash_compile_time.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1hasher__helper.html">hasher_helper</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A dummy helper. <a href="classpvr_1_1hasher__helper.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1hasher__helper_3_01hashvalue_00_01first_01_4.html">hasher_helper&lt; hashvalue, first &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Template specialization for uint32_t values. <a href="classpvr_1_1hasher__helper_3_01hashvalue_00_01first_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1hasher__helper_3_01hashvalue_00_01first_00_01dummy_8_8_8_01_4.html">hasher_helper&lt; hashvalue, first, dummy... &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Template specialization for uint32_t values. <a href="classpvr_1_1hasher__helper_3_01hashvalue_00_01first_00_01dummy_8_8_8_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1_i_asset_provider.html">IAssetProvider</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <a class="el" href="classpvr_1_1_i_asset_provider.html" title="The IAssetProvider interface marks a class that provides the getAssetStream function to load assets i...">IAssetProvider</a> interface marks a class that provides the getAssetStream function to load assets in a platform independent way. <a href="classpvr_1_1_i_asset_provider.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpvr_1_1_image_data_format.html">ImageDataFormat</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents an image format, including pixel format(channels/bits per channel), datatype and colorspace. /summary&gt;  <a href="structpvr_1_1_image_data_format.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpvr_1_1_image_layers_size.html">ImageLayersSize</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Structure describes the number of array levels and mip levels an image contains <a href="structpvr_1_1_image_layers_size.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpvr_1_1_image_range.html">ImageRange</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents a specific 3-D range in an image (an orthogonal cuboid anywhere in the image) <a href="structpvr_1_1_image_range.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpvr_1_1_image_resolve_range.html">ImageResolveRange</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents an image resolve operation <a href="structpvr_1_1_image_resolve_range.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpvr_1_1_image_storage_format.html">ImageStorageFormat</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extends the <a class="el" href="structpvr_1_1_image_data_format.html" title="Represents an image format, including pixel format(channels/bits per channel), datatype and colorspac...">ImageDataFormat</a> with mipmaps and number of Samples. <a href="structpvr_1_1_image_storage_format.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpvr_1_1_image_storage_format_compressed.html">ImageStorageFormatCompressed</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Describes a Compressed format. Compressed formats provide less information than the uncompressed format, as they can only be accessed "black box". <a href="structpvr_1_1_image_storage_format_compressed.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpvr_1_1_image_subresource.html">ImageSubresource</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Describes a single "layer" of an image: a single array layer of a single mip level, or the offset of a layer range. <a href="structpvr_1_1_image_subresource.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpvr_1_1_image_subresource_layers.html">ImageSubresourceLayers</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents a specific subresource layer: A specified Array Layer and Mipmap level of specific aspect of an image <a href="structpvr_1_1_image_subresource_layers.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpvr_1_1_image_subresource_range.html">ImageSubresourceRange</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents a subresource range: A specified range of Array Layers and Mipmap levels of specific aspect of an image <a href="structpvr_1_1_image_subresource_range.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1_index_out_of_range.html">IndexOutOfRange</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A simple std::runtime_error wrapper for throwing exceptions when attempting to use index out of range <a href="classpvr_1_1_index_out_of_range.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1_invalid_argument_error.html">InvalidArgumentError</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A simple std::runtime_error wrapper for throwing exceptions when invalid arguments are provided <a href="classpvr_1_1_invalid_argument_error.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1_invalid_data_error.html">InvalidDataError</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A simple std::runtime_error wrapper for throwing exceptions when invalid data is provided <a href="classpvr_1_1_invalid_data_error.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1_invalid_operation_error.html">InvalidOperationError</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A simple std::runtime_error wrapper for throwing exceptions when invalid operations are attempted <a href="classpvr_1_1_invalid_operation_error.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1_locked_queue.html">LockedQueue</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A simple adapter for the BlockingConcurrentQueue that simplifies common use cases <a href="classpvr_1_1_locked_queue.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1_operation_failed_error.html">OperationFailedError</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A simple std::runtime_error wrapper for throwing exceptions when operations fail <a href="classpvr_1_1_operation_failed_error.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1_palette_expander.html">PaletteExpander</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Internally used by some texture readers. <a href="classpvr_1_1_palette_expander.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1_pixel_format.html">PixelFormat</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <a class="el" href="classpvr_1_1_pixel_format.html" title="The PixelFormat class fully defines a Pixel Format (channels, format, compression, bit width etc.).">PixelFormat</a> class fully defines a Pixel Format (channels, format, compression, bit width etc.). <a href="classpvr_1_1_pixel_format.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1_plane3d.html">Plane3d</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Uses the plane equation Ax + By + Cz + D = 0, where A B C are plane normal, xyz are position on the plane and D is distance to the plane. <a href="classpvr_1_1_plane3d.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1_pvr_error.html">PvrError</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A simple std::runtime_error wrapper for throwing generic PVR exceptions <a href="classpvr_1_1_pvr_error.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpvr_1_1_rectangle.html">Rectangle</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A class representing an axis-aligned rectangle. Internal representation TopLeft and size. <a href="structpvr_1_1_rectangle.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpvr_1_1_rectangle3_d.html">Rectangle3D</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A class representing an Axis-Aligned cuboidal region of 3D space. Internal representation offset defined as the absolute coordinates of one corner of the bounding region and extent which defines the second corner of the bounding region relative to the offset. <a href="structpvr_1_1_rectangle3_d.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpvr_1_1_stencil_state.html">StencilState</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pipeline Stencil state <a href="structpvr_1_1_stencil_state.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1_stream.html">Stream</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class is used to abstract streams of data (files, blocks of memory, resources etc.). In general a stream is considered something that can be read or written from. Specializations for many different types of streams are provided by the PowerVR Framework, the most commonly used ones being Files and Memory. The common interface and pointer types allow the <a class="el" href="classpvr_1_1_stream.html" title="This class is used to abstract streams of data (files, blocks of memory, resources etc...">Stream</a> to abstract data in a very useful manner. <a href="classpvr_1_1_stream.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1_strided_buffer.html">StridedBuffer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Representation of raw data. Used to store raw data that is logically grouped in blocks with a stride. <a href="classpvr_1_1_strided_buffer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1_string_hash.html">StringHash</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implementation of a hashed std::string with functionality for fast compares. <a href="classpvr_1_1_string_hash.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpvr_1_1_swizzle_channels.html">SwizzleChannels</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <a class="el" href="structpvr_1_1_swizzle_channels.html" title="The SwizzleChannels struct">SwizzleChannels</a> struct <a href="structpvr_1_1_swizzle_channels.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1_texture.html">Texture</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A 2D <a class="el" href="classpvr_1_1_texture.html" title="A 2D Texture asset, together with Information, Metadata and actual Pixel data. Only represents the ac...">Texture</a> asset, together with Information, Metadata and actual Pixel data. Only represents the actual data, not the API objects that may be created from it. <a href="classpvr_1_1_texture.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1_texture_decompression_error.html">TextureDecompressionError</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A simple std::runtime_error wrapper for throwing exceptions when invalid operations are attempted <a href="classpvr_1_1_texture_decompression_error.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1_texture_header.html">TextureHeader</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A class mirroring the PVR <a class="el" href="classpvr_1_1_texture.html" title="A 2D Texture asset, together with Information, Metadata and actual Pixel data. Only represents the ac...">Texture</a> container format header, and which can in general represent any <a class="el" href="classpvr_1_1_texture.html" title="A 2D Texture asset, together with Information, Metadata and actual Pixel data. Only represents the ac...">Texture</a> asset. Contains accessors functions to facilitate using the <a class="el" href="classpvr_1_1_texture.html" title="A 2D Texture asset, together with Information, Metadata and actual Pixel data. Only represents the ac...">Texture</a> data in application code. /summary&gt;  <a href="classpvr_1_1_texture_header.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1_texture_meta_data.html">TextureMetaData</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <a class="el" href="classpvr_1_1_texture_meta_data.html" title="The TextureMetaData class contains metadata of a texture. Metadata is any information that a texture ...">TextureMetaData</a> class contains metadata of a texture. Metadata is any information that a texture could be correctly loaded from file without. In most cases, metadata may still be necessary to actually USE the texture, such as winding orders, paddings, atlas information and others. <a href="classpvr_1_1_texture_meta_data.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1_time.html">Time</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class provides functions for measuring time: current time, elapsed time etc. High performance timers are used if available by the platform. <a href="classpvr_1_1_time.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1_t_p_s_camera.html">TPSCamera</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A simple third person camera implementation <a href="classpvr_1_1_t_p_s_camera.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1_t_p_s_orbit_camera.html">TPSOrbitCamera</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A simple third person orbit camera implementation <a href="classpvr_1_1_t_p_s_orbit_camera.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpvr_1_1_typed_mem.html">TypedMem</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents Free Value View that is backed by a (usually small) dynamically allocated block. <a href="structpvr_1_1_typed_mem.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1_unsupported_operation_error.html">UnsupportedOperationError</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A simple std::runtime_error wrapper for throwing exceptions when unsupported operations are attempted <a href="classpvr_1_1_unsupported_operation_error.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpvr_1_1_vertex_attribute_layout.html">VertexAttributeLayout</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class contains all the information of a Vertex Attribute's layout inside a block of memory, typically a Vertex Buffer Object. This informations is normally the DataType of the attribute, the Offset (from the beginning of the array) and the width (how many values of type DataType form an attribute). <a href="structpvr_1_1_vertex_attribute_layout.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1_windows_resource_stream.html">WindowsResourceStream</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A <a class="el" href="classpvr_1_1_stream.html" title="This class is used to abstract streams of data (files, blocks of memory, resources etc...">Stream</a> implementation that is used to access resources built in a MS Windows executable. <a href="classpvr_1_1_windows_resource_stream.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:adb9f486ad8ed5a55c94d47224583f59a"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classpvr_1_1platform_1_1_command_line_parser_1_1_parsed_command_line.html">platform::CommandLineParser::ParsedCommandLine</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr.html#adb9f486ad8ed5a55c94d47224583f59a">CommandLine</a></td></tr>
<tr class="memdesc:adb9f486ad8ed5a55c94d47224583f59a"><td class="mdescLeft">&#160;</td><td class="mdescRight">&lt; summary&gt; Typedef of the CommandLine into the pvr namespace <a href="#adb9f486ad8ed5a55c94d47224583f59a">More...</a><br /></td></tr>
<tr class="separator:adb9f486ad8ed5a55c94d47224583f59a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad4679ddc96cc1cb09f0f776bfd5f6cc8"><td class="memItemLeft" align="right" valign="top"><a id="ad4679ddc96cc1cb09f0f776bfd5f6cc8"></a>
typedef <a class="el" href="structpvr_1_1effect_1_1_effect.html">effect::Effect</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr.html#ad4679ddc96cc1cb09f0f776bfd5f6cc8">Effect</a></td></tr>
<tr class="memdesc:ad4679ddc96cc1cb09f0f776bfd5f6cc8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Typedef of the effect. <br /></td></tr>
<tr class="separator:ad4679ddc96cc1cb09f0f776bfd5f6cc8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a065d965f04c53d6e94e0e56a34289090"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="structpvr_1_1_generic_extent2_d.html">GenericExtent2D</a>&lt; uint32_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr.html#a065d965f04c53d6e94e0e56a34289090">Extent2D</a></td></tr>
<tr class="memdesc:a065d965f04c53d6e94e0e56a34289090"><td class="mdescLeft">&#160;</td><td class="mdescRight">A 2D, integer Extent typically used for Images <a href="#a065d965f04c53d6e94e0e56a34289090">More...</a><br /></td></tr>
<tr class="separator:a065d965f04c53d6e94e0e56a34289090"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc7deef434e373b18abd3b929c31e9aa"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="structpvr_1_1_generic_extent3_d.html">GenericExtent3D</a>&lt; uint32_t, uint32_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr.html#abc7deef434e373b18abd3b929c31e9aa">Extent3D</a></td></tr>
<tr class="memdesc:abc7deef434e373b18abd3b929c31e9aa"><td class="mdescLeft">&#160;</td><td class="mdescRight">A 3D, integer Extent typically used for 3D Images <a href="#abc7deef434e373b18abd3b929c31e9aa">More...</a><br /></td></tr>
<tr class="separator:abc7deef434e373b18abd3b929c31e9aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c68f9a2f58eb4afee65dee64a84ec60"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="structpvr_1_1_generic_offset2_d.html">GenericOffset2D</a>&lt; int32_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr.html#a3c68f9a2f58eb4afee65dee64a84ec60">Offset2D</a></td></tr>
<tr class="memdesc:a3c68f9a2f58eb4afee65dee64a84ec60"><td class="mdescLeft">&#160;</td><td class="mdescRight">A 2D, integer Offset typically used for Images <a href="#a3c68f9a2f58eb4afee65dee64a84ec60">More...</a><br /></td></tr>
<tr class="separator:a3c68f9a2f58eb4afee65dee64a84ec60"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c82b565cdd75fbf396893a67ce24f4d"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="structpvr_1_1_generic_offset3_d.html">GenericOffset3D</a>&lt; int32_t, int32_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr.html#a9c82b565cdd75fbf396893a67ce24f4d">Offset3D</a></td></tr>
<tr class="memdesc:a9c82b565cdd75fbf396893a67ce24f4d"><td class="mdescLeft">&#160;</td><td class="mdescRight">A 3D, integer Offset typically used for 3D Images <a href="#a9c82b565cdd75fbf396893a67ce24f4d">More...</a><br /></td></tr>
<tr class="separator:a9c82b565cdd75fbf396893a67ce24f4d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aedeecfbbd5f300d790a94b7f47277582"><td class="memItemLeft" align="right" valign="top">typedef void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr.html#aedeecfbbd5f300d790a94b7f47277582">OSApplication</a></td></tr>
<tr class="memdesc:aedeecfbbd5f300d790a94b7f47277582"><td class="mdescLeft">&#160;</td><td class="mdescRight">Native application type. <a href="#aedeecfbbd5f300d790a94b7f47277582">More...</a><br /></td></tr>
<tr class="separator:aedeecfbbd5f300d790a94b7f47277582"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af20cc023ab76f41ca5119b328748a293"><td class="memItemLeft" align="right" valign="top">typedef void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr.html#af20cc023ab76f41ca5119b328748a293">OSConnection</a></td></tr>
<tr class="memdesc:af20cc023ab76f41ca5119b328748a293"><td class="mdescLeft">&#160;</td><td class="mdescRight">Native connection type. Used as a connection between a client side window system library (Xlib, XCB) and its corresponding server side window system library. <a href="#af20cc023ab76f41ca5119b328748a293">More...</a><br /></td></tr>
<tr class="separator:af20cc023ab76f41ca5119b328748a293"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac6f2b93a38b04d593e40fb33ac919de9"><td class="memItemLeft" align="right" valign="top">typedef void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr.html#ac6f2b93a38b04d593e40fb33ac919de9">OSDATA</a></td></tr>
<tr class="memdesc:ac6f2b93a38b04d593e40fb33ac919de9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Native application data type. <a href="#ac6f2b93a38b04d593e40fb33ac919de9">More...</a><br /></td></tr>
<tr class="separator:ac6f2b93a38b04d593e40fb33ac919de9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb92095259cdb0e0a5013d243b8cdcad"><td class="memItemLeft" align="right" valign="top">typedef void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr.html#aeb92095259cdb0e0a5013d243b8cdcad">OSDisplay</a></td></tr>
<tr class="memdesc:aeb92095259cdb0e0a5013d243b8cdcad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Native display type. <a href="#aeb92095259cdb0e0a5013d243b8cdcad">More...</a><br /></td></tr>
<tr class="separator:aeb92095259cdb0e0a5013d243b8cdcad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a3c2268d5e5b11e1bc9cf97d7c337e8"><td class="memItemLeft" align="right" valign="top">typedef void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr.html#a4a3c2268d5e5b11e1bc9cf97d7c337e8">OSWindow</a></td></tr>
<tr class="memdesc:a4a3c2268d5e5b11e1bc9cf97d7c337e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Native window type. <a href="#a4a3c2268d5e5b11e1bc9cf97d7c337e8">More...</a><br /></td></tr>
<tr class="separator:a4a3c2268d5e5b11e1bc9cf97d7c337e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc19de2d5b6952c2d5471033aa4f2563"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="structpvr_1_1_rectangle3_d.html">Rectangle3D</a>&lt; float &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr.html#afc19de2d5b6952c2d5471033aa4f2563">Rectangle3Df</a></td></tr>
<tr class="memdesc:afc19de2d5b6952c2d5471033aa4f2563"><td class="mdescLeft">&#160;</td><td class="mdescRight">A float 3D rectangle <a href="#afc19de2d5b6952c2d5471033aa4f2563">More...</a><br /></td></tr>
<tr class="separator:afc19de2d5b6952c2d5471033aa4f2563"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a799b34b4c6caf281d54db6a9756dc39d"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="structpvr_1_1_rectangle3_d.html">Rectangle3D</a>&lt; int32_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr.html#a799b34b4c6caf281d54db6a9756dc39d">Rectangle3Di</a></td></tr>
<tr class="memdesc:a799b34b4c6caf281d54db6a9756dc39d"><td class="mdescLeft">&#160;</td><td class="mdescRight">An integer 3D rectangle <a href="#a799b34b4c6caf281d54db6a9756dc39d">More...</a><br /></td></tr>
<tr class="separator:a799b34b4c6caf281d54db6a9756dc39d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba0728db2b6aa21ad82b263a102fec44"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="structpvr_1_1_rectangle.html">Rectangle</a>&lt; float &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr.html#aba0728db2b6aa21ad82b263a102fec44">Rectanglef</a></td></tr>
<tr class="memdesc:aba0728db2b6aa21ad82b263a102fec44"><td class="mdescLeft">&#160;</td><td class="mdescRight">A floating point 2D rectangle <a href="#aba0728db2b6aa21ad82b263a102fec44">More...</a><br /></td></tr>
<tr class="separator:aba0728db2b6aa21ad82b263a102fec44"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a779802ae077693e9183007cfbedf47d4"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="structpvr_1_1_rectangle.html">Rectangle</a>&lt; int32_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr.html#a779802ae077693e9183007cfbedf47d4">Rectanglei</a></td></tr>
<tr class="memdesc:a779802ae077693e9183007cfbedf47d4"><td class="mdescLeft">&#160;</td><td class="mdescRight">An integer 2D rectangle <a href="#a779802ae077693e9183007cfbedf47d4">More...</a><br /></td></tr>
<tr class="separator:a779802ae077693e9183007cfbedf47d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a870616cf592ddd3bd544f6c519ccac5f"><td class="memItemLeft" align="right" valign="top">typedef ::std::vector&lt; unsigned char &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr.html#a870616cf592ddd3bd544f6c519ccac5f">UInt8Buffer</a></td></tr>
<tr class="memdesc:a870616cf592ddd3bd544f6c519ccac5f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents a buffer of Unsigned Bytes. Used to store raw data. <a href="#a870616cf592ddd3bd544f6c519ccac5f">More...</a><br /></td></tr>
<tr class="separator:a870616cf592ddd3bd544f6c519ccac5f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f1b3a4b714cc874e267883662058a19"><td class="memItemLeft" align="right" valign="top">typedef unsigned short&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr.html#a2f1b3a4b714cc874e267883662058a19">utf16</a></td></tr>
<tr class="memdesc:a2f1b3a4b714cc874e267883662058a19"><td class="mdescLeft">&#160;</td><td class="mdescRight">A UTF-16 (unsigned) character. 16-bit unsigned Integer. <a href="#a2f1b3a4b714cc874e267883662058a19">More...</a><br /></td></tr>
<tr class="separator:a2f1b3a4b714cc874e267883662058a19"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae281450f4795e25d5ce35d674b17249b"><td class="memItemLeft" align="right" valign="top">typedef unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr.html#ae281450f4795e25d5ce35d674b17249b">utf32</a></td></tr>
<tr class="memdesc:ae281450f4795e25d5ce35d674b17249b"><td class="mdescLeft">&#160;</td><td class="mdescRight">A UTF-32 (unsigned) character. 32-bit unsigned Integer. <a href="#ae281450f4795e25d5ce35d674b17249b">More...</a><br /></td></tr>
<tr class="separator:ae281450f4795e25d5ce35d674b17249b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ee58768dfb56ed9216c98178d572e17"><td class="memItemLeft" align="right" valign="top">typedef unsigned char&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr.html#a9ee58768dfb56ed9216c98178d572e17">utf8</a></td></tr>
<tr class="memdesc:a9ee58768dfb56ed9216c98178d572e17"><td class="mdescLeft">&#160;</td><td class="mdescRight">A UTF-8 (unsigned) character. 8-bit unsigned Integer. <a href="#a9ee58768dfb56ed9216c98178d572e17">More...</a><br /></td></tr>
<tr class="separator:a9ee58768dfb56ed9216c98178d572e17"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:af88eb990f89e601fa71b688d99673620"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom">{ <b>pvrTextureAllMipMaps</b> = -1
 }<tr class="memdesc:af88eb990f89e601fa71b688d99673620"><td class="mdescLeft">&#160;</td><td class="mdescRight">Flag interpreted as All mipmap levels. <a href="namespacepvr.html#af88eb990f89e601fa71b688d99673620">More...</a><br /></td></tr>
</td></tr>
<tr class="separator:af88eb990f89e601fa71b688d99673620"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a74c5d1afa51512f076dd8e5844b171c8"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr.html#a74c5d1afa51512f076dd8e5844b171c8">Api</a> { <br />
&#160;&#160;<b>Unspecified</b> = 0, 
<b>OpenGLES2</b>, 
<b>OpenGLES3</b>, 
<b>OpenGLES31</b>, 
<br />
&#160;&#160;<b>OpenGLESMaxVersion</b> = OpenGLES31, 
<b>Vulkan</b>, 
<b>NumApis</b>
<br />
 }<tr class="memdesc:a74c5d1afa51512f076dd8e5844b171c8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enumeration of all API types supported by this implementation <a href="namespacepvr.html#a74c5d1afa51512f076dd8e5844b171c8">More...</a><br /></td></tr>
</td></tr>
<tr class="separator:a74c5d1afa51512f076dd8e5844b171c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc560f133c0bcec5adff02183b4a9386"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr.html#afc560f133c0bcec5adff02183b4a9386">BlendFactor</a> : uint8_t { <br />
&#160;&#160;<a class="el" href="namespacepvr.html#afc560f133c0bcec5adff02183b4a9386ad7ed4ee1df437474d005188535f74875">BlendFactor::Zero</a>, 
<a class="el" href="namespacepvr.html#afc560f133c0bcec5adff02183b4a9386a06c2cea18679d64399783748fa367bdd">BlendFactor::One</a>, 
<a class="el" href="namespacepvr.html#afc560f133c0bcec5adff02183b4a9386a2ad714e29d37896d79187312086bc6fe">BlendFactor::SrcColor</a>, 
<a class="el" href="namespacepvr.html#afc560f133c0bcec5adff02183b4a9386a09d3240b4e2481b1a729da24e9bfddf7">BlendFactor::OneMinusSrcColor</a>, 
<br />
&#160;&#160;<a class="el" href="namespacepvr.html#afc560f133c0bcec5adff02183b4a9386afaedf511c99a5461048fd6a3b73da26c">BlendFactor::DstColor</a>, 
<a class="el" href="namespacepvr.html#afc560f133c0bcec5adff02183b4a9386a09f1a054ebd4d3850fd248bd2fa7b325">BlendFactor::OneMinusDstColor</a>, 
<a class="el" href="namespacepvr.html#afc560f133c0bcec5adff02183b4a9386ad5c7b7f0102df3f7305c43f73fc3a498">BlendFactor::SrcAlpha</a>, 
<a class="el" href="namespacepvr.html#afc560f133c0bcec5adff02183b4a9386ac00a6016489cff63d50d489ce52254cc">BlendFactor::OneMinusSrcAlpha</a>, 
<br />
&#160;&#160;<a class="el" href="namespacepvr.html#afc560f133c0bcec5adff02183b4a9386af72dbe2436b38a39e5927ed644e6818b">BlendFactor::DstAlpha</a>, 
<a class="el" href="namespacepvr.html#afc560f133c0bcec5adff02183b4a9386a4132e4b87a8d461be2c6ee8fc620cfb2">BlendFactor::OneMinusDstAlpha</a>, 
<a class="el" href="namespacepvr.html#afc560f133c0bcec5adff02183b4a9386aeb8eb99f8eea9079c0e76d5ce7301dd3">BlendFactor::ConstantColor</a>, 
<a class="el" href="namespacepvr.html#afc560f133c0bcec5adff02183b4a9386a13ab8deb1c606ab17745354b4e92f43a">BlendFactor::OneMinusConstantColor</a>, 
<br />
&#160;&#160;<a class="el" href="namespacepvr.html#afc560f133c0bcec5adff02183b4a9386a6f0229db491c3b01860363456dc57288">BlendFactor::ConstantAlpha</a>, 
<a class="el" href="namespacepvr.html#afc560f133c0bcec5adff02183b4a9386a9a1874144125c69e93ec99f17e985e41">BlendFactor::OneMinusConstantAlpha</a>, 
<a class="el" href="namespacepvr.html#afc560f133c0bcec5adff02183b4a9386a87c65d6ae5c79e8a05482365776bd959">BlendFactor::Src1Color</a>, 
<a class="el" href="namespacepvr.html#afc560f133c0bcec5adff02183b4a9386ac1686472488cf32c06cc257f4e8ac04f">BlendFactor::OneMinusSrc1Color</a>, 
<br />
&#160;&#160;<a class="el" href="namespacepvr.html#afc560f133c0bcec5adff02183b4a9386aa69d96453c025ed62b3276e892e59e39">BlendFactor::Src1Alpha</a>, 
<a class="el" href="namespacepvr.html#afc560f133c0bcec5adff02183b4a9386a88dfdcc65a80f412d0330f00579ab7f2">BlendFactor::OneMinusSrc1Alpha</a>, 
<b>NumBlendFactor</b>, 
<b>DefaultSrcRgba</b> = One, 
<br />
&#160;&#160;<b>DefaultDestRgba</b> = Zero
<br />
 }<tr class="memdesc:afc560f133c0bcec5adff02183b4a9386"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specfies how the rgba blending facors are computed for source and destination fragments. <a href="namespacepvr.html#afc560f133c0bcec5adff02183b4a9386">More...</a><br /></td></tr>
</td></tr>
<tr class="separator:afc560f133c0bcec5adff02183b4a9386"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78be6b6f15903b90d6a9d575ebf6d353"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr.html#a78be6b6f15903b90d6a9d575ebf6d353">BlendOp</a> : uint32_t { <br />
&#160;&#160;<a class="el" href="namespacepvr.html#a78be6b6f15903b90d6a9d575ebf6d353aec211f7c20af43e742bf2570c3cb84f9">BlendOp::Add</a>, 
<a class="el" href="namespacepvr.html#a78be6b6f15903b90d6a9d575ebf6d353a1d9baf077ee87921f57a8fe42d510b65">BlendOp::Subtract</a>, 
<a class="el" href="namespacepvr.html#a78be6b6f15903b90d6a9d575ebf6d353abd5458190996e76988cb2f27a820c685">BlendOp::ReverseSubtract</a>, 
<a class="el" href="namespacepvr.html#a78be6b6f15903b90d6a9d575ebf6d353a78d811e98514cd165dda532286610fd2">BlendOp::Min</a>, 
<br />
&#160;&#160;<a class="el" href="namespacepvr.html#a78be6b6f15903b90d6a9d575ebf6d353a6a061313d22e51e0f25b7cd4dc065233">BlendOp::Max</a>, 
<b>NumBlendFunc</b>, 
<b>Default</b> = Add
<br />
 }<tr class="memdesc:a78be6b6f15903b90d6a9d575ebf6d353"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enumeration of the blend operations (determine how a new pixel (source color) is combined with a pixel already in the framebuffer (destination color). <a href="namespacepvr.html#a78be6b6f15903b90d6a9d575ebf6d353">More...</a><br /></td></tr>
</td></tr>
<tr class="separator:a78be6b6f15903b90d6a9d575ebf6d353"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa6ac287ad32e4b14937cee7ac81fb85e"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr.html#aa6ac287ad32e4b14937cee7ac81fb85e">BufferUsageFlags</a> : uint32_t { <br />
&#160;&#160;<a class="el" href="namespacepvr.html#aa6ac287ad32e4b14937cee7ac81fb85eac1b703f2c13fac2fff3e72d3e307d4c0">BufferUsageFlags::TransferSrc</a> = 0x00000001, 
<a class="el" href="namespacepvr.html#aa6ac287ad32e4b14937cee7ac81fb85ea155895f4426d6fc97295ca2de160fd20">BufferUsageFlags::TransferDest</a> = 0x00000002, 
<a class="el" href="namespacepvr.html#aa6ac287ad32e4b14937cee7ac81fb85ea4b43da703340c8273da56cf3445c6754">BufferUsageFlags::UniformTexelBuffer</a> = 0x00000004, 
<a class="el" href="namespacepvr.html#aa6ac287ad32e4b14937cee7ac81fb85eaae1f93780c3073aeadaf118d550f0c65">BufferUsageFlags::StorageTexelBuffer</a> = 0x00000008, 
<br />
&#160;&#160;<a class="el" href="namespacepvr.html#aa6ac287ad32e4b14937cee7ac81fb85ea88f133adfed6c854e5731cdffbf208cf">BufferUsageFlags::UniformBuffer</a> = 0x00000010, 
<a class="el" href="namespacepvr.html#aa6ac287ad32e4b14937cee7ac81fb85ea439f57c2c466c89db942b3de48298b2b">BufferUsageFlags::StorageBuffer</a> = 0x00000020, 
<a class="el" href="namespacepvr.html#aa6ac287ad32e4b14937cee7ac81fb85ea7c3895116254ff0417e58b6286de27c0">BufferUsageFlags::IndexBuffer</a> = 0x00000040, 
<a class="el" href="namespacepvr.html#aa6ac287ad32e4b14937cee7ac81fb85ea10461f19cdb5aadba2fc9986be6400bd">BufferUsageFlags::VertexBuffer</a> = 0x00000080, 
<br />
&#160;&#160;<a class="el" href="namespacepvr.html#aa6ac287ad32e4b14937cee7ac81fb85ea7e5abafe55b7f7e20d417fe9c967d69e">BufferUsageFlags::IndirectBuffer</a> = 0x00000100, 
<b>Count</b> = 10
<br />
 }<tr class="memdesc:aa6ac287ad32e4b14937cee7ac81fb85e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enumeration of all supported buffer use types. <a href="namespacepvr.html#aa6ac287ad32e4b14937cee7ac81fb85e">More...</a><br /></td></tr>
</td></tr>
<tr class="separator:aa6ac287ad32e4b14937cee7ac81fb85e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af9ca1aead0a3149b0af3842d03bc6cd4"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr.html#af9ca1aead0a3149b0af3842d03bc6cd4">Capability</a> : uint8_t { <a class="el" href="namespacepvr.html#af9ca1aead0a3149b0af3842d03bc6cd4ab4080bdf74febf04d578ff105cce9d3f">Capability::Unsupported</a>, 
<a class="el" href="namespacepvr.html#af9ca1aead0a3149b0af3842d03bc6cd4a11efd9ae6f76e706e3f1b34d97584ebc">Capability::Immutable</a>, 
<a class="el" href="namespacepvr.html#af9ca1aead0a3149b0af3842d03bc6cd4ad924522d30d6615e9f71e91504364a9d">Capability::Mutable</a>
 }<tr class="memdesc:af9ca1aead0a3149b0af3842d03bc6cd4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Capability supported values. <a href="namespacepvr.html#af9ca1aead0a3149b0af3842d03bc6cd4">More...</a><br /></td></tr>
</td></tr>
<tr class="separator:af9ca1aead0a3149b0af3842d03bc6cd4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a675b14a2f2079f7f72e7f2ad35d13de7"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr.html#a675b14a2f2079f7f72e7f2ad35d13de7">ColorChannelFlags</a> : uint32_t { <br />
&#160;&#160;<a class="el" href="namespacepvr.html#a675b14a2f2079f7f72e7f2ad35d13de7ae1e1d3d40573127e9ee0480caf1283d6">ColorChannelFlags::R</a> = 0x01, 
<a class="el" href="namespacepvr.html#a675b14a2f2079f7f72e7f2ad35d13de7adfcf28d0734569a6a693bc8194de62bf">ColorChannelFlags::G</a> = 0x02, 
<a class="el" href="namespacepvr.html#a675b14a2f2079f7f72e7f2ad35d13de7a9d5ed678fe57bcca610140957afab571">ColorChannelFlags::B</a> = 0x04, 
<a class="el" href="namespacepvr.html#a675b14a2f2079f7f72e7f2ad35d13de7a7fc56270e7a70fa81a5935b72eacbe29">ColorChannelFlags::A</a> = 0x08, 
<br />
&#160;&#160;<a class="el" href="namespacepvr.html#a675b14a2f2079f7f72e7f2ad35d13de7a6adf97f83acf6453d4a6a4b1070f3754">ColorChannelFlags::None</a> = 0, 
<b>All</b> = R | G | B | A
<br />
 }<tr class="memdesc:a675b14a2f2079f7f72e7f2ad35d13de7"><td class="mdescLeft">&#160;</td><td class="mdescRight">ChannelWriteMask enable/ disable writting to channel bits. <a href="namespacepvr.html#a675b14a2f2079f7f72e7f2ad35d13de7">More...</a><br /></td></tr>
</td></tr>
<tr class="separator:a675b14a2f2079f7f72e7f2ad35d13de7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b94afe6b8a7c21e8f8ddee1f7b5cb91"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr.html#a1b94afe6b8a7c21e8f8ddee1f7b5cb91">ColorSpace</a> { <a class="el" href="namespacepvr.html#a1b94afe6b8a7c21e8f8ddee1f7b5cb91a4c8bf835da6d934b50f620cdd0cc3913">ColorSpace::lRGB</a>, 
<a class="el" href="namespacepvr.html#a1b94afe6b8a7c21e8f8ddee1f7b5cb91a9ed33d9be17d174aeb4393a989586ed9">ColorSpace::sRGB</a>, 
<b>NumSpaces</b>
 }<tr class="memdesc:a1b94afe6b8a7c21e8f8ddee1f7b5cb91"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enumeration of Colorspaces (Linear, SRGB). <a href="namespacepvr.html#a1b94afe6b8a7c21e8f8ddee1f7b5cb91">More...</a><br /></td></tr>
</td></tr>
<tr class="separator:a1b94afe6b8a7c21e8f8ddee1f7b5cb91"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24a87498f839b45b6e1bc3c8b2ca20fc"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr.html#a24a87498f839b45b6e1bc3c8b2ca20fc">CompareOp</a> : uint32_t { <br />
&#160;&#160;<a class="el" href="namespacepvr.html#a24a87498f839b45b6e1bc3c8b2ca20fca6e7b34fa59e1bd229b207892956dc41c">CompareOp::Never</a> = 0, 
<a class="el" href="namespacepvr.html#a24a87498f839b45b6e1bc3c8b2ca20fca1cfdf0e8d0c87a228c1f40d9bee7888b">CompareOp::Less</a> = 1, 
<a class="el" href="namespacepvr.html#a24a87498f839b45b6e1bc3c8b2ca20fcaf5f286e73bda105e538310b3190f75c5">CompareOp::Equal</a> = 2, 
<a class="el" href="namespacepvr.html#a24a87498f839b45b6e1bc3c8b2ca20fcad3e6fdac55bb7b0edd7834c968ba1f38">CompareOp::LessEqual</a> = 3, 
<br />
&#160;&#160;<a class="el" href="namespacepvr.html#a24a87498f839b45b6e1bc3c8b2ca20fca8768a6821cd735aea4f5b0df88c1fc6a">CompareOp::Greater</a> = 4, 
<a class="el" href="namespacepvr.html#a24a87498f839b45b6e1bc3c8b2ca20fca19bb0af2c3c530538cb41aff7f235b96">CompareOp::NotEqual</a> = 5, 
<a class="el" href="namespacepvr.html#a24a87498f839b45b6e1bc3c8b2ca20fca758b05d899def79c9eb864ad4f96be1f">CompareOp::GreaterEqual</a> = 6, 
<a class="el" href="namespacepvr.html#a24a87498f839b45b6e1bc3c8b2ca20fca68eec46437c384d8dad18d5464ebc35c">CompareOp::Always</a> = 7, 
<br />
&#160;&#160;<b>NumComparisonMode</b>, 
<b>DefaultDepthFunc</b> = Less, 
<b>DefaultStencilFunc</b> = Always
<br />
 }<tr class="memdesc:a24a87498f839b45b6e1bc3c8b2ca20fc"><td class="mdescLeft">&#160;</td><td class="mdescRight">An enumeration that defines Comparison operations (equal, less or equal etc.). Especially used in API classes for functions like depth testing. <a href="namespacepvr.html#a24a87498f839b45b6e1bc3c8b2ca20fc">More...</a><br /></td></tr>
</td></tr>
<tr class="separator:a24a87498f839b45b6e1bc3c8b2ca20fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7cfc7d042b44f46e4d5dfbb32d0f16b1"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr.html#a7cfc7d042b44f46e4d5dfbb32d0f16b1">CompressedPixelFormat</a> { <br />
&#160;&#160;<b>PVRTCI_2bpp_RGB</b>, 
<b>PVRTCI_2bpp_RGBA</b>, 
<b>PVRTCI_4bpp_RGB</b>, 
<b>PVRTCI_4bpp_RGBA</b>, 
<br />
&#160;&#160;<b>PVRTCII_2bpp</b>, 
<b>PVRTCII_4bpp</b>, 
<b>ETC1</b>, 
<b>DXT1</b>, 
<br />
&#160;&#160;<b>DXT2</b>, 
<b>DXT3</b>, 
<b>DXT4</b>, 
<b>DXT5</b>, 
<br />
&#160;&#160;<b>BC1</b> = DXT1, 
<b>BC2</b> = DXT3, 
<b>BC3</b> = DXT5, 
<b>BC4</b>, 
<br />
&#160;&#160;<b>BC5</b>, 
<b>BC6</b>, 
<b>BC7</b>, 
<b>UYVY</b>, 
<br />
&#160;&#160;<b>YUY2</b>, 
<b>BW1bpp</b>, 
<b>SharedExponentR9G9B9E5</b>, 
<b>RGBG8888</b>, 
<br />
&#160;&#160;<b>GRGB8888</b>, 
<b>ETC2_RGB</b>, 
<b>ETC2_RGBA</b>, 
<b>ETC2_RGB_A1</b>, 
<br />
&#160;&#160;<b>EAC_R11</b>, 
<b>EAC_RG11</b>, 
<b>ASTC_4x4</b>, 
<b>ASTC_5x4</b>, 
<br />
&#160;&#160;<b>ASTC_5x5</b>, 
<b>ASTC_6x5</b>, 
<b>ASTC_6x6</b>, 
<b>ASTC_8x5</b>, 
<br />
&#160;&#160;<b>ASTC_8x6</b>, 
<b>ASTC_8x8</b>, 
<b>ASTC_10x5</b>, 
<b>ASTC_10x6</b>, 
<br />
&#160;&#160;<b>ASTC_10x8</b>, 
<b>ASTC_10x10</b>, 
<b>ASTC_12x10</b>, 
<b>ASTC_12x12</b>, 
<br />
&#160;&#160;<b>ASTC_3x3x3</b>, 
<b>ASTC_4x3x3</b>, 
<b>ASTC_4x4x3</b>, 
<b>ASTC_4x4x4</b>, 
<br />
&#160;&#160;<b>ASTC_5x4x4</b>, 
<b>ASTC_5x5x4</b>, 
<b>ASTC_5x5x5</b>, 
<b>ASTC_6x5x5</b>, 
<br />
&#160;&#160;<b>ASTC_6x6x5</b>, 
<b>ASTC_6x6x6</b>, 
<b>NumCompressedPFs</b>
<br />
 }<tr class="memdesc:a7cfc7d042b44f46e4d5dfbb32d0f16b1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enumeration of all known Compressed pixel formats. <a href="namespacepvr.html#a7cfc7d042b44f46e4d5dfbb32d0f16b1">More...</a><br /></td></tr>
</td></tr>
<tr class="separator:a7cfc7d042b44f46e4d5dfbb32d0f16b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a87b409df225dee78541eb74988f4e20c"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr.html#a87b409df225dee78541eb74988f4e20c">CubeFace</a> : uint32_t { <br />
&#160;&#160;<a class="el" href="namespacepvr.html#a87b409df225dee78541eb74988f4e20ca9f082d04c481aab268b9f614d2ffd129">CubeFace::PositiveX</a> = 0, 
<a class="el" href="namespacepvr.html#a87b409df225dee78541eb74988f4e20ca963a8a64a09d54efc81b136ca6be21b2">CubeFace::NegativeX</a>, 
<a class="el" href="namespacepvr.html#a87b409df225dee78541eb74988f4e20cac53c385ced96bd629c0f45a902aceba3">CubeFace::PositiveY</a>, 
<a class="el" href="namespacepvr.html#a87b409df225dee78541eb74988f4e20cae4d5f02ceecd15caf66e9f0b2393c86b">CubeFace::NegativeY</a>, 
<br />
&#160;&#160;<a class="el" href="namespacepvr.html#a87b409df225dee78541eb74988f4e20ca1921c16ffdafaf04e378ca1b6774c0ce">CubeFace::PositiveZ</a>, 
<a class="el" href="namespacepvr.html#a87b409df225dee78541eb74988f4e20cada76df034cd139bd515761c8bb8e3090">CubeFace::NegativeZ</a>
<br />
 }<tr class="memdesc:a87b409df225dee78541eb74988f4e20c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enumeration of the six faces of a Cube <a href="namespacepvr.html#a87b409df225dee78541eb74988f4e20c">More...</a><br /></td></tr>
</td></tr>
<tr class="separator:a87b409df225dee78541eb74988f4e20c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7924324f96dc973225ad3c532cc72309"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr.html#a7924324f96dc973225ad3c532cc72309">DataType</a> { <br />
&#160;&#160;<a class="el" href="namespacepvr.html#a7924324f96dc973225ad3c532cc72309a6adf97f83acf6453d4a6a4b1070f3754">DataType::None</a>, 
<a class="el" href="namespacepvr.html#a7924324f96dc973225ad3c532cc72309a166495adc0d0f53bee6baecc577f5204">DataType::Float32</a>, 
<a class="el" href="namespacepvr.html#a7924324f96dc973225ad3c532cc72309ac06129f6e6e15c09328365e553f1dc31">DataType::Int32</a>, 
<a class="el" href="namespacepvr.html#a7924324f96dc973225ad3c532cc72309a8bd950a9d7779b83f5c30046c9aaf1cf">DataType::UInt16</a>, 
<br />
&#160;&#160;<a class="el" href="namespacepvr.html#a7924324f96dc973225ad3c532cc72309aea3495a278957dc58165e48a8945469f">DataType::RGBA</a>, 
<a class="el" href="namespacepvr.html#a7924324f96dc973225ad3c532cc72309ae192297ecf3602fabbec5f0a38ede758">DataType::ARGB</a>, 
<a class="el" href="namespacepvr.html#a7924324f96dc973225ad3c532cc72309a67cb8b94254acbfda2cdf7a916421298">DataType::D3DCOLOR</a>, 
<a class="el" href="namespacepvr.html#a7924324f96dc973225ad3c532cc72309aa061360f8e01902202f21849c40a1105">DataType::UBYTE4</a>, 
<br />
&#160;&#160;<a class="el" href="namespacepvr.html#a7924324f96dc973225ad3c532cc72309aff4e3dcc2ead0fa54993ccbf4eda1ae8">DataType::DEC3N</a>, 
<a class="el" href="namespacepvr.html#a7924324f96dc973225ad3c532cc72309a32e326bf2ef732551075db8987a1408c">DataType::Fixed16_16</a>, 
<a class="el" href="namespacepvr.html#a7924324f96dc973225ad3c532cc72309ab31df9c476d20e85ff898121efe11b5a">DataType::UInt8</a>, 
<a class="el" href="namespacepvr.html#a7924324f96dc973225ad3c532cc72309a39bc2ae44b184207f560ff8619823208">DataType::Int16</a>, 
<br />
&#160;&#160;<a class="el" href="namespacepvr.html#a7924324f96dc973225ad3c532cc72309a0f224678669aa9f1b9e9dee8c544912a">DataType::Int16Norm</a>, 
<a class="el" href="namespacepvr.html#a7924324f96dc973225ad3c532cc72309a7d839b2c12bfd40ac121b4cc9e81c539">DataType::Int8</a>, 
<a class="el" href="namespacepvr.html#a7924324f96dc973225ad3c532cc72309a74f0eeb95bdbf29bcc7eb2b6431c13f2">DataType::Int8Norm</a>, 
<a class="el" href="namespacepvr.html#a7924324f96dc973225ad3c532cc72309a784d359bf21cc07236f54855d9aab91a">DataType::UInt8Norm</a>, 
<br />
&#160;&#160;<a class="el" href="namespacepvr.html#a7924324f96dc973225ad3c532cc72309ab296ec5fbf49139c807bd99ba7f7dee8">DataType::UInt16Norm</a>, 
<a class="el" href="namespacepvr.html#a7924324f96dc973225ad3c532cc72309ae7956ed7be1c5025a27ed3cb42a396bd">DataType::UInt32</a>, 
<a class="el" href="namespacepvr.html#a7924324f96dc973225ad3c532cc72309adce7d10c2f9ffc8ed9e7b6a3f7d8ba6c">DataType::ABGR</a>, 
<a class="el" href="namespacepvr.html#a7924324f96dc973225ad3c532cc72309a26e6ed77470c6f2f830ecf874e6c0d55">DataType::Float16</a>, 
<br />
&#160;&#160;<b>Custom</b> = 1000
<br />
 }<tr class="memdesc:a7924324f96dc973225ad3c532cc72309"><td class="mdescLeft">&#160;</td><td class="mdescRight">An enumeration that defines data types used throughout the Framework. Commonly used in places where raw data are used to define the types actually contained. <a href="namespacepvr.html#a7924324f96dc973225ad3c532cc72309">More...</a><br /></td></tr>
</td></tr>
<tr class="separator:a7924324f96dc973225ad3c532cc72309"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3283c5c9822ac5135fefd45a7cdd5932"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr.html#a3283c5c9822ac5135fefd45a7cdd5932">DescriptorType</a> : uint32_t { <br />
&#160;&#160;<a class="el" href="namespacepvr.html#a3283c5c9822ac5135fefd45a7cdd5932a5bca2f066df1fe641b2b779db2a63c0a">DescriptorType::Sampler</a>, 
<a class="el" href="namespacepvr.html#a3283c5c9822ac5135fefd45a7cdd5932a8cfe077ac9aea5235b0c3fda85914029">DescriptorType::CombinedImageSampler</a>, 
<a class="el" href="namespacepvr.html#a3283c5c9822ac5135fefd45a7cdd5932a4520c597ce328c250d1ca5192047d71d">DescriptorType::SampledImage</a>, 
<a class="el" href="namespacepvr.html#a3283c5c9822ac5135fefd45a7cdd5932aa078fa7ad769f9e7b53b8c42e3b7bbab">DescriptorType::StorageImage</a>, 
<br />
&#160;&#160;<a class="el" href="namespacepvr.html#a3283c5c9822ac5135fefd45a7cdd5932a4b43da703340c8273da56cf3445c6754">DescriptorType::UniformTexelBuffer</a>, 
<a class="el" href="namespacepvr.html#a3283c5c9822ac5135fefd45a7cdd5932aae1f93780c3073aeadaf118d550f0c65">DescriptorType::StorageTexelBuffer</a>, 
<a class="el" href="namespacepvr.html#a3283c5c9822ac5135fefd45a7cdd5932a88f133adfed6c854e5731cdffbf208cf">DescriptorType::UniformBuffer</a>, 
<a class="el" href="namespacepvr.html#a3283c5c9822ac5135fefd45a7cdd5932a439f57c2c466c89db942b3de48298b2b">DescriptorType::StorageBuffer</a>, 
<br />
&#160;&#160;<a class="el" href="namespacepvr.html#a3283c5c9822ac5135fefd45a7cdd5932a517b91f0588b3bf6c80ff3b19b2a7f57">DescriptorType::UniformBufferDynamic</a>, 
<a class="el" href="namespacepvr.html#a3283c5c9822ac5135fefd45a7cdd5932ada8c94227ee0e3b5cd40da12d594ad55">DescriptorType::StorageBufferDynamic</a>, 
<a class="el" href="namespacepvr.html#a3283c5c9822ac5135fefd45a7cdd5932a261d965f5dd43c6873489b68730dbe57">DescriptorType::InputAttachment</a>, 
<b>Count</b> = 12, 
<br />
&#160;&#160;<b>NumBits</b> = 4
<br />
 }<tr class="memdesc:a3283c5c9822ac5135fefd45a7cdd5932"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enumeration of all the different descriptor types. <a href="namespacepvr.html#a3283c5c9822ac5135fefd45a7cdd5932">More...</a><br /></td></tr>
</td></tr>
<tr class="separator:a3283c5c9822ac5135fefd45a7cdd5932"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ca56afd652113209f2535e7688a4189"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr.html#a1ca56afd652113209f2535e7688a4189">Face</a> : uint32_t { <br />
&#160;&#160;<a class="el" href="namespacepvr.html#a1ca56afd652113209f2535e7688a4189a6adf97f83acf6453d4a6a4b1070f3754">Face::None</a> = 0, 
<a class="el" href="namespacepvr.html#a1ca56afd652113209f2535e7688a4189a5835bab1ade0060909e31a06af2e2cde">Face::Front</a> = 1, 
<a class="el" href="namespacepvr.html#a1ca56afd652113209f2535e7688a4189a0557fa923dcee4d0f86b1409f5c2167f">Face::Back</a> = 2, 
<a class="el" href="namespacepvr.html#a1ca56afd652113209f2535e7688a4189a8be41da9b58e32ece35a2b5751f6aeb9">Face::FrontAndBack</a> = 3, 
<br />
&#160;&#160;<b>Default</b> = None
<br />
 }<tr class="memdesc:a1ca56afd652113209f2535e7688a4189"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enumeration of Face facing (front, back...). <a href="namespacepvr.html#a1ca56afd652113209f2535e7688a4189">More...</a><br /></td></tr>
</td></tr>
<tr class="separator:a1ca56afd652113209f2535e7688a4189"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a84d320093e1561f82e57776aafd947d7"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr.html#a84d320093e1561f82e57776aafd947d7">Filter</a> : uint8_t { <br />
&#160;&#160;<a class="el" href="namespacepvr.html#a84d320093e1561f82e57776aafd947d7a60494f02d440f316319dd0fad40ad007">Filter::Nearest</a>, 
<b>Linear</b>, 
<a class="el" href="namespacepvr.html#a84d320093e1561f82e57776aafd947d7a6adf97f83acf6453d4a6a4b1070f3754">Filter::None</a>, 
<a class="el" href="namespacepvr.html#a84d320093e1561f82e57776aafd947d7aec6b5414eb175379ff9efc9b3eef5814">Filter::Cubic</a>, 
<br />
&#160;&#160;<b>Default</b> = Linear, 
<b>MipDefault</b> = Linear, 
<b>Size</b> = 4
<br />
 }<tr class="memdesc:a84d320093e1561f82e57776aafd947d7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enumeration describing a filtering type of a specific dimension. In order to describe the filtering mode properly, you would have to define a Minification filter, a Magnification filter and a Mipmapping minification filter. Possible values: Nearest, Linear, Cubic, None. <a href="namespacepvr.html#a84d320093e1561f82e57776aafd947d7">More...</a><br /></td></tr>
</td></tr>
<tr class="separator:a84d320093e1561f82e57776aafd947d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa4440f5fd1256889bd3b3822002208b6"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr.html#aa4440f5fd1256889bd3b3822002208b6">GpuDatatypes</a> : uint32_t { <br />
&#160;&#160;<b>Integer</b>, 
<b>uinteger</b> = Integer, 
<b>boolean</b> = Integer, 
<b>Float</b>, 
<br />
&#160;&#160;<b>ivec2</b>, 
<b>uvec2</b> = ivec2, 
<b>bvec2</b> = ivec2, 
<b>ivec3</b>, 
<br />
&#160;&#160;<b>uvec3</b> = ivec3, 
<b>bvec3</b> = ivec3, 
<b>ivec4</b>, 
<b>uvec4</b> = ivec4, 
<br />
&#160;&#160;<b>bvec4</b> = ivec4, 
<b>vec2</b> = static_cast&lt;uint32_t&gt;(GpuDatatypesHelper::Bits::Float) | static_cast&lt;uint32_t&gt;(GpuDatatypesHelper::Bits::BitVec2) | static_cast&lt;uint32_t&gt;(GpuDatatypesHelper::Bits::BitOneCol), 
<b>vec3</b> = static_cast&lt;uint32_t&gt;(GpuDatatypesHelper::Bits::Float) | static_cast&lt;uint32_t&gt;(GpuDatatypesHelper::Bits::BitVec3) | static_cast&lt;uint32_t&gt;(GpuDatatypesHelper::Bits::BitOneCol), 
<b>vec4</b> = static_cast&lt;uint32_t&gt;(GpuDatatypesHelper::Bits::Float) | static_cast&lt;uint32_t&gt;(GpuDatatypesHelper::Bits::BitVec4) | static_cast&lt;uint32_t&gt;(GpuDatatypesHelper::Bits::BitOneCol), 
<br />
&#160;&#160;<b>mat2x2</b> = static_cast&lt;uint32_t&gt;(GpuDatatypesHelper::Bits::Float) | static_cast&lt;uint32_t&gt;(GpuDatatypesHelper::Bits::BitVec2) | static_cast&lt;uint32_t&gt;(GpuDatatypesHelper::Bits::BitMat2x), 
<b>mat2x3</b> = static_cast&lt;uint32_t&gt;(GpuDatatypesHelper::Bits::Float) | static_cast&lt;uint32_t&gt;(GpuDatatypesHelper::Bits::BitVec3) | static_cast&lt;uint32_t&gt;(GpuDatatypesHelper::Bits::BitMat2x), 
<b>mat2x4</b> = static_cast&lt;uint32_t&gt;(GpuDatatypesHelper::Bits::Float) | static_cast&lt;uint32_t&gt;(GpuDatatypesHelper::Bits::BitVec4) | static_cast&lt;uint32_t&gt;(GpuDatatypesHelper::Bits::BitMat2x), 
<b>mat3x2</b> = static_cast&lt;uint32_t&gt;(GpuDatatypesHelper::Bits::Float) | static_cast&lt;uint32_t&gt;(GpuDatatypesHelper::Bits::BitVec2) | static_cast&lt;uint32_t&gt;(GpuDatatypesHelper::Bits::BitMat3x), 
<br />
&#160;&#160;<b>mat3x3</b> = static_cast&lt;uint32_t&gt;(GpuDatatypesHelper::Bits::Float) | static_cast&lt;uint32_t&gt;(GpuDatatypesHelper::Bits::BitVec3) | static_cast&lt;uint32_t&gt;(GpuDatatypesHelper::Bits::BitMat3x), 
<b>mat3x4</b> = static_cast&lt;uint32_t&gt;(GpuDatatypesHelper::Bits::Float) | static_cast&lt;uint32_t&gt;(GpuDatatypesHelper::Bits::BitVec4) | static_cast&lt;uint32_t&gt;(GpuDatatypesHelper::Bits::BitMat3x), 
<b>mat4x2</b> = static_cast&lt;uint32_t&gt;(GpuDatatypesHelper::Bits::Float) | static_cast&lt;uint32_t&gt;(GpuDatatypesHelper::Bits::BitVec2) | static_cast&lt;uint32_t&gt;(GpuDatatypesHelper::Bits::BitMat4x), 
<b>mat4x3</b> = static_cast&lt;uint32_t&gt;(GpuDatatypesHelper::Bits::Float) | static_cast&lt;uint32_t&gt;(GpuDatatypesHelper::Bits::BitVec3) | static_cast&lt;uint32_t&gt;(GpuDatatypesHelper::Bits::BitMat4x), 
<br />
&#160;&#160;<b>mat4x4</b> = static_cast&lt;uint32_t&gt;(GpuDatatypesHelper::Bits::Float) | static_cast&lt;uint32_t&gt;(GpuDatatypesHelper::Bits::BitVec4) | static_cast&lt;uint32_t&gt;(GpuDatatypesHelper::Bits::BitMat4x), 
<b>none</b> = 0xFFFFFFFF, 
<b>structure</b> = none
<br />
 }<tr class="memdesc:aa4440f5fd1256889bd3b3822002208b6"><td class="mdescLeft">&#160;</td><td class="mdescRight">A (normally hardware-supported) GPU datatype (e.g. vec4 etc.) <a href="namespacepvr.html#aa4440f5fd1256889bd3b3822002208b6">More...</a><br /></td></tr>
</td></tr>
<tr class="separator:aa4440f5fd1256889bd3b3822002208b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee12f61a84bee4c4513c6bfad5b042d2"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr.html#aee12f61a84bee4c4513c6bfad5b042d2">ImageAspectFlags</a> : uint32_t { <br />
&#160;&#160;<b>Color</b> = 0x1, 
<b>Depth</b> = 0x2, 
<b>Stencil</b> = 0x4, 
<b>Metadata</b> = 0x8, 
<br />
&#160;&#160;<b>DepthAndStencil</b> = Depth | Stencil
<br />
 }<tr class="memdesc:aee12f61a84bee4c4513c6bfad5b042d2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enumeration of the "aspect" (or "semantics") of an image: Color, Depth, Stencil. <a href="namespacepvr.html#aee12f61a84bee4c4513c6bfad5b042d2">More...</a><br /></td></tr>
</td></tr>
<tr class="separator:aee12f61a84bee4c4513c6bfad5b042d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab98ea90165357c2f9030218c337f90bf"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr.html#ab98ea90165357c2f9030218c337f90bf">ImageType</a> { <br />
&#160;&#160;<a class="el" href="namespacepvr.html#ab98ea90165357c2f9030218c337f90bfa4be6a4b9c4d4594764eb625d5c146fff">ImageType::Image1D</a>, 
<a class="el" href="namespacepvr.html#ab98ea90165357c2f9030218c337f90bfab696e5f895616f606a8be85892c374a9">ImageType::Image2D</a>, 
<a class="el" href="namespacepvr.html#ab98ea90165357c2f9030218c337f90bfa2d4c32ae3db71aee7bf3a801d15f5075">ImageType::Image3D</a>, 
<a class="el" href="namespacepvr.html#ab98ea90165357c2f9030218c337f90bfa9aeb35984c497717cce0044620fc964a">ImageType::Unallocated</a>, 
<br />
&#160;&#160;<a class="el" href="namespacepvr.html#ab98ea90165357c2f9030218c337f90bfa88183b946cc5f0e8c96b2e66e1c74a7e">ImageType::Unknown</a>, 
<b>Count</b> = Image3D + 1
<br />
 }<tr class="memdesc:ab98ea90165357c2f9030218c337f90bf"><td class="mdescLeft">&#160;</td><td class="mdescRight">The dimension of an image. <a href="namespacepvr.html#ab98ea90165357c2f9030218c337f90bf">More...</a><br /></td></tr>
</td></tr>
<tr class="separator:ab98ea90165357c2f9030218c337f90bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a43f03a43047f737186d5b90b19dcaca2"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr.html#a43f03a43047f737186d5b90b19dcaca2">ImageViewType</a> { <br />
&#160;&#160;<a class="el" href="namespacepvr.html#a43f03a43047f737186d5b90b19dcaca2a882bc3b744cc0702640a7bacf0bbcfec">ImageViewType::ImageView1D</a>, 
<a class="el" href="namespacepvr.html#a43f03a43047f737186d5b90b19dcaca2ad6677d8d1d32ba21cdf283ac165924ad">ImageViewType::ImageView2D</a>, 
<a class="el" href="namespacepvr.html#a43f03a43047f737186d5b90b19dcaca2a6698a767e1fc8afa8db1cd800d78d675">ImageViewType::ImageView3D</a>, 
<a class="el" href="namespacepvr.html#a43f03a43047f737186d5b90b19dcaca2a0e44904a008408462e8f2567465f2157">ImageViewType::ImageView2DCube</a>, 
<br />
&#160;&#160;<a class="el" href="namespacepvr.html#a43f03a43047f737186d5b90b19dcaca2aba6b5050476daa2d65fe7081478ed7a0">ImageViewType::ImageView1DArray</a>, 
<a class="el" href="namespacepvr.html#a43f03a43047f737186d5b90b19dcaca2abe5a0e508c8c71c3ab11da749a6678a7">ImageViewType::ImageView2DArray</a>, 
<a class="el" href="namespacepvr.html#a43f03a43047f737186d5b90b19dcaca2a9ffe857cfe5d3eff82077db510ca5675">ImageViewType::ImageView2DCubeArray</a>, 
<a class="el" href="namespacepvr.html#a43f03a43047f737186d5b90b19dcaca2aa9d24d469028b69a34b22604c244dfc3">ImageViewType::ImageViewUnknown</a>
<br />
 }<tr class="memdesc:a43f03a43047f737186d5b90b19dcaca2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enumeration of Texture dimensionalities. <a href="namespacepvr.html#a43f03a43047f737186d5b90b19dcaca2">More...</a><br /></td></tr>
</td></tr>
<tr class="separator:a43f03a43047f737186d5b90b19dcaca2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab40a4733df51a99c80b389348c493ac"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr.html#aab40a4733df51a99c80b389348c493ac">IndexType</a> : uint32_t { <a class="el" href="namespacepvr.html#aab40a4733df51a99c80b389348c493acac995e06991264df36fe28315304bcd6e">IndexType::IndexType16Bit</a> = static_cast&lt;uint32_t&gt;(DataType::UInt16), 
<a class="el" href="namespacepvr.html#aab40a4733df51a99c80b389348c493aca456ada99990fe2c6043f27810c550148">IndexType::IndexType32Bit</a> = static_cast&lt;uint32_t&gt;(DataType::UInt32)
 }<tr class="memdesc:aab40a4733df51a99c80b389348c493ac"><td class="mdescLeft">&#160;</td><td class="mdescRight">An enumeration that defines a type that can use as an index, typically 16 or 32 bit int. Especially used in Model classes. <a href="namespacepvr.html#aab40a4733df51a99c80b389348c493ac">More...</a><br /></td></tr>
</td></tr>
<tr class="separator:aab40a4733df51a99c80b389348c493ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aafc960d10904ec52d4d823ed66717c43"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr.html#aafc960d10904ec52d4d823ed66717c43">PackedSamplerFilter</a> : int8_t { <br />
&#160;&#160;<b>PackNone</b>, 
<b>PackNearestMipNone</b>, 
<b>PackNearestMipNearest</b>, 
<b>PackNearestMipLinear</b>, 
<br />
&#160;&#160;<b>PackLinearMipNone</b>, 
<b>PackLinearMipNearest</b>, 
<b>PackTrilinear</b>, 
<b>Size</b>, 
<br />
&#160;&#160;<b>Size</b> = 4, 
<b>Size</b>, 
<b>PackDefault</b> = PackTrilinear
<br />
 }<tr class="memdesc:aafc960d10904ec52d4d823ed66717c43"><td class="mdescLeft">&#160;</td><td class="mdescRight">This enum is made to pack all sampler filtering info in 8 bits for specific uses. Use "packSamplerFilter" and "unpackSamplerFilter". NOTE: The defined values are only the most common cases - other 8 bit values are also valid (for example, different minification and magnification filters) <a href="namespacepvr.html#aafc960d10904ec52d4d823ed66717c43">More...</a><br /></td></tr>
</td></tr>
<tr class="separator:aafc960d10904ec52d4d823ed66717c43"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acebf4429ca4e976bca1ecaf28401bd59"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr.html#acebf4429ca4e976bca1ecaf28401bd59">PolygonWindingOrder</a> : uint8_t { <a class="el" href="namespacepvr.html#acebf4429ca4e976bca1ecaf28401bd59a6baa14a02b39a3336b6bf0087473eff3">PolygonWindingOrder::FrontFaceCCW</a>, 
<a class="el" href="namespacepvr.html#acebf4429ca4e976bca1ecaf28401bd59a8331b56f0f66fa794a20609344081509">PolygonWindingOrder::FrontFaceCW</a>, 
<b>Default</b> = FrontFaceCCW
 }<tr class="memdesc:acebf4429ca4e976bca1ecaf28401bd59"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enumeration of the different front face to winding order correlations. <a href="namespacepvr.html#acebf4429ca4e976bca1ecaf28401bd59">More...</a><br /></td></tr>
</td></tr>
<tr class="separator:acebf4429ca4e976bca1ecaf28401bd59"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a95105fe432efbe2b976187f0270b6012"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr.html#a95105fe432efbe2b976187f0270b6012">PrimitiveTopology</a> : uint32_t { <br />
&#160;&#160;<a class="el" href="namespacepvr.html#a95105fe432efbe2b976187f0270b6012a1a18ff71b3df3e362a2489eef4b30003">PrimitiveTopology::PointList</a>, 
<a class="el" href="namespacepvr.html#a95105fe432efbe2b976187f0270b6012a596e1b7afe8925f3f578c716d5af8fef">PrimitiveTopology::LineList</a>, 
<a class="el" href="namespacepvr.html#a95105fe432efbe2b976187f0270b6012ae7f9e73b8edd21f420a63b3ace5768a2">PrimitiveTopology::LineStrip</a>, 
<a class="el" href="namespacepvr.html#a95105fe432efbe2b976187f0270b6012af5beeab7a1f452e5b0e9b03b44f0de92">PrimitiveTopology::TriangleList</a>, 
<br />
&#160;&#160;<a class="el" href="namespacepvr.html#a95105fe432efbe2b976187f0270b6012a1da0b9ead8b051940a89214bae22831c">PrimitiveTopology::TriangleStrip</a>, 
<a class="el" href="namespacepvr.html#a95105fe432efbe2b976187f0270b6012a18d58fde618e4a30e2dfdc122e693047">PrimitiveTopology::TriangleFan</a>, 
<a class="el" href="namespacepvr.html#a95105fe432efbe2b976187f0270b6012af951dbe32c0c5d525b8e0ec3884de6c7">PrimitiveTopology::LineListWithAdjacency</a>, 
<a class="el" href="namespacepvr.html#a95105fe432efbe2b976187f0270b6012ae6a2093eb583f16122d50acb096af542">PrimitiveTopology::LineStripWithAdjacency</a>, 
<br />
&#160;&#160;<a class="el" href="namespacepvr.html#a95105fe432efbe2b976187f0270b6012a150324739f6017972f918eff656ba998">PrimitiveTopology::TriangleListWithAdjacency</a>, 
<a class="el" href="namespacepvr.html#a95105fe432efbe2b976187f0270b6012aa8df42f3be2313042a310fb7319b4c36">PrimitiveTopology::TriangleStripWithAdjacency</a>, 
<a class="el" href="namespacepvr.html#a95105fe432efbe2b976187f0270b6012af1b220525e3cc747140a46b7e2d7532e">PrimitiveTopology::PatchList</a>, 
<b>Count</b>
<br />
 }<tr class="memdesc:a95105fe432efbe2b976187f0270b6012"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enumeration containing all possible Primitive topologies (Point, line trianglelist etc.). <a href="namespacepvr.html#a95105fe432efbe2b976187f0270b6012">More...</a><br /></td></tr>
</td></tr>
<tr class="separator:a95105fe432efbe2b976187f0270b6012"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c5fa1488e4ba61dd568718646a8c73d"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr.html#a1c5fa1488e4ba61dd568718646a8c73d">Result</a> { <br />
&#160;&#160;<b>Success</b>, 
<b>UnknownError</b>, 
<b>NotInitialized</b>, 
<b>InitializationError</b>, 
<br />
&#160;&#160;<b>UnsupportedRequest</b>, 
<b>ExitRenderFrame</b>
<br />
 }<tr class="memdesc:a1c5fa1488e4ba61dd568718646a8c73d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pre-defined Result codes (success and generic errors). <a href="namespacepvr.html#a1c5fa1488e4ba61dd568718646a8c73d">More...</a><br /></td></tr>
</td></tr>
<tr class="separator:a1c5fa1488e4ba61dd568718646a8c73d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aedec1ca92cba055434a2a27da89f5643"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr.html#aedec1ca92cba055434a2a27da89f5643">SamplerAddressMode</a> : uint8_t { <br />
&#160;&#160;<a class="el" href="namespacepvr.html#aedec1ca92cba055434a2a27da89f5643a7020426cfb0a204051be4b3053d2acc8">SamplerAddressMode::Repeat</a>, 
<a class="el" href="namespacepvr.html#aedec1ca92cba055434a2a27da89f5643a39a681a9d5ccc902bebd16a343dd7b74">SamplerAddressMode::MirrorRepeat</a>, 
<a class="el" href="namespacepvr.html#aedec1ca92cba055434a2a27da89f5643a74556551231333c36debc3d373261134">SamplerAddressMode::ClampToEdge</a>, 
<a class="el" href="namespacepvr.html#aedec1ca92cba055434a2a27da89f5643afb07f88f6f11cc5ab9c951290716f147">SamplerAddressMode::ClampToBorder</a>, 
<br />
&#160;&#160;<a class="el" href="namespacepvr.html#aedec1ca92cba055434a2a27da89f5643a01f488e80fc32761aecfbeb3d1c8f26b">SamplerAddressMode::MirrorClampToEdge</a>, 
<b>Size</b>, 
<b>Default</b> = Repeat
<br />
 }<tr class="memdesc:aedec1ca92cba055434a2a27da89f5643"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enumeration for defining texture wrapping mode: Repeat, Mirror, Clamp, Border. <a href="namespacepvr.html#aedec1ca92cba055434a2a27da89f5643">More...</a><br /></td></tr>
</td></tr>
<tr class="separator:aedec1ca92cba055434a2a27da89f5643"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac7a59f03f943f1c79a5339331fc15abe"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr.html#ac7a59f03f943f1c79a5339331fc15abe">SamplerMipmapMode</a> : uint8_t { <a class="el" href="namespacepvr.html#ac7a59f03f943f1c79a5339331fc15abea60494f02d440f316319dd0fad40ad007">SamplerMipmapMode::Nearest</a>, 
<a class="el" href="namespacepvr.html#ac7a59f03f943f1c79a5339331fc15abea32a843da6ea40ab3b17a3421ccdf671b">SamplerMipmapMode::Linear</a>, 
<b>Count</b>
 }<tr class="memdesc:ac7a59f03f943f1c79a5339331fc15abe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enumeration of mipmap modes supported for a sampler <a href="namespacepvr.html#ac7a59f03f943f1c79a5339331fc15abe">More...</a><br /></td></tr>
</td></tr>
<tr class="separator:ac7a59f03f943f1c79a5339331fc15abe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5c2a4d46bb7aa6a877a0ed8c5ba3ac8"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr.html#af5c2a4d46bb7aa6a877a0ed8c5ba3ac8">ShaderType</a> { <br />
&#160;&#160;<a class="el" href="namespacepvr.html#af5c2a4d46bb7aa6a877a0ed8c5ba3ac8a05c0d061c57b467a86d66f7529f19bb5">ShaderType::UnknownShader</a> = 0, 
<a class="el" href="namespacepvr.html#af5c2a4d46bb7aa6a877a0ed8c5ba3ac8aeb3ca4dac3e206977e0b7d998eefcc33">ShaderType::VertexShader</a>, 
<a class="el" href="namespacepvr.html#af5c2a4d46bb7aa6a877a0ed8c5ba3ac8a90a9bb4e665932b1781da33fc2f32922">ShaderType::FragmentShader</a>, 
<a class="el" href="namespacepvr.html#af5c2a4d46bb7aa6a877a0ed8c5ba3ac8a2216355d14abbc1a80dadd4f881c0f39">ShaderType::ComputeShader</a>, 
<br />
&#160;&#160;<b>TessControlShader</b>, 
<b>TessEvaluationShader</b>, 
<b>GeometryShader</b>, 
<b>RayShader</b>, 
<br />
&#160;&#160;<b>FrameShader</b>, 
<b>Count</b>
<br />
 }<tr class="memdesc:af5c2a4d46bb7aa6a877a0ed8c5ba3ac8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enumeration of all supported shader types. <a href="namespacepvr.html#af5c2a4d46bb7aa6a877a0ed8c5ba3ac8">More...</a><br /></td></tr>
</td></tr>
<tr class="separator:af5c2a4d46bb7aa6a877a0ed8c5ba3ac8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adaffc1ac547687d86eef4bb51d0533aa"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr.html#adaffc1ac547687d86eef4bb51d0533aa">StencilOp</a> : uint8_t { <br />
&#160;&#160;<a class="el" href="namespacepvr.html#adaffc1ac547687d86eef4bb51d0533aaa02bce93bff905887ad2233110bf9c49e">StencilOp::Keep</a>, 
<a class="el" href="namespacepvr.html#adaffc1ac547687d86eef4bb51d0533aaad7ed4ee1df437474d005188535f74875">StencilOp::Zero</a>, 
<a class="el" href="namespacepvr.html#adaffc1ac547687d86eef4bb51d0533aaa0ebe6df8a3ac338e0512acc741823fdb">StencilOp::Replace</a>, 
<a class="el" href="namespacepvr.html#adaffc1ac547687d86eef4bb51d0533aaa39f5ed1c9a1e48cc90401d52864202ab">StencilOp::IncrementClamp</a>, 
<br />
&#160;&#160;<a class="el" href="namespacepvr.html#adaffc1ac547687d86eef4bb51d0533aaa669ecd4a04c7b2cda3fbf54f62e180f1">StencilOp::DecrementClamp</a>, 
<a class="el" href="namespacepvr.html#adaffc1ac547687d86eef4bb51d0533aaa9b8958acb7be504bb5f55f17c0eea366">StencilOp::Invert</a>, 
<a class="el" href="namespacepvr.html#adaffc1ac547687d86eef4bb51d0533aaaaa91cb7f033b90dec9582dc5e9611732">StencilOp::IncrementWrap</a>, 
<a class="el" href="namespacepvr.html#adaffc1ac547687d86eef4bb51d0533aaa6ec565c329385c8d59333abc6a1003d1">StencilOp::DecrementWrap</a>, 
<br />
&#160;&#160;<b>NumStencilOp</b>, 
<b>Default</b> = Keep
<br />
 }<tr class="memdesc:adaffc1ac547687d86eef4bb51d0533aa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enumeration of the different stencil operations. <a href="namespacepvr.html#adaffc1ac547687d86eef4bb51d0533aa">More...</a><br /></td></tr>
</td></tr>
<tr class="separator:adaffc1ac547687d86eef4bb51d0533aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6fffa33db4623ece1088010c6f78bc9f"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr.html#a6fffa33db4623ece1088010c6f78bc9f">StepRate</a> : uint32_t { <a class="el" href="namespacepvr.html#a6fffa33db4623ece1088010c6f78bc9fab22b929ba52471a02d18bb3a4e4472e6">StepRate::Vertex</a>, 
<a class="el" href="namespacepvr.html#a6fffa33db4623ece1088010c6f78bc9fad9a17c1c9e8ef6866e4dbeef41c741b2">StepRate::Instance</a>, 
<b>Default</b> = Vertex
 }<tr class="memdesc:a6fffa33db4623ece1088010c6f78bc9f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Step rate for a vertex attribute when drawing: Per vertex, per instance, per draw. <a href="namespacepvr.html#a6fffa33db4623ece1088010c6f78bc9f">More...</a><br /></td></tr>
</td></tr>
<tr class="separator:a6fffa33db4623ece1088010c6f78bc9f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab74a3e033b17a2d3f50ee6d0299eb195"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr.html#ab74a3e033b17a2d3f50ee6d0299eb195">Swizzle</a> : uint8_t { <br />
&#160;&#160;<b>Identity</b> = 0, 
<b>Zero</b> = 1, 
<b>One</b> = 2, 
<b>R</b> = 3, 
<br />
&#160;&#160;<b>G</b> = 4, 
<b>B</b> = 5, 
<b>A</b> = 6, 
<b>Red</b> = R, 
<br />
&#160;&#160;<b>Green</b> = G, 
<b>Blue</b> = B, 
<b>Alpha</b> = A
<br />
 }<tr class="memdesc:ab74a3e033b17a2d3f50ee6d0299eb195"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enumeration of texture Swizzle mask channels. <a href="namespacepvr.html#ab74a3e033b17a2d3f50ee6d0299eb195">More...</a><br /></td></tr>
</td></tr>
<tr class="separator:ab74a3e033b17a2d3f50ee6d0299eb195"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8be7d779089afe1df56a1bf542134d0d"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr.html#a8be7d779089afe1df56a1bf542134d0d">TextureFileFormat</a> { <br />
&#160;&#160;<b>UNKNOWN</b> = 0, 
<b>KTX</b>, 
<b>DDX</b>, 
<b>PVR</b>, 
<br />
&#160;&#160;<b>TGA</b>, 
<b>BMP</b>, 
<b>DDS</b>, 
<b>JPEG</b>
<br />
 }<tr class="memdesc:a8be7d779089afe1df56a1bf542134d0d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enumerates the texture formats directly supported by the Framework. <a href="namespacepvr.html#a8be7d779089afe1df56a1bf542134d0d">More...</a><br /></td></tr>
</td></tr>
<tr class="separator:a8be7d779089afe1df56a1bf542134d0d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7449705e04c8fe948e390ea793106107"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr.html#a7449705e04c8fe948e390ea793106107">VariableScope</a> { <br />
&#160;&#160;<a class="el" href="namespacepvr.html#a7449705e04c8fe948e390ea793106107a88183b946cc5f0e8c96b2e66e1c74a7e">VariableScope::Unknown</a>, 
<a class="el" href="namespacepvr.html#a7449705e04c8fe948e390ea793106107a086247a9b57fde6eefee2a0c4752242d">VariableScope::Automatic</a>, 
<a class="el" href="namespacepvr.html#a7449705e04c8fe948e390ea793106107aa559b87068921eec05086ce5485e9784">VariableScope::Model</a>, 
<a class="el" href="namespacepvr.html#a7449705e04c8fe948e390ea793106107aa62d22910732d5343689f5117999abfa">VariableScope::Effect</a>, 
<br />
&#160;&#160;<a class="el" href="namespacepvr.html#a7449705e04c8fe948e390ea793106107a6c3a6944a808a7c0bbb6788dbec54a9f">VariableScope::Node</a>, 
<a class="el" href="namespacepvr.html#a7449705e04c8fe948e390ea793106107aa65c9562b8c9e07299be6bc0b4f3a072">VariableScope::BoneBatch</a>
<br />
 }<tr class="memdesc:a7449705e04c8fe948e390ea793106107"><td class="mdescLeft">&#160;</td><td class="mdescRight">The possible scope, or frequency of change, of a variable <a href="namespacepvr.html#a7449705e04c8fe948e390ea793106107">More...</a><br /></td></tr>
</td></tr>
<tr class="separator:a7449705e04c8fe948e390ea793106107"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f7777c11dfff8fcf4a03d85e5ab0b98"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr.html#a6f7777c11dfff8fcf4a03d85e5ab0b98">VariableType</a> { <br />
&#160;&#160;<b>UnsignedByteNorm</b>, 
<b>SignedByteNorm</b>, 
<b>UnsignedByte</b>, 
<b>SignedByte</b>, 
<br />
&#160;&#160;<b>UnsignedShortNorm</b>, 
<b>SignedShortNorm</b>, 
<b>UnsignedShort</b>, 
<b>SignedShort</b>, 
<br />
&#160;&#160;<b>UnsignedIntegerNorm</b>, 
<b>SignedIntegerNorm</b>, 
<b>UnsignedInteger</b>, 
<b>SignedInteger</b>, 
<br />
&#160;&#160;<b>SignedFloat</b>, 
<b>Float</b> = SignedFloat, 
<b>UnsignedFloat</b>, 
<b>NumVarTypes</b>
<br />
 }<tr class="memdesc:a6f7777c11dfff8fcf4a03d85e5ab0b98"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enumeration of Datatypes. <a href="namespacepvr.html#a6f7777c11dfff8fcf4a03d85e5ab0b98">More...</a><br /></td></tr>
</td></tr>
<tr class="separator:a6f7777c11dfff8fcf4a03d85e5ab0b98"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f3166dd9130684c23ff89682e4b38c8"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr.html#a7f3166dd9130684c23ff89682e4b38c8">VsyncMode</a> { <br />
&#160;&#160;<a class="el" href="namespacepvr.html#a7f3166dd9130684c23ff89682e4b38c8ad15305d7a4e34e02489c74a5ef542f36">VsyncMode::Off</a>, 
<a class="el" href="namespacepvr.html#a7f3166dd9130684c23ff89682e4b38c8a521c36a31c2762741cf0f8890cbe05e3">VsyncMode::On</a>, 
<a class="el" href="namespacepvr.html#a7f3166dd9130684c23ff89682e4b38c8a4160be5df3fc34c3b165f28616f1bd16">VsyncMode::Relaxed</a>, 
<a class="el" href="namespacepvr.html#a7f3166dd9130684c23ff89682e4b38c8a2dcff8c037093c5d3552ad532e603f9f">VsyncMode::Mailbox</a>, 
<br />
&#160;&#160;<a class="el" href="namespacepvr.html#a7f3166dd9130684c23ff89682e4b38c8ac48615a1bc4197056d522af276aa5a85">VsyncMode::Half</a>
<br />
 }<tr class="memdesc:a7f3166dd9130684c23ff89682e4b38c8"><td class="mdescLeft">&#160;</td><td class="mdescRight">The Vertical Synchronization (or lack thereof) modes, A.K.A. Presentation mode. <a href="namespacepvr.html#a7f3166dd9130684c23ff89682e4b38c8">More...</a><br /></td></tr>
</td></tr>
<tr class="separator:a7f3166dd9130684c23ff89682e4b38c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a3dc927ae582f3ec00005bf32ceb97830"><td class="memTemplParams" colspan="2">template&lt;typename t1 , typename t2 &gt; </td></tr>
<tr class="memitem:a3dc927ae582f3ec00005bf32ceb97830"><td class="memTemplItemLeft" align="right" valign="top">t1&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacepvr.html#a3dc927ae582f3ec00005bf32ceb97830">align</a> (t1 numberToAlign, t2 alignment)</td></tr>
<tr class="memdesc:a3dc927ae582f3ec00005bf32ceb97830"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aligns a given number based on the given alignment <a href="#a3dc927ae582f3ec00005bf32ceb97830">More...</a><br /></td></tr>
<tr class="separator:a3dc927ae582f3ec00005bf32ceb97830"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0303f68824c30e29b02875302cd75d96"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr.html#a0303f68824c30e29b02875302cd75d96">apiCode</a> (<a class="el" href="namespacepvr.html#a74c5d1afa51512f076dd8e5844b171c8">Api</a> api)</td></tr>
<tr class="memdesc:a0303f68824c30e29b02875302cd75d96"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a string of the specific api enum <a href="#a0303f68824c30e29b02875302cd75d96">More...</a><br /></td></tr>
<tr class="separator:a0303f68824c30e29b02875302cd75d96"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac0940447f72ad2b8777a37cd3181b5c9"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr.html#ac0940447f72ad2b8777a37cd3181b5c9">apiName</a> (<a class="el" href="namespacepvr.html#a74c5d1afa51512f076dd8e5844b171c8">Api</a> api)</td></tr>
<tr class="memdesc:ac0940447f72ad2b8777a37cd3181b5c9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the api name std::string of the given Enumeration <a href="#ac0940447f72ad2b8777a37cd3181b5c9">More...</a><br /></td></tr>
<tr class="separator:ac0940447f72ad2b8777a37cd3181b5c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad604ae533aa5f192cf745d3b37e1f7e1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr.html#ad604ae533aa5f192cf745d3b37e1f7e1">convertXYZToCubeUV</a> (float x, float y, float z, <a class="el" href="namespacepvr.html#a87b409df225dee78541eb74988f4e20c">CubeFace</a> &amp;face, float &amp;u, float &amp;v)</td></tr>
<tr class="memdesc:ad604ae533aa5f192cf745d3b37e1f7e1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts an x, y and z direction to a texture coordinate of a particular cubemap face. <a href="#ad604ae533aa5f192cf745d3b37e1f7e1">More...</a><br /></td></tr>
<tr class="separator:ad604ae533aa5f192cf745d3b37e1f7e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32304b6fe8a8ebcfdaa03d5b227da809"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr.html#a32304b6fe8a8ebcfdaa03d5b227da809">dataTypeIsNormalised</a> (<a class="el" href="namespacepvr.html#a7924324f96dc973225ad3c532cc72309">DataType</a> type)</td></tr>
<tr class="memdesc:a32304b6fe8a8ebcfdaa03d5b227da809"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return if the format is Normalized (represents a range between 0..1 for unsigned types or between -1..1 for signed types) <a href="#a32304b6fe8a8ebcfdaa03d5b227da809">More...</a><br /></td></tr>
<tr class="separator:a32304b6fe8a8ebcfdaa03d5b227da809"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4bbe49ea1e5ffbeaf1463379ff1adcfc"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr.html#a4bbe49ea1e5ffbeaf1463379ff1adcfc">dataTypeSize</a> (<a class="el" href="namespacepvr.html#a7924324f96dc973225ad3c532cc72309">DataType</a> type)</td></tr>
<tr class="memdesc:a4bbe49ea1e5ffbeaf1463379ff1adcfc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the Size of a DataType. <a href="#a4bbe49ea1e5ffbeaf1463379ff1adcfc">More...</a><br /></td></tr>
<tr class="separator:a4bbe49ea1e5ffbeaf1463379ff1adcfc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af4676d56d2f795d4c4f5b7a094af90c9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacepvr.html#aa6ac287ad32e4b14937cee7ac81fb85e">BufferUsageFlags</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr.html#af4676d56d2f795d4c4f5b7a094af90c9">descriptorTypeToBufferUsage</a> (<a class="el" href="namespacepvr.html#a3283c5c9822ac5135fefd45a7cdd5932">DescriptorType</a> descType)</td></tr>
<tr class="memdesc:af4676d56d2f795d4c4f5b7a094af90c9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Infer the BufferUsageFlags that are suitable for the typical use of an object <a href="#af4676d56d2f795d4c4f5b7a094af90c9">More...</a><br /></td></tr>
<tr class="separator:af4676d56d2f795d4c4f5b7a094af90c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a43dd44f92c0013d2ed1dd13363070770"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr.html#a43dd44f92c0013d2ed1dd13363070770">getAlignment</a> (<a class="el" href="namespacepvr.html#aa4440f5fd1256889bd3b3822002208b6">GpuDatatypes</a> type)</td></tr>
<tr class="memdesc:a43dd44f92c0013d2ed1dd13363070770"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get required alignment of this type as demanded by std140 rules <a href="#a43dd44f92c0013d2ed1dd13363070770">More...</a><br /></td></tr>
<tr class="separator:a43dd44f92c0013d2ed1dd13363070770"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe1ac49f71337e1cfd4e6436b3bb9ca6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacepvr_1_1_gpu_datatypes_helper.html#abead2e53bdab9ebb17f7c858a2844e14">GpuDatatypesHelper::BaseType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr.html#abe1ac49f71337e1cfd4e6436b3bb9ca6">getBaseType</a> (<a class="el" href="namespacepvr.html#aa4440f5fd1256889bd3b3822002208b6">GpuDatatypes</a> type)</td></tr>
<tr class="memdesc:abe1ac49f71337e1cfd4e6436b3bb9ca6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the underlying element of a type (integer or float) <a href="#abe1ac49f71337e1cfd4e6436b3bb9ca6">More...</a><br /></td></tr>
<tr class="separator:abe1ac49f71337e1cfd4e6436b3bb9ca6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6bc2716579dfbeade26021e2628dd7a7"><td class="memItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr.html#a6bc2716579dfbeade26021e2628dd7a7">getCpuPackedSize</a> (<a class="el" href="namespacepvr.html#aa4440f5fd1256889bd3b3822002208b6">GpuDatatypes</a> type, uint32_t arrayElements=1)</td></tr>
<tr class="memdesc:a6bc2716579dfbeade26021e2628dd7a7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the size of n array members of a type, packed in CPU <a href="#a6bc2716579dfbeade26021e2628dd7a7">More...</a><br /></td></tr>
<tr class="separator:a6bc2716579dfbeade26021e2628dd7a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a65076be9fba2c986f80ffe1eb64aa29a"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr.html#a65076be9fba2c986f80ffe1eb64aa29a">getNumMatrixColumns</a> (<a class="el" href="namespacepvr.html#aa4440f5fd1256889bd3b3822002208b6">GpuDatatypes</a> type)</td></tr>
<tr class="memdesc:a65076be9fba2c986f80ffe1eb64aa29a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the number of colums (1..4) of the type <a href="#a65076be9fba2c986f80ffe1eb64aa29a">More...</a><br /></td></tr>
<tr class="separator:a65076be9fba2c986f80ffe1eb64aa29a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8277a30a2c9fa98ba8c66c2c8516f923"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr.html#a8277a30a2c9fa98ba8c66c2c8516f923">getNumVecElements</a> (<a class="el" href="namespacepvr.html#aa4440f5fd1256889bd3b3822002208b6">GpuDatatypes</a> type)</td></tr>
<tr class="memdesc:a8277a30a2c9fa98ba8c66c2c8516f923"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the number of vector elements (i.e. Rows) of a type. (e.g. vec2=&gt;2) <a href="#a8277a30a2c9fa98ba8c66c2c8516f923">More...</a><br /></td></tr>
<tr class="separator:a8277a30a2c9fa98ba8c66c2c8516f923"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b67db200cee4a4078676dc5f3622ec0"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr.html#a5b67db200cee4a4078676dc5f3622ec0">getOffsetAfter</a> (<a class="el" href="namespacepvr.html#aa4440f5fd1256889bd3b3822002208b6">GpuDatatypes</a> type, uint64_t previousTotalSize)</td></tr>
<tr class="memdesc:a5b67db200cee4a4078676dc5f3622ec0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aligns an address/offset with the alignment of a type &ndash; equivalently, assuming you want to place a type after a known offset (i.e. calculating the offset of an item inside a struct having already calculated its previous element) (i.e. aligning a vec4 after an item that ends at 30 bytes returns 32 bytes...) <a href="#a5b67db200cee4a4078676dc5f3622ec0">More...</a><br /></td></tr>
<tr class="separator:a5b67db200cee4a4078676dc5f3622ec0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a10f119283374e989cd179f6831fe1e36"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr.html#a10f119283374e989cd179f6831fe1e36">getResultCodeString</a> (<a class="el" href="namespacepvr.html#a1c5fa1488e4ba61dd568718646a8c73d">Result</a> result)</td></tr>
<tr class="memdesc:a10f119283374e989cd179f6831fe1e36"><td class="mdescLeft">&#160;</td><td class="mdescRight">Use this function to convert a Result into a std::string that is suitable for outputting. <a href="#a10f119283374e989cd179f6831fe1e36">More...</a><br /></td></tr>
<tr class="separator:a10f119283374e989cd179f6831fe1e36"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7caef391618cc1a3ebab73d8ffe90a47"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr.html#a7caef391618cc1a3ebab73d8ffe90a47">getSelfAlignedArraySize</a> (<a class="el" href="namespacepvr.html#aa4440f5fd1256889bd3b3822002208b6">GpuDatatypes</a> type)</td></tr>
<tr class="memdesc:a7caef391618cc1a3ebab73d8ffe90a47"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns "how many bytes will an object of this type take", if it is an array member (arrays have potentially stricter requirements). <a href="#a7caef391618cc1a3ebab73d8ffe90a47">More...</a><br /></td></tr>
<tr class="separator:a7caef391618cc1a3ebab73d8ffe90a47"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a239df321236ac77da04fe9d58f5efe55"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr.html#a239df321236ac77da04fe9d58f5efe55">getSelfAlignedSize</a> (<a class="el" href="namespacepvr.html#aa4440f5fd1256889bd3b3822002208b6">GpuDatatypes</a> type)</td></tr>
<tr class="memdesc:a239df321236ac77da04fe9d58f5efe55"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns "how many bytes will an object of this type take", if not an array. <a href="#a239df321236ac77da04fe9d58f5efe55">More...</a><br /></td></tr>
<tr class="separator:a239df321236ac77da04fe9d58f5efe55"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e17c970a2a4965269fcb9e3e55049dd"><td class="memItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr.html#a7e17c970a2a4965269fcb9e3e55049dd">getSize</a> (<a class="el" href="namespacepvr.html#aa4440f5fd1256889bd3b3822002208b6">GpuDatatypes</a> type, uint32_t arrayElements=1)</td></tr>
<tr class="memdesc:a7e17c970a2a4965269fcb9e3e55049dd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns how many bytes an array of n objects of this type take, but arrayElements = 1 is NOT considered an array (is aligned as a single object, NOT an array of 1) <a href="#a7e17c970a2a4965269fcb9e3e55049dd">More...</a><br /></td></tr>
<tr class="separator:a7e17c970a2a4965269fcb9e3e55049dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5486ebd5e2197fa607b0fc29c7850742"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacepvr.html#a8be7d779089afe1df56a1bf542134d0d">TextureFileFormat</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr.html#a5486ebd5e2197fa607b0fc29c7850742">getTextureFormatFromFilename</a> (const char *assetname)</td></tr>
<tr class="memdesc:a5486ebd5e2197fa607b0fc29c7850742"><td class="mdescLeft">&#160;</td><td class="mdescRight">Infer the texture format from a filename. <a href="#a5486ebd5e2197fa607b0fc29c7850742">More...</a><br /></td></tr>
<tr class="separator:a5486ebd5e2197fa607b0fc29c7850742"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6bc881503cace7cf8d883d54905aa462"><td class="memItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr.html#a6bc881503cace7cf8d883d54905aa462">getTotalSizeAfter</a> (<a class="el" href="namespacepvr.html#aa4440f5fd1256889bd3b3822002208b6">GpuDatatypes</a> type, uint32_t arrayElements, uint64_t previousTotalSize)</td></tr>
<tr class="memdesc:a6bc881503cace7cf8d883d54905aa462"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the new size of a hypothetical struct whose old size was previousTotalSize, and to which "arrayElement" new items of type "type" are added <a href="#a6bc881503cace7cf8d883d54905aa462">More...</a><br /></td></tr>
<tr class="separator:a6bc881503cace7cf8d883d54905aa462"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c310f549c8db9647eeeef82a0a56af0"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr.html#a4c310f549c8db9647eeeef82a0a56af0">getVectorSelfAlignedSize</a> (<a class="el" href="namespacepvr.html#aa4440f5fd1256889bd3b3822002208b6">GpuDatatypes</a> type)</td></tr>
<tr class="memdesc:a4c310f549c8db9647eeeef82a0a56af0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the size of a type, including padding, assuming the next item is of the same type <a href="#a4c310f549c8db9647eeeef82a0a56af0">More...</a><br /></td></tr>
<tr class="separator:a4c310f549c8db9647eeeef82a0a56af0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3cbe7fd082e1089dc162d9afdacdd6f1"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr.html#a3cbe7fd082e1089dc162d9afdacdd6f1">getVectorUnalignedSize</a> (<a class="el" href="namespacepvr.html#aa4440f5fd1256889bd3b3822002208b6">GpuDatatypes</a> type)</td></tr>
<tr class="memdesc:a3cbe7fd082e1089dc162d9afdacdd6f1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the cpu-packed size of each vector element a type (disregarding matrix columns if they exist) <a href="#a3cbe7fd082e1089dc162d9afdacdd6f1">More...</a><br /></td></tr>
<tr class="separator:a3cbe7fd082e1089dc162d9afdacdd6f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a43f0a8e74fd2e53e456ced76b3a9ac"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr.html#a1a43f0a8e74fd2e53e456ced76b3a9ac">growFloat</a> (const uint32_t &amp;value, const uint8_t &amp;mantissaBits, const uint8_t &amp;exponentBits, const uint8_t &amp;exponentBias, const bool hasSign)</td></tr>
<tr class="memdesc:a1a43f0a8e74fd2e53e456ced76b3a9ac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Produces a floating point value based on the uint32_t value, the mantissa bits and exponent bits <a href="#a1a43f0a8e74fd2e53e456ced76b3a9ac">More...</a><br /></td></tr>
<tr class="separator:a1a43f0a8e74fd2e53e456ced76b3a9ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade5ae06be9adae4c32d10aa679b5731e"><td class="memTemplParams" colspan="2">template&lt;typename T1_ &gt; </td></tr>
<tr class="memitem:ade5ae06be9adae4c32d10aa679b5731e"><td class="memTemplItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacepvr.html#ade5ae06be9adae4c32d10aa679b5731e">hash32_32</a> (const T1_ &amp;t)</td></tr>
<tr class="memdesc:ade5ae06be9adae4c32d10aa679b5731e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function object hashing to 32 bit values into a 32 bit unsigned Integer. <a href="#ade5ae06be9adae4c32d10aa679b5731e">More...</a><br /></td></tr>
<tr class="separator:ade5ae06be9adae4c32d10aa679b5731e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a18b97ab7a969dcd477d5e6c236a0bec4"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr.html#a18b97ab7a969dcd477d5e6c236a0bec4">hash32_bytes</a> (const void *bytes, size_t count)</td></tr>
<tr class="memdesc:a18b97ab7a969dcd477d5e6c236a0bec4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function object hashing a number of bytes into a 32 bit unsigned Integer. <a href="#a18b97ab7a969dcd477d5e6c236a0bec4">More...</a><br /></td></tr>
<tr class="separator:a18b97ab7a969dcd477d5e6c236a0bec4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a128900aeb6815de42a6d6d2c59f67a6e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacepvr.html#ab98ea90165357c2f9030218c337f90bf">ImageType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr.html#a128900aeb6815de42a6d6d2c59f67a6e">imageViewTypeToImageBaseType</a> (<a class="el" href="namespacepvr.html#a43f03a43047f737186d5b90b19dcaca2">ImageViewType</a> viewtype)</td></tr>
<tr class="memdesc:a128900aeb6815de42a6d6d2c59f67a6e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Map an ImageViewType (2dCube etc) to its base type (1d/2d/3d) <a href="#a128900aeb6815de42a6d6d2c59f67a6e">More...</a><br /></td></tr>
<tr class="separator:a128900aeb6815de42a6d6d2c59f67a6e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3fd0cfec4d261dd1caa2ce5eefcc2a53"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr.html#a3fd0cfec4d261dd1caa2ce5eefcc2a53">indexTypeSizeInBytes</a> (const <a class="el" href="namespacepvr.html#aab40a4733df51a99c80b389348c493ac">IndexType</a> type)</td></tr>
<tr class="memdesc:a3fd0cfec4d261dd1caa2ce5eefcc2a53"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the Size of an IndexType in bytes. <a href="#a3fd0cfec4d261dd1caa2ce5eefcc2a53">More...</a><br /></td></tr>
<tr class="separator:a3fd0cfec4d261dd1caa2ce5eefcc2a53"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff2eee1ed23143ae72185a5472ea765a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr.html#aff2eee1ed23143ae72185a5472ea765a">isDescriptorTypeDynamic</a> (<a class="el" href="namespacepvr.html#a3283c5c9822ac5135fefd45a7cdd5932">DescriptorType</a> descType)</td></tr>
<tr class="memdesc:aff2eee1ed23143ae72185a5472ea765a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if a descriptor type is dynamic (a dynamic UBO or dynamic SSBO) <a href="#aff2eee1ed23143ae72185a5472ea765a">More...</a><br /></td></tr>
<tr class="separator:aff2eee1ed23143ae72185a5472ea765a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a47994de10c19816f5b4f0351e265ead5"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr.html#a47994de10c19816f5b4f0351e265ead5">isVariableTypeNormalized</a> (<a class="el" href="namespacepvr.html#a6f7777c11dfff8fcf4a03d85e5ab0b98">VariableType</a> item)</td></tr>
<tr class="memdesc:a47994de10c19816f5b4f0351e265ead5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if a variable type is a Normalizedtype <a href="#a47994de10c19816f5b4f0351e265ead5">More...</a><br /></td></tr>
<tr class="separator:a47994de10c19816f5b4f0351e265ead5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad8844086c38cb4b2dddc3317494b16ac"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr.html#ad8844086c38cb4b2dddc3317494b16ac">isVariableTypeSigned</a> (<a class="el" href="namespacepvr.html#a6f7777c11dfff8fcf4a03d85e5ab0b98">VariableType</a> item)</td></tr>
<tr class="memdesc:ad8844086c38cb4b2dddc3317494b16ac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if a variable type is a Signed type <a href="#ad8844086c38cb4b2dddc3317494b16ac">More...</a><br /></td></tr>
<tr class="separator:ad8844086c38cb4b2dddc3317494b16ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac73ce628e547374c22057ff8e3a89bb3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacepvr.html#aa4440f5fd1256889bd3b3822002208b6">GpuDatatypes</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr.html#ac73ce628e547374c22057ff8e3a89bb3">mergeDatatypesBigger</a> (<a class="el" href="namespacepvr.html#aa4440f5fd1256889bd3b3822002208b6">GpuDatatypes</a> type1, <a class="el" href="namespacepvr.html#aa4440f5fd1256889bd3b3822002208b6">GpuDatatypes</a> type2)</td></tr>
<tr class="memdesc:ac73ce628e547374c22057ff8e3a89bb3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a datatype that is larger or equal to both of two types: 1) Has the most permissive base type (float&gt;int) 2) Has the largest of the two vector widths 3) Has the most of the two matrix colums heights <a href="#ac73ce628e547374c22057ff8e3a89bb3">More...</a><br /></td></tr>
<tr class="separator:ac73ce628e547374c22057ff8e3a89bb3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ef5be44f3a11eac1a122cafd4a217db"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacepvr.html#aa4440f5fd1256889bd3b3822002208b6">GpuDatatypes</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr.html#a7ef5be44f3a11eac1a122cafd4a217db">mergeDatatypesSmaller</a> (<a class="el" href="namespacepvr.html#aa4440f5fd1256889bd3b3822002208b6">GpuDatatypes</a> type1, <a class="el" href="namespacepvr.html#aa4440f5fd1256889bd3b3822002208b6">GpuDatatypes</a> type2)</td></tr>
<tr class="memdesc:a7ef5be44f3a11eac1a122cafd4a217db"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a datatype that is smaller or equal to both of two types: 1) Has the most permissive base type (float&gt;int) 2) Has the smaller of the two vector widths 3) Has the least of the two matrix colums heights <a href="#a7ef5be44f3a11eac1a122cafd4a217db">More...</a><br /></td></tr>
<tr class="separator:a7ef5be44f3a11eac1a122cafd4a217db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a33df3732a0a48b5274ac3938a7e570b0"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr.html#a33df3732a0a48b5274ac3938a7e570b0">numDataTypeComponents</a> (<a class="el" href="namespacepvr.html#a7924324f96dc973225ad3c532cc72309">DataType</a> type)</td></tr>
<tr class="memdesc:a33df3732a0a48b5274ac3938a7e570b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the number of components in a datatype. <a href="#a33df3732a0a48b5274ac3938a7e570b0">More...</a><br /></td></tr>
<tr class="separator:a33df3732a0a48b5274ac3938a7e570b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace778b3dc26297c9b8e57205c37e32b3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacepvr.html#aa4440f5fd1256889bd3b3822002208b6">GpuDatatypes</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr.html#ace778b3dc26297c9b8e57205c37e32b3">operator &amp;</a> (<a class="el" href="namespacepvr.html#aa4440f5fd1256889bd3b3822002208b6">GpuDatatypes</a> lhs, <a class="el" href="namespacepvr_1_1_gpu_datatypes_helper.html#a84bf23cf8acb6cfb591074eda461590f">GpuDatatypesHelper::Bits</a> rhs)</td></tr>
<tr class="memdesc:ace778b3dc26297c9b8e57205c37e32b3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bitwise operator AND. Typical semantics. Allows AND between GpuDatatypes and Bits <a href="#ace778b3dc26297c9b8e57205c37e32b3">More...</a><br /></td></tr>
<tr class="separator:ace778b3dc26297c9b8e57205c37e32b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac7ea58158def42897beab0d03b6a715f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacepvr.html#aee12f61a84bee4c4513c6bfad5b042d2">ImageAspectFlags</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr.html#ac7ea58158def42897beab0d03b6a715f">operator &amp;</a> (<a class="el" href="namespacepvr.html#aee12f61a84bee4c4513c6bfad5b042d2">ImageAspectFlags</a> lhs, <a class="el" href="namespacepvr.html#aee12f61a84bee4c4513c6bfad5b042d2">ImageAspectFlags</a> rhs)</td></tr>
<tr class="memdesc:ac7ea58158def42897beab0d03b6a715f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Operator&amp;. <a href="#ac7ea58158def42897beab0d03b6a715f">More...</a><br /></td></tr>
<tr class="separator:ac7ea58158def42897beab0d03b6a715f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5de0698d0beb6ad53d66cee8c3da3d50"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr.html#a5de0698d0beb6ad53d66cee8c3da3d50">operator &amp;=</a> (<a class="el" href="namespacepvr.html#aee12f61a84bee4c4513c6bfad5b042d2">ImageAspectFlags</a> &amp;lhs, <a class="el" href="namespacepvr.html#aee12f61a84bee4c4513c6bfad5b042d2">ImageAspectFlags</a> rhs)</td></tr>
<tr class="memdesc:a5de0698d0beb6ad53d66cee8c3da3d50"><td class="mdescLeft">&#160;</td><td class="mdescRight">Operator&amp;=. <a href="#a5de0698d0beb6ad53d66cee8c3da3d50">More...</a><br /></td></tr>
<tr class="separator:a5de0698d0beb6ad53d66cee8c3da3d50"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae6830359c957ddaf92782874bb70e825"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacepvr.html#aa4440f5fd1256889bd3b3822002208b6">GpuDatatypes</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr.html#ae6830359c957ddaf92782874bb70e825">operator&lt;&lt;</a> (<a class="el" href="namespacepvr.html#aa4440f5fd1256889bd3b3822002208b6">GpuDatatypes</a> lhs, <a class="el" href="namespacepvr_1_1_gpu_datatypes_helper.html#a84bf23cf8acb6cfb591074eda461590f">GpuDatatypesHelper::Bits</a> rhs)</td></tr>
<tr class="memdesc:ae6830359c957ddaf92782874bb70e825"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bitwise operator LEFT SHIFT. Typical semantics. Allows LEFT SHIFT of GpuDatatypes by Bits <a href="#ae6830359c957ddaf92782874bb70e825">More...</a><br /></td></tr>
<tr class="separator:ae6830359c957ddaf92782874bb70e825"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab32d83bd296ef37d4c646b2552e276e7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacepvr.html#aa4440f5fd1256889bd3b3822002208b6">GpuDatatypes</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr.html#ab32d83bd296ef37d4c646b2552e276e7">operator&gt;&gt;</a> (<a class="el" href="namespacepvr.html#aa4440f5fd1256889bd3b3822002208b6">GpuDatatypes</a> lhs, <a class="el" href="namespacepvr_1_1_gpu_datatypes_helper.html#a84bf23cf8acb6cfb591074eda461590f">GpuDatatypesHelper::Bits</a> rhs)</td></tr>
<tr class="memdesc:ab32d83bd296ef37d4c646b2552e276e7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bitwise operator RIGHT SHIFT. Typical semantics. Allows RIGHT SHIFT of GpuDatatypes by Bits <a href="#ab32d83bd296ef37d4c646b2552e276e7">More...</a><br /></td></tr>
<tr class="separator:ab32d83bd296ef37d4c646b2552e276e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af90306acc1aaa07ed01111e86229dd02"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacepvr.html#aee12f61a84bee4c4513c6bfad5b042d2">ImageAspectFlags</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr.html#af90306acc1aaa07ed01111e86229dd02">operator|</a> (<a class="el" href="namespacepvr.html#aee12f61a84bee4c4513c6bfad5b042d2">ImageAspectFlags</a> lhs, <a class="el" href="namespacepvr.html#aee12f61a84bee4c4513c6bfad5b042d2">ImageAspectFlags</a> rhs)</td></tr>
<tr class="memdesc:af90306acc1aaa07ed01111e86229dd02"><td class="mdescLeft">&#160;</td><td class="mdescRight">Operator|. <a href="#af90306acc1aaa07ed01111e86229dd02">More...</a><br /></td></tr>
<tr class="separator:af90306acc1aaa07ed01111e86229dd02"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad9b7e5a5c13f5eb605d551685cff1be7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr.html#ad9b7e5a5c13f5eb605d551685cff1be7">operator|=</a> (<a class="el" href="namespacepvr.html#aee12f61a84bee4c4513c6bfad5b042d2">ImageAspectFlags</a> &amp;lhs, <a class="el" href="namespacepvr.html#aee12f61a84bee4c4513c6bfad5b042d2">ImageAspectFlags</a> rhs)</td></tr>
<tr class="memdesc:ad9b7e5a5c13f5eb605d551685cff1be7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Operator|=. <a href="#ad9b7e5a5c13f5eb605d551685cff1be7">More...</a><br /></td></tr>
<tr class="separator:ad9b7e5a5c13f5eb605d551685cff1be7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abbe45548f9e676d52b1645ea21ba4d11"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacepvr.html#aafc960d10904ec52d4d823ed66717c43">PackedSamplerFilter</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr.html#abbe45548f9e676d52b1645ea21ba4d11">packSamplerFilter</a> (<a class="el" href="namespacepvr.html#a84d320093e1561f82e57776aafd947d7">Filter</a> mini, <a class="el" href="namespacepvr.html#a84d320093e1561f82e57776aafd947d7">Filter</a> magni, <a class="el" href="namespacepvr.html#ac7a59f03f943f1c79a5339331fc15abe">SamplerMipmapMode</a> mip)</td></tr>
<tr class="memdesc:abbe45548f9e676d52b1645ea21ba4d11"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pack a minification filter, a magnification filter and a mipmap filter into an 8 bit value <a href="#abbe45548f9e676d52b1645ea21ba4d11">More...</a><br /></td></tr>
<tr class="separator:abbe45548f9e676d52b1645ea21ba4d11"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a717b05fe80f33f87f83e84aafdcd6029"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr.html#a717b05fe80f33f87f83e84aafdcd6029">PVRTDecompressETC</a> (const void *srcData, uint32_t xDim, uint32_t yDim, void *dstData, uint32_t mode)</td></tr>
<tr class="memdesc:a717b05fe80f33f87f83e84aafdcd6029"><td class="mdescLeft">&#160;</td><td class="mdescRight">Decompresses ETC to RGBA 8888. <a href="#a717b05fe80f33f87f83e84aafdcd6029">More...</a><br /></td></tr>
<tr class="separator:a717b05fe80f33f87f83e84aafdcd6029"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff06586480b28aae72e01be1c735cacf"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr.html#aff06586480b28aae72e01be1c735cacf">PVRTDecompressPVRTC</a> (const void *compressedData, uint32_t do2bitMode, uint32_t xDim, uint32_t yDim, uint8_t *outResultImage)</td></tr>
<tr class="memdesc:aff06586480b28aae72e01be1c735cacf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Decompresses PVRTC to RGBA 8888. <a href="#aff06586480b28aae72e01be1c735cacf">More...</a><br /></td></tr>
<tr class="separator:aff06586480b28aae72e01be1c735cacf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7cc135f8fc78f66cf936fd87efc7fccf"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr.html#a7cc135f8fc78f66cf936fd87efc7fccf">randomrange</a> (float min, float max)</td></tr>
<tr class="memdesc:a7cc135f8fc78f66cf936fd87efc7fccf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a random Number between min and max <a href="#a7cc135f8fc78f66cf936fd87efc7fccf">More...</a><br /></td></tr>
<tr class="separator:a7cc135f8fc78f66cf936fd87efc7fccf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a960c0fbbee6c09de2e753f4d4df0a977"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpvr_1_1_texture.html">Texture</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr.html#a960c0fbbee6c09de2e753f4d4df0a977">textureLoad</a> (const <a class="el" href="classpvr_1_1_stream.html">Stream</a> &amp;textureStream, <a class="el" href="namespacepvr.html#a8be7d779089afe1df56a1bf542134d0d">TextureFileFormat</a> type)</td></tr>
<tr class="memdesc:a960c0fbbee6c09de2e753f4d4df0a977"><td class="mdescLeft">&#160;</td><td class="mdescRight">Load a texture from binary data. Synchronous. <a href="#a960c0fbbee6c09de2e753f4d4df0a977">More...</a><br /></td></tr>
<tr class="separator:a960c0fbbee6c09de2e753f4d4df0a977"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af78cb1ebeebf974be88e5ec542eff07f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpvr_1_1_texture.html">Texture</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr.html#af78cb1ebeebf974be88e5ec542eff07f">textureLoad</a> (const <a class="el" href="classpvr_1_1_stream.html">Stream</a> &amp;textureStream)</td></tr>
<tr class="memdesc:af78cb1ebeebf974be88e5ec542eff07f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Load a texture from binary data. Synchronous. <a href="#af78cb1ebeebf974be88e5ec542eff07f">More...</a><br /></td></tr>
<tr class="separator:af78cb1ebeebf974be88e5ec542eff07f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ba89cd73a4bd44a48929c19be453c42"><td class="memItemLeft" align="right" valign="top"><a id="a4ba89cd73a4bd44a48929c19be453c42"></a>
std::string&#160;</td><td class="memItemRight" valign="bottom"><b>to_string</b> (<a class="el" href="namespacepvr.html#a7cfc7d042b44f46e4d5dfbb32d0f16b1">CompressedPixelFormat</a> format)</td></tr>
<tr class="separator:a4ba89cd73a4bd44a48929c19be453c42"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9eba0f081d510ad2dc9da45015a5502b"><td class="memItemLeft" align="right" valign="top"><a id="a9eba0f081d510ad2dc9da45015a5502b"></a>
std::string&#160;</td><td class="memItemRight" valign="bottom"><b>to_string</b> (<a class="el" href="namespacepvr.html#a1b94afe6b8a7c21e8f8ddee1f7b5cb91">ColorSpace</a> colorspace)</td></tr>
<tr class="separator:a9eba0f081d510ad2dc9da45015a5502b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a191e381dddf4355555dedafe403999c5"><td class="memItemLeft" align="right" valign="top"><a id="a191e381dddf4355555dedafe403999c5"></a>
std::string&#160;</td><td class="memItemRight" valign="bottom"><b>to_string</b> (<a class="el" href="namespacepvr.html#a6f7777c11dfff8fcf4a03d85e5ab0b98">VariableType</a> variableType)</td></tr>
<tr class="separator:a191e381dddf4355555dedafe403999c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af4313bce3d2aa89901241ca461f8af53"><td class="memItemLeft" align="right" valign="top"><a id="af4313bce3d2aa89901241ca461f8af53"></a>
std::string&#160;</td><td class="memItemRight" valign="bottom"><b>to_string</b> (const <a class="el" href="classpvr_1_1_pixel_format.html">PixelFormat</a> &amp;fmt)</td></tr>
<tr class="separator:af4313bce3d2aa89901241ca461f8af53"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a627b4365be1581c05ca10e33752b4f"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr.html#a5a627b4365be1581c05ca10e33752b4f">to_string</a> (<a class="el" href="namespacepvr.html#af5c2a4d46bb7aa6a877a0ed8c5ba3ac8">ShaderType</a> shaderType)</td></tr>
<tr class="memdesc:a5a627b4365be1581c05ca10e33752b4f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts a <a class="el" href="namespacepvr.html#af5c2a4d46bb7aa6a877a0ed8c5ba3ac8" title="Enumeration of all supported shader types.">pvr::ShaderType</a> to string <a href="#a5a627b4365be1581c05ca10e33752b4f">More...</a><br /></td></tr>
<tr class="separator:a5a627b4365be1581c05ca10e33752b4f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a547738cbdb228eba2d1d4b58d2c142c9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacepvr.html#a7924324f96dc973225ad3c532cc72309">DataType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr.html#a547738cbdb228eba2d1d4b58d2c142c9">toDataType</a> (<a class="el" href="namespacepvr.html#aa4440f5fd1256889bd3b3822002208b6">GpuDatatypes</a> type)</td></tr>
<tr class="memdesc:a547738cbdb228eba2d1d4b58d2c142c9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the Cpu Datatype <em>type</em>  refers to (i.e. which CPU datatype must you load in the data you upload to the GPU to correctly upload the same value in the shader). <a href="#a547738cbdb228eba2d1d4b58d2c142c9">More...</a><br /></td></tr>
<tr class="separator:a547738cbdb228eba2d1d4b58d2c142c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea8728868bc6c9fa07c48f1f6d0e2f37"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr.html#aea8728868bc6c9fa07c48f1f6d0e2f37">toString</a> (<a class="el" href="namespacepvr.html#aa4440f5fd1256889bd3b3822002208b6">GpuDatatypes</a> type)</td></tr>
<tr class="memdesc:aea8728868bc6c9fa07c48f1f6d0e2f37"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a string with the glsl variable name of a type <a href="#aea8728868bc6c9fa07c48f1f6d0e2f37">More...</a><br /></td></tr>
<tr class="separator:aea8728868bc6c9fa07c48f1f6d0e2f37"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93997dab7a634e84d3ac4cdd4bb7fa33"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr.html#a93997dab7a634e84d3ac4cdd4bb7fa33">unpackSamplerFilter</a> (<a class="el" href="namespacepvr.html#aafc960d10904ec52d4d823ed66717c43">PackedSamplerFilter</a> packed, <a class="el" href="namespacepvr.html#a84d320093e1561f82e57776aafd947d7">Filter</a> &amp;mini, <a class="el" href="namespacepvr.html#a84d320093e1561f82e57776aafd947d7">Filter</a> &amp;magni, <a class="el" href="namespacepvr.html#ac7a59f03f943f1c79a5339331fc15abe">SamplerMipmapMode</a> &amp;mip)</td></tr>
<tr class="memdesc:a93997dab7a634e84d3ac4cdd4bb7fa33"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unpack a 8 bit PackedSamplerFilter value into a minification, magnification and mip filter mode <a href="#a93997dab7a634e84d3ac4cdd4bb7fa33">More...</a><br /></td></tr>
<tr class="separator:a93997dab7a634e84d3ac4cdd4bb7fa33"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a771a597a351ca78fd99c9059be6b6b0b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr.html#a771a597a351ca78fd99c9059be6b6b0b">writeTGA</a> (<a class="el" href="classpvr_1_1_stream.html">pvr::Stream</a> &amp;file, uint32_t w, uint32_t h, const unsigned char *imageData, const uint32_t stride, uint32_t pixelReplicate=1)</td></tr>
<tr class="memdesc:a771a597a351ca78fd99c9059be6b6b0b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write out TGA data from an image. <a href="#a771a597a351ca78fd99c9059be6b6b0b">More...</a><br /></td></tr>
<tr class="separator:a771a597a351ca78fd99c9059be6b6b0b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3dc97c9ed2a10c891c9143a98f69c28b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr.html#a3dc97c9ed2a10c891c9143a98f69c28b">writeTGA</a> (<a class="el" href="classpvr_1_1_stream.html">pvr::Stream</a> &amp;&amp;file, uint32_t w, uint32_t h, const unsigned char *imageData, const unsigned char stride, uint32_t pixelReplicate=1)</td></tr>
<tr class="memdesc:a3dc97c9ed2a10c891c9143a98f69c28b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write out TGA data from an image. <a href="#a3dc97c9ed2a10c891c9143a98f69c28b">More...</a><br /></td></tr>
<tr class="separator:a3dc97c9ed2a10c891c9143a98f69c28b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1fbb5d45243437fd1da5e5c676ef886d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr.html#a1fbb5d45243437fd1da5e5c676ef886d">writeTGA</a> (const char *filename, uint32_t w, uint32_t h, const unsigned char *imageData, const unsigned char stride, uint32_t pixelReplicate=1)</td></tr>
<tr class="memdesc:a1fbb5d45243437fd1da5e5c676ef886d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write out TGA data from an image. <a href="#a1fbb5d45243437fd1da5e5c676ef886d">More...</a><br /></td></tr>
<tr class="separator:a1fbb5d45243437fd1da5e5c676ef886d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac8bab478a8afc2458b8cf7a7f0a86526"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr.html#ac8bab478a8afc2458b8cf7a7f0a86526">writeTGAFromPlanar</a> (<a class="el" href="classpvr_1_1_stream.html">pvr::Stream</a> &amp;stream, uint32_t w, uint32_t h, const unsigned char *imageDataR, const unsigned char *imageDataG, const unsigned char *imageDataB, const uint32_t stride, uint32_t pixelReplicate=1)</td></tr>
<tr class="memdesc:ac8bab478a8afc2458b8cf7a7f0a86526"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write out TGA data from an image. <a href="#ac8bab478a8afc2458b8cf7a7f0a86526">More...</a><br /></td></tr>
<tr class="separator:ac8bab478a8afc2458b8cf7a7f0a86526"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a8967706f6b66d13061f0e33e135dbd"><td class="memItemLeft" align="right" valign="top"><a id="a4a8967706f6b66d13061f0e33e135dbd"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>writeTGAFromPlanar</b> (<a class="el" href="classpvr_1_1_stream.html">pvr::Stream</a> &amp;&amp;stream, uint32_t w, uint32_t h, const unsigned char *imageDataR, const unsigned char *imageDataG, const unsigned char *imageDataB, const uint32_t stride, uint32_t pixelReplicate=1)</td></tr>
<tr class="separator:a4a8967706f6b66d13061f0e33e135dbd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab7a41d371ada7bd24719226dbdb25602"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr.html#ab7a41d371ada7bd24719226dbdb25602">writeTGAFromPlanar</a> (const char *filename, uint32_t w, uint32_t h, const unsigned char *imageDataR, const unsigned char *imageDataG, const unsigned char *imageDataB, const uint32_t stride, uint32_t pixelReplicate=1)</td></tr>
<tr class="memdesc:ab7a41d371ada7bd24719226dbdb25602"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write out TGA data from an image. <a href="#ab7a41d371ada7bd24719226dbdb25602">More...</a><br /></td></tr>
<tr class="separator:ab7a41d371ada7bd24719226dbdb25602"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Main PowerVR Framework Namespace</p>
</div><h2 class="groupheader">Typedef Documentation</h2>
<a id="adb9f486ad8ed5a55c94d47224583f59a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adb9f486ad8ed5a55c94d47224583f59a">&#9670;&nbsp;</a></span>CommandLine</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classpvr_1_1platform_1_1_command_line_parser_1_1_parsed_command_line.html">platform::CommandLineParser::ParsedCommandLine</a> <a class="el" href="namespacepvr.html#adb9f486ad8ed5a55c94d47224583f59a">pvr::CommandLine</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>&lt; summary&gt; Typedef of the CommandLine into the pvr namespace</p>

</div>
</div>
<a id="a065d965f04c53d6e94e0e56a34289090"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a065d965f04c53d6e94e0e56a34289090">&#9670;&nbsp;</a></span>Extent2D</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="structpvr_1_1_generic_extent2_d.html">GenericExtent2D</a>&lt;uint32_t&gt; <a class="el" href="namespacepvr.html#a065d965f04c53d6e94e0e56a34289090">pvr::Extent2D</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A 2D, integer Extent typically used for Images</p>

</div>
</div>
<a id="abc7deef434e373b18abd3b929c31e9aa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abc7deef434e373b18abd3b929c31e9aa">&#9670;&nbsp;</a></span>Extent3D</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="structpvr_1_1_generic_extent3_d.html">GenericExtent3D</a>&lt;uint32_t, uint32_t&gt; <a class="el" href="namespacepvr.html#abc7deef434e373b18abd3b929c31e9aa">pvr::Extent3D</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A 3D, integer Extent typically used for 3D Images</p>

</div>
</div>
<a id="a3c68f9a2f58eb4afee65dee64a84ec60"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3c68f9a2f58eb4afee65dee64a84ec60">&#9670;&nbsp;</a></span>Offset2D</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="structpvr_1_1_generic_offset2_d.html">GenericOffset2D</a>&lt;int32_t&gt; <a class="el" href="namespacepvr.html#a3c68f9a2f58eb4afee65dee64a84ec60">pvr::Offset2D</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A 2D, integer Offset typically used for Images</p>

</div>
</div>
<a id="a9c82b565cdd75fbf396893a67ce24f4d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9c82b565cdd75fbf396893a67ce24f4d">&#9670;&nbsp;</a></span>Offset3D</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="structpvr_1_1_generic_offset3_d.html">GenericOffset3D</a>&lt;int32_t, int32_t&gt; <a class="el" href="namespacepvr.html#a9c82b565cdd75fbf396893a67ce24f4d">pvr::Offset3D</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A 3D, integer Offset typically used for 3D Images</p>

</div>
</div>
<a id="aedeecfbbd5f300d790a94b7f47277582"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aedeecfbbd5f300d790a94b7f47277582">&#9670;&nbsp;</a></span>OSApplication</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void* <a class="el" href="namespacepvr.html#aedeecfbbd5f300d790a94b7f47277582">pvr::OSApplication</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Native application type.</p>

</div>
</div>
<a id="af20cc023ab76f41ca5119b328748a293"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af20cc023ab76f41ca5119b328748a293">&#9670;&nbsp;</a></span>OSConnection</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void* <a class="el" href="namespacepvr.html#af20cc023ab76f41ca5119b328748a293">pvr::OSConnection</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Native connection type. Used as a connection between a client side window system library (Xlib, XCB) and its corresponding server side window system library.</p>

</div>
</div>
<a id="ac6f2b93a38b04d593e40fb33ac919de9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac6f2b93a38b04d593e40fb33ac919de9">&#9670;&nbsp;</a></span>OSDATA</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void* <a class="el" href="namespacepvr.html#ac6f2b93a38b04d593e40fb33ac919de9">pvr::OSDATA</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Native application data type.</p>

</div>
</div>
<a id="aeb92095259cdb0e0a5013d243b8cdcad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeb92095259cdb0e0a5013d243b8cdcad">&#9670;&nbsp;</a></span>OSDisplay</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void* <a class="el" href="namespacepvr.html#aeb92095259cdb0e0a5013d243b8cdcad">pvr::OSDisplay</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Native display type.</p>

</div>
</div>
<a id="a4a3c2268d5e5b11e1bc9cf97d7c337e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4a3c2268d5e5b11e1bc9cf97d7c337e8">&#9670;&nbsp;</a></span>OSWindow</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void* <a class="el" href="namespacepvr.html#a4a3c2268d5e5b11e1bc9cf97d7c337e8">pvr::OSWindow</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Native window type.</p>

</div>
</div>
<a id="afc19de2d5b6952c2d5471033aa4f2563"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afc19de2d5b6952c2d5471033aa4f2563">&#9670;&nbsp;</a></span>Rectangle3Df</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="structpvr_1_1_rectangle3_d.html">Rectangle3D</a>&lt;float&gt; <a class="el" href="namespacepvr.html#afc19de2d5b6952c2d5471033aa4f2563">pvr::Rectangle3Df</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A float 3D rectangle</p>

</div>
</div>
<a id="a799b34b4c6caf281d54db6a9756dc39d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a799b34b4c6caf281d54db6a9756dc39d">&#9670;&nbsp;</a></span>Rectangle3Di</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="structpvr_1_1_rectangle3_d.html">Rectangle3D</a>&lt;int32_t&gt; <a class="el" href="namespacepvr.html#a799b34b4c6caf281d54db6a9756dc39d">pvr::Rectangle3Di</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>An integer 3D rectangle</p>

</div>
</div>
<a id="aba0728db2b6aa21ad82b263a102fec44"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aba0728db2b6aa21ad82b263a102fec44">&#9670;&nbsp;</a></span>Rectanglef</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="structpvr_1_1_rectangle.html">Rectangle</a>&lt;float&gt; <a class="el" href="namespacepvr.html#aba0728db2b6aa21ad82b263a102fec44">pvr::Rectanglef</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A floating point 2D rectangle</p>

</div>
</div>
<a id="a779802ae077693e9183007cfbedf47d4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a779802ae077693e9183007cfbedf47d4">&#9670;&nbsp;</a></span>Rectanglei</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="structpvr_1_1_rectangle.html">Rectangle</a>&lt;int32_t&gt; <a class="el" href="namespacepvr.html#a779802ae077693e9183007cfbedf47d4">pvr::Rectanglei</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>An integer 2D rectangle</p>

</div>
</div>
<a id="a870616cf592ddd3bd544f6c519ccac5f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a870616cf592ddd3bd544f6c519ccac5f">&#9670;&nbsp;</a></span>UInt8Buffer</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef ::std::vector&lt;unsigned char&gt; <a class="el" href="namespacepvr.html#a870616cf592ddd3bd544f6c519ccac5f">pvr::UInt8Buffer</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Represents a buffer of Unsigned Bytes. Used to store raw data.</p>

</div>
</div>
<a id="a2f1b3a4b714cc874e267883662058a19"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2f1b3a4b714cc874e267883662058a19">&#9670;&nbsp;</a></span>utf16</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef unsigned short <a class="el" href="namespacepvr.html#a2f1b3a4b714cc874e267883662058a19">pvr::utf16</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A UTF-16 (unsigned) character. 16-bit unsigned Integer.</p>

</div>
</div>
<a id="ae281450f4795e25d5ce35d674b17249b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae281450f4795e25d5ce35d674b17249b">&#9670;&nbsp;</a></span>utf32</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef unsigned int <a class="el" href="namespacepvr.html#ae281450f4795e25d5ce35d674b17249b">pvr::utf32</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A UTF-32 (unsigned) character. 32-bit unsigned Integer.</p>

</div>
</div>
<a id="a9ee58768dfb56ed9216c98178d572e17"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9ee58768dfb56ed9216c98178d572e17">&#9670;&nbsp;</a></span>utf8</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef unsigned char <a class="el" href="namespacepvr.html#a9ee58768dfb56ed9216c98178d572e17">pvr::utf8</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A UTF-8 (unsigned) character. 8-bit unsigned Integer.</p>

</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="af88eb990f89e601fa71b688d99673620"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af88eb990f89e601fa71b688d99673620">&#9670;&nbsp;</a></span>anonymous enum</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">anonymous enum</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Flag interpreted as All mipmap levels.</p>

</div>
</div>
<a id="a74c5d1afa51512f076dd8e5844b171c8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a74c5d1afa51512f076dd8e5844b171c8">&#9670;&nbsp;</a></span>Api</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacepvr.html#a74c5d1afa51512f076dd8e5844b171c8">pvr::Api</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Enumeration of all API types supported by this implementation</p>

</div>
</div>
<a id="afc560f133c0bcec5adff02183b4a9386"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afc560f133c0bcec5adff02183b4a9386">&#9670;&nbsp;</a></span>BlendFactor</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacepvr.html#afc560f133c0bcec5adff02183b4a9386">pvr::BlendFactor</a> : uint8_t</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Specfies how the rgba blending facors are computed for source and destination fragments.</p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="afc560f133c0bcec5adff02183b4a9386ad7ed4ee1df437474d005188535f74875"></a>Zero&#160;</td><td class="fielddoc"><p>Zero. </p>
</td></tr>
<tr><td class="fieldname"><a id="afc560f133c0bcec5adff02183b4a9386a06c2cea18679d64399783748fa367bdd"></a>One&#160;</td><td class="fielddoc"><p>One. </p>
</td></tr>
<tr><td class="fieldname"><a id="afc560f133c0bcec5adff02183b4a9386a2ad714e29d37896d79187312086bc6fe"></a>SrcColor&#160;</td><td class="fielddoc"><p>The color of the incoming fragment. </p>
</td></tr>
<tr><td class="fieldname"><a id="afc560f133c0bcec5adff02183b4a9386a09d3240b4e2481b1a729da24e9bfddf7"></a>OneMinusSrcColor&#160;</td><td class="fielddoc"><p>1 - (SourceColor) </p>
</td></tr>
<tr><td class="fieldname"><a id="afc560f133c0bcec5adff02183b4a9386afaedf511c99a5461048fd6a3b73da26c"></a>DstColor&#160;</td><td class="fielddoc"><p>The color of the pixel already in the framebuffer. </p>
</td></tr>
<tr><td class="fieldname"><a id="afc560f133c0bcec5adff02183b4a9386a09f1a054ebd4d3850fd248bd2fa7b325"></a>OneMinusDstColor&#160;</td><td class="fielddoc"><p>1 - (Destination Color) </p>
</td></tr>
<tr><td class="fieldname"><a id="afc560f133c0bcec5adff02183b4a9386ad5c7b7f0102df3f7305c43f73fc3a498"></a>SrcAlpha&#160;</td><td class="fielddoc"><p>The alpha of the incoming fragment. </p>
</td></tr>
<tr><td class="fieldname"><a id="afc560f133c0bcec5adff02183b4a9386ac00a6016489cff63d50d489ce52254cc"></a>OneMinusSrcAlpha&#160;</td><td class="fielddoc"><p>1- (Source Alpha) </p>
</td></tr>
<tr><td class="fieldname"><a id="afc560f133c0bcec5adff02183b4a9386af72dbe2436b38a39e5927ed644e6818b"></a>DstAlpha&#160;</td><td class="fielddoc"><p>The alpha of the pixel already in the framebuffer (requires an alpha channel) </p>
</td></tr>
<tr><td class="fieldname"><a id="afc560f133c0bcec5adff02183b4a9386a4132e4b87a8d461be2c6ee8fc620cfb2"></a>OneMinusDstAlpha&#160;</td><td class="fielddoc"><p>1- (Destination Alpha) </p>
</td></tr>
<tr><td class="fieldname"><a id="afc560f133c0bcec5adff02183b4a9386aeb8eb99f8eea9079c0e76d5ce7301dd3"></a>ConstantColor&#160;</td><td class="fielddoc"><p>A constant color provided by the api. </p>
</td></tr>
<tr><td class="fieldname"><a id="afc560f133c0bcec5adff02183b4a9386a13ab8deb1c606ab17745354b4e92f43a"></a>OneMinusConstantColor&#160;</td><td class="fielddoc"><p>1- (Constant Color) </p>
</td></tr>
<tr><td class="fieldname"><a id="afc560f133c0bcec5adff02183b4a9386a6f0229db491c3b01860363456dc57288"></a>ConstantAlpha&#160;</td><td class="fielddoc"><p>A constant alpha value provided by the api. </p>
</td></tr>
<tr><td class="fieldname"><a id="afc560f133c0bcec5adff02183b4a9386a9a1874144125c69e93ec99f17e985e41"></a>OneMinusConstantAlpha&#160;</td><td class="fielddoc"><p>1- (ConstantAlpha) </p>
</td></tr>
<tr><td class="fieldname"><a id="afc560f133c0bcec5adff02183b4a9386a87c65d6ae5c79e8a05482365776bd959"></a>Src1Color&#160;</td><td class="fielddoc"><p>Source Color 1. </p>
</td></tr>
<tr><td class="fieldname"><a id="afc560f133c0bcec5adff02183b4a9386ac1686472488cf32c06cc257f4e8ac04f"></a>OneMinusSrc1Color&#160;</td><td class="fielddoc"><p>1 - (Source Color 1) </p>
</td></tr>
<tr><td class="fieldname"><a id="afc560f133c0bcec5adff02183b4a9386aa69d96453c025ed62b3276e892e59e39"></a>Src1Alpha&#160;</td><td class="fielddoc"><p>Source Alpha 1. </p>
</td></tr>
<tr><td class="fieldname"><a id="afc560f133c0bcec5adff02183b4a9386a88dfdcc65a80f412d0330f00579ab7f2"></a>OneMinusSrc1Alpha&#160;</td><td class="fielddoc"><p>1 - (Source Alpha 1) </p>
</td></tr>
</table>

</div>
</div>
<a id="a78be6b6f15903b90d6a9d575ebf6d353"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a78be6b6f15903b90d6a9d575ebf6d353">&#9670;&nbsp;</a></span>BlendOp</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacepvr.html#a78be6b6f15903b90d6a9d575ebf6d353">pvr::BlendOp</a> : uint32_t</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Enumeration of the blend operations (determine how a new pixel (source color) is combined with a pixel already in the framebuffer (destination color).</p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a78be6b6f15903b90d6a9d575ebf6d353aec211f7c20af43e742bf2570c3cb84f9"></a>Add&#160;</td><td class="fielddoc"><p>Addition. </p>
</td></tr>
<tr><td class="fieldname"><a id="a78be6b6f15903b90d6a9d575ebf6d353a1d9baf077ee87921f57a8fe42d510b65"></a>Subtract&#160;</td><td class="fielddoc"><p>Subtraction second from first. </p>
</td></tr>
<tr><td class="fieldname"><a id="a78be6b6f15903b90d6a9d575ebf6d353abd5458190996e76988cb2f27a820c685"></a>ReverseSubtract&#160;</td><td class="fielddoc"><p>Subtract first from second. </p>
</td></tr>
<tr><td class="fieldname"><a id="a78be6b6f15903b90d6a9d575ebf6d353a78d811e98514cd165dda532286610fd2"></a>Min&#160;</td><td class="fielddoc"><p>Minimum of the two. </p>
</td></tr>
<tr><td class="fieldname"><a id="a78be6b6f15903b90d6a9d575ebf6d353a6a061313d22e51e0f25b7cd4dc065233"></a>Max&#160;</td><td class="fielddoc"><p>Maximum of the two. </p>
</td></tr>
</table>

</div>
</div>
<a id="aa6ac287ad32e4b14937cee7ac81fb85e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa6ac287ad32e4b14937cee7ac81fb85e">&#9670;&nbsp;</a></span>BufferUsageFlags</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacepvr.html#aa6ac287ad32e4b14937cee7ac81fb85e">pvr::BufferUsageFlags</a> : uint32_t</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Enumeration of all supported buffer use types.</p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="aa6ac287ad32e4b14937cee7ac81fb85eac1b703f2c13fac2fff3e72d3e307d4c0"></a>TransferSrc&#160;</td><td class="fielddoc"><p>Transfer Source. </p>
</td></tr>
<tr><td class="fieldname"><a id="aa6ac287ad32e4b14937cee7ac81fb85ea155895f4426d6fc97295ca2de160fd20"></a>TransferDest&#160;</td><td class="fielddoc"><p>Transfer Destination. </p>
</td></tr>
<tr><td class="fieldname"><a id="aa6ac287ad32e4b14937cee7ac81fb85ea4b43da703340c8273da56cf3445c6754"></a>UniformTexelBuffer&#160;</td><td class="fielddoc"><p>Uniform Texel Buffer. </p>
</td></tr>
<tr><td class="fieldname"><a id="aa6ac287ad32e4b14937cee7ac81fb85eaae1f93780c3073aeadaf118d550f0c65"></a>StorageTexelBuffer&#160;</td><td class="fielddoc"><p>Storage Texel Buffer. </p>
</td></tr>
<tr><td class="fieldname"><a id="aa6ac287ad32e4b14937cee7ac81fb85ea88f133adfed6c854e5731cdffbf208cf"></a>UniformBuffer&#160;</td><td class="fielddoc"><p>UBO. </p>
</td></tr>
<tr><td class="fieldname"><a id="aa6ac287ad32e4b14937cee7ac81fb85ea439f57c2c466c89db942b3de48298b2b"></a>StorageBuffer&#160;</td><td class="fielddoc"><p>SSBO. </p>
</td></tr>
<tr><td class="fieldname"><a id="aa6ac287ad32e4b14937cee7ac81fb85ea7c3895116254ff0417e58b6286de27c0"></a>IndexBuffer&#160;</td><td class="fielddoc"><p>IBO. </p>
</td></tr>
<tr><td class="fieldname"><a id="aa6ac287ad32e4b14937cee7ac81fb85ea10461f19cdb5aadba2fc9986be6400bd"></a>VertexBuffer&#160;</td><td class="fielddoc"><p>VBO. </p>
</td></tr>
<tr><td class="fieldname"><a id="aa6ac287ad32e4b14937cee7ac81fb85ea7e5abafe55b7f7e20d417fe9c967d69e"></a>IndirectBuffer&#160;</td><td class="fielddoc"><p>A buffer that contains Draw Indirect commands. </p>
</td></tr>
</table>

</div>
</div>
<a id="af9ca1aead0a3149b0af3842d03bc6cd4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af9ca1aead0a3149b0af3842d03bc6cd4">&#9670;&nbsp;</a></span>Capability</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacepvr.html#af9ca1aead0a3149b0af3842d03bc6cd4">pvr::Capability</a> : uint8_t</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Capability supported values.</p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="af9ca1aead0a3149b0af3842d03bc6cd4ab4080bdf74febf04d578ff105cce9d3f"></a>Unsupported&#160;</td><td class="fielddoc"><p>The capability is unsupported. </p>
</td></tr>
<tr><td class="fieldname"><a id="af9ca1aead0a3149b0af3842d03bc6cd4a11efd9ae6f76e706e3f1b34d97584ebc"></a>Immutable&#160;</td><td class="fielddoc"><p>The capability exists but cannot be changed. </p>
</td></tr>
<tr><td class="fieldname"><a id="af9ca1aead0a3149b0af3842d03bc6cd4ad924522d30d6615e9f71e91504364a9d"></a>Mutable&#160;</td><td class="fielddoc"><p>The capability is supported and can be changed. </p>
</td></tr>
</table>

</div>
</div>
<a id="a675b14a2f2079f7f72e7f2ad35d13de7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a675b14a2f2079f7f72e7f2ad35d13de7">&#9670;&nbsp;</a></span>ColorChannelFlags</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacepvr.html#a675b14a2f2079f7f72e7f2ad35d13de7">pvr::ColorChannelFlags</a> : uint32_t</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>ChannelWriteMask enable/ disable writting to channel bits.</p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a675b14a2f2079f7f72e7f2ad35d13de7ae1e1d3d40573127e9ee0480caf1283d6"></a>R&#160;</td><td class="fielddoc"><p>write to red channel </p>
</td></tr>
<tr><td class="fieldname"><a id="a675b14a2f2079f7f72e7f2ad35d13de7adfcf28d0734569a6a693bc8194de62bf"></a>G&#160;</td><td class="fielddoc"><p>write to green channel </p>
</td></tr>
<tr><td class="fieldname"><a id="a675b14a2f2079f7f72e7f2ad35d13de7a9d5ed678fe57bcca610140957afab571"></a>B&#160;</td><td class="fielddoc"><p>write to blue channel </p>
</td></tr>
<tr><td class="fieldname"><a id="a675b14a2f2079f7f72e7f2ad35d13de7a7fc56270e7a70fa81a5935b72eacbe29"></a>A&#160;</td><td class="fielddoc"><p>write to alpha channel </p>
</td></tr>
<tr><td class="fieldname"><a id="a675b14a2f2079f7f72e7f2ad35d13de7a6adf97f83acf6453d4a6a4b1070f3754"></a>None&#160;</td><td class="fielddoc"><p>don't write to any channel </p>
</td></tr>
</table>

</div>
</div>
<a id="a1b94afe6b8a7c21e8f8ddee1f7b5cb91"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1b94afe6b8a7c21e8f8ddee1f7b5cb91">&#9670;&nbsp;</a></span>ColorSpace</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacepvr.html#a1b94afe6b8a7c21e8f8ddee1f7b5cb91">pvr::ColorSpace</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Enumeration of Colorspaces (Linear, SRGB).</p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a1b94afe6b8a7c21e8f8ddee1f7b5cb91a4c8bf835da6d934b50f620cdd0cc3913"></a>lRGB&#160;</td><td class="fielddoc"><p>Linear RGB colorspace. </p>
</td></tr>
<tr><td class="fieldname"><a id="a1b94afe6b8a7c21e8f8ddee1f7b5cb91a9ed33d9be17d174aeb4393a989586ed9"></a>sRGB&#160;</td><td class="fielddoc"><p>sRGB colorspace </p>
</td></tr>
</table>

</div>
</div>
<a id="a24a87498f839b45b6e1bc3c8b2ca20fc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a24a87498f839b45b6e1bc3c8b2ca20fc">&#9670;&nbsp;</a></span>CompareOp</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacepvr.html#a24a87498f839b45b6e1bc3c8b2ca20fc">pvr::CompareOp</a> : uint32_t</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>An enumeration that defines Comparison operations (equal, less or equal etc.). Especially used in API classes for functions like depth testing.</p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a24a87498f839b45b6e1bc3c8b2ca20fca6e7b34fa59e1bd229b207892956dc41c"></a>Never&#160;</td><td class="fielddoc"><p>Always false. </p>
</td></tr>
<tr><td class="fieldname"><a id="a24a87498f839b45b6e1bc3c8b2ca20fca1cfdf0e8d0c87a228c1f40d9bee7888b"></a>Less&#160;</td><td class="fielddoc"><p>True if lhs&lt;rhs. </p>
</td></tr>
<tr><td class="fieldname"><a id="a24a87498f839b45b6e1bc3c8b2ca20fcaf5f286e73bda105e538310b3190f75c5"></a>Equal&#160;</td><td class="fielddoc"><p>True if lhs==rhs. </p>
</td></tr>
<tr><td class="fieldname"><a id="a24a87498f839b45b6e1bc3c8b2ca20fcad3e6fdac55bb7b0edd7834c968ba1f38"></a>LessEqual&#160;</td><td class="fielddoc"><p>True if lhs&lt;=rhs. </p>
</td></tr>
<tr><td class="fieldname"><a id="a24a87498f839b45b6e1bc3c8b2ca20fca8768a6821cd735aea4f5b0df88c1fc6a"></a>Greater&#160;</td><td class="fielddoc"><p>True if lhs&gt;rhs. </p>
</td></tr>
<tr><td class="fieldname"><a id="a24a87498f839b45b6e1bc3c8b2ca20fca19bb0af2c3c530538cb41aff7f235b96"></a>NotEqual&#160;</td><td class="fielddoc"><p>True if lhs!=rhs. </p>
</td></tr>
<tr><td class="fieldname"><a id="a24a87498f839b45b6e1bc3c8b2ca20fca758b05d899def79c9eb864ad4f96be1f"></a>GreaterEqual&#160;</td><td class="fielddoc"><p>True if lhs&gt;=rhs. </p>
</td></tr>
<tr><td class="fieldname"><a id="a24a87498f839b45b6e1bc3c8b2ca20fca68eec46437c384d8dad18d5464ebc35c"></a>Always&#160;</td><td class="fielddoc"><p>Always true. </p>
</td></tr>
</table>

</div>
</div>
<a id="a7cfc7d042b44f46e4d5dfbb32d0f16b1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7cfc7d042b44f46e4d5dfbb32d0f16b1">&#9670;&nbsp;</a></span>CompressedPixelFormat</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacepvr.html#a7cfc7d042b44f46e4d5dfbb32d0f16b1">pvr::CompressedPixelFormat</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Enumeration of all known Compressed pixel formats.</p>

</div>
</div>
<a id="a87b409df225dee78541eb74988f4e20c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a87b409df225dee78541eb74988f4e20c">&#9670;&nbsp;</a></span>CubeFace</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacepvr.html#a87b409df225dee78541eb74988f4e20c">pvr::CubeFace</a> : uint32_t</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Enumeration of the six faces of a Cube</p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a87b409df225dee78541eb74988f4e20ca9f082d04c481aab268b9f614d2ffd129"></a>PositiveX&#160;</td><td class="fielddoc"><p>+x </p>
</td></tr>
<tr><td class="fieldname"><a id="a87b409df225dee78541eb74988f4e20ca963a8a64a09d54efc81b136ca6be21b2"></a>NegativeX&#160;</td><td class="fielddoc"><p>-x </p>
</td></tr>
<tr><td class="fieldname"><a id="a87b409df225dee78541eb74988f4e20cac53c385ced96bd629c0f45a902aceba3"></a>PositiveY&#160;</td><td class="fielddoc"><p>+y </p>
</td></tr>
<tr><td class="fieldname"><a id="a87b409df225dee78541eb74988f4e20cae4d5f02ceecd15caf66e9f0b2393c86b"></a>NegativeY&#160;</td><td class="fielddoc"><p>-y </p>
</td></tr>
<tr><td class="fieldname"><a id="a87b409df225dee78541eb74988f4e20ca1921c16ffdafaf04e378ca1b6774c0ce"></a>PositiveZ&#160;</td><td class="fielddoc"><p>+z </p>
</td></tr>
<tr><td class="fieldname"><a id="a87b409df225dee78541eb74988f4e20cada76df034cd139bd515761c8bb8e3090"></a>NegativeZ&#160;</td><td class="fielddoc"><p>-z </p>
</td></tr>
</table>

</div>
</div>
<a id="a7924324f96dc973225ad3c532cc72309"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7924324f96dc973225ad3c532cc72309">&#9670;&nbsp;</a></span>DataType</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacepvr.html#a7924324f96dc973225ad3c532cc72309">pvr::DataType</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>An enumeration that defines data types used throughout the Framework. Commonly used in places where raw data are used to define the types actually contained.</p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a7924324f96dc973225ad3c532cc72309a6adf97f83acf6453d4a6a4b1070f3754"></a>None&#160;</td><td class="fielddoc"><p>None, or unknown. </p>
</td></tr>
<tr><td class="fieldname"><a id="a7924324f96dc973225ad3c532cc72309a166495adc0d0f53bee6baecc577f5204"></a>Float32&#160;</td><td class="fielddoc"><p>32 bit floating point number </p>
</td></tr>
<tr><td class="fieldname"><a id="a7924324f96dc973225ad3c532cc72309ac06129f6e6e15c09328365e553f1dc31"></a>Int32&#160;</td><td class="fielddoc"><p>32 bit Integer </p>
</td></tr>
<tr><td class="fieldname"><a id="a7924324f96dc973225ad3c532cc72309a8bd950a9d7779b83f5c30046c9aaf1cf"></a>UInt16&#160;</td><td class="fielddoc"><p>16 bit Unsigned Integer (aka Unsigned Short) </p>
</td></tr>
<tr><td class="fieldname"><a id="a7924324f96dc973225ad3c532cc72309aea3495a278957dc58165e48a8945469f"></a>RGBA&#160;</td><td class="fielddoc"><p>32 bit (4 channels x 8bpc), in Red,Green,Blue,Alpha order </p>
</td></tr>
<tr><td class="fieldname"><a id="a7924324f96dc973225ad3c532cc72309ae192297ecf3602fabbec5f0a38ede758"></a>ARGB&#160;</td><td class="fielddoc"><p>32 bit (4 channels x 8bpc), in Alpha,Red,Green,Blue order </p>
</td></tr>
<tr><td class="fieldname"><a id="a7924324f96dc973225ad3c532cc72309a67cb8b94254acbfda2cdf7a916421298"></a>D3DCOLOR&#160;</td><td class="fielddoc"><p>Direct3D color format. </p>
</td></tr>
<tr><td class="fieldname"><a id="a7924324f96dc973225ad3c532cc72309aa061360f8e01902202f21849c40a1105"></a>UBYTE4&#160;</td><td class="fielddoc"><p>Direct3D UBYTE4 format. </p>
</td></tr>
<tr><td class="fieldname"><a id="a7924324f96dc973225ad3c532cc72309aff4e3dcc2ead0fa54993ccbf4eda1ae8"></a>DEC3N&#160;</td><td class="fielddoc"><p>Direct3D DEC3N format. </p>
</td></tr>
<tr><td class="fieldname"><a id="a7924324f96dc973225ad3c532cc72309a32e326bf2ef732551075db8987a1408c"></a>Fixed16_16&#160;</td><td class="fielddoc"><p>32 bit Fixed Point (16 + 16) </p>
</td></tr>
<tr><td class="fieldname"><a id="a7924324f96dc973225ad3c532cc72309ab31df9c476d20e85ff898121efe11b5a"></a>UInt8&#160;</td><td class="fielddoc"><p>Unsigned 8 bit integer (aka unsigned char/byte) </p>
</td></tr>
<tr><td class="fieldname"><a id="a7924324f96dc973225ad3c532cc72309a39bc2ae44b184207f560ff8619823208"></a>Int16&#160;</td><td class="fielddoc"><p>Signed 16 bit integer (aka short) </p>
</td></tr>
<tr><td class="fieldname"><a id="a7924324f96dc973225ad3c532cc72309a0f224678669aa9f1b9e9dee8c544912a"></a>Int16Norm&#160;</td><td class="fielddoc"><p>Signed 16 bit integer scaled to a value from -1..1 (aka normalized short) </p>
</td></tr>
<tr><td class="fieldname"><a id="a7924324f96dc973225ad3c532cc72309a7d839b2c12bfd40ac121b4cc9e81c539"></a>Int8&#160;</td><td class="fielddoc"><p>Signed 8 bit integer (aka char / byte) </p>
</td></tr>
<tr><td class="fieldname"><a id="a7924324f96dc973225ad3c532cc72309a74f0eeb95bdbf29bcc7eb2b6431c13f2"></a>Int8Norm&#160;</td><td class="fielddoc"><p>Signed 8 bit integer, interpreted by scaling to -1..1 (aka normalized byte) </p>
</td></tr>
<tr><td class="fieldname"><a id="a7924324f96dc973225ad3c532cc72309a784d359bf21cc07236f54855d9aab91a"></a>UInt8Norm&#160;</td><td class="fielddoc"><p>Unsigned 8 bit integer, interpreted by scaling to 0..1 (aka unsigned normalized byte) </p>
</td></tr>
<tr><td class="fieldname"><a id="a7924324f96dc973225ad3c532cc72309ab296ec5fbf49139c807bd99ba7f7dee8"></a>UInt16Norm&#160;</td><td class="fielddoc"><p>Unsigned 16 bit integer, interpreted by scaling to 0..1 (aka unsigned normalized short) </p>
</td></tr>
<tr><td class="fieldname"><a id="a7924324f96dc973225ad3c532cc72309ae7956ed7be1c5025a27ed3cb42a396bd"></a>UInt32&#160;</td><td class="fielddoc"><p>Unsigned 32 bit integer (aka Unsigned Int) </p>
</td></tr>
<tr><td class="fieldname"><a id="a7924324f96dc973225ad3c532cc72309adce7d10c2f9ffc8ed9e7b6a3f7d8ba6c"></a>ABGR&#160;</td><td class="fielddoc"><p>32 bit (4 channels x 8 bpc), in Alpha,Blue,Green,Red order </p>
</td></tr>
<tr><td class="fieldname"><a id="a7924324f96dc973225ad3c532cc72309a26e6ed77470c6f2f830ecf874e6c0d55"></a>Float16&#160;</td><td class="fielddoc"><p>16 bit IEEE 754-2008 floating point number (aka Half) </p>
</td></tr>
</table>

</div>
</div>
<a id="a3283c5c9822ac5135fefd45a7cdd5932"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3283c5c9822ac5135fefd45a7cdd5932">&#9670;&nbsp;</a></span>DescriptorType</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacepvr.html#a3283c5c9822ac5135fefd45a7cdd5932">pvr::DescriptorType</a> : uint32_t</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Enumeration of all the different descriptor types.</p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a3283c5c9822ac5135fefd45a7cdd5932a5bca2f066df1fe641b2b779db2a63c0a"></a>Sampler&#160;</td><td class="fielddoc"><p>A Sampler object. </p>
</td></tr>
<tr><td class="fieldname"><a id="a3283c5c9822ac5135fefd45a7cdd5932a8cfe077ac9aea5235b0c3fda85914029"></a>CombinedImageSampler&#160;</td><td class="fielddoc"><p>A descriptor that contains both and image and its sampler. </p>
</td></tr>
<tr><td class="fieldname"><a id="a3283c5c9822ac5135fefd45a7cdd5932a4520c597ce328c250d1ca5192047d71d"></a>SampledImage&#160;</td><td class="fielddoc"><p>Aka "Texture". </p>
</td></tr>
<tr><td class="fieldname"><a id="a3283c5c9822ac5135fefd45a7cdd5932aa078fa7ad769f9e7b53b8c42e3b7bbab"></a>StorageImage&#160;</td><td class="fielddoc"><p>Aka "Image for Image Load Store". </p>
</td></tr>
<tr><td class="fieldname"><a id="a3283c5c9822ac5135fefd45a7cdd5932a4b43da703340c8273da56cf3445c6754"></a>UniformTexelBuffer&#160;</td><td class="fielddoc"><p>Aka <a class="el" href="classpvr_1_1_texture.html" title="A 2D Texture asset, together with Information, Metadata and actual Pixel data. Only represents the ac...">Texture</a> Buffer. </p>
</td></tr>
<tr><td class="fieldname"><a id="a3283c5c9822ac5135fefd45a7cdd5932aae1f93780c3073aeadaf118d550f0c65"></a>StorageTexelBuffer&#160;</td><td class="fielddoc"><p>Also known as TextureBuffer. </p>
</td></tr>
<tr><td class="fieldname"><a id="a3283c5c9822ac5135fefd45a7cdd5932a88f133adfed6c854e5731cdffbf208cf"></a>UniformBuffer&#160;</td><td class="fielddoc"><p>Aka UBO. </p>
</td></tr>
<tr><td class="fieldname"><a id="a3283c5c9822ac5135fefd45a7cdd5932a439f57c2c466c89db942b3de48298b2b"></a>StorageBuffer&#160;</td><td class="fielddoc"><p>Aka SSBO. </p>
</td></tr>
<tr><td class="fieldname"><a id="a3283c5c9822ac5135fefd45a7cdd5932a517b91f0588b3bf6c80ff3b19b2a7f57"></a>UniformBufferDynamic&#160;</td><td class="fielddoc"><p>A UBO that can be bound one piece at a time. </p>
</td></tr>
<tr><td class="fieldname"><a id="a3283c5c9822ac5135fefd45a7cdd5932ada8c94227ee0e3b5cd40da12d594ad55"></a>StorageBufferDynamic&#160;</td><td class="fielddoc"><p>A SSBO that can be bound one piece at a time. </p>
</td></tr>
<tr><td class="fieldname"><a id="a3283c5c9822ac5135fefd45a7cdd5932a261d965f5dd43c6873489b68730dbe57"></a>InputAttachment&#160;</td><td class="fielddoc"><p>An intermediate attachment that can be used between subpasses. </p>
</td></tr>
</table>

</div>
</div>
<a id="a1ca56afd652113209f2535e7688a4189"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1ca56afd652113209f2535e7688a4189">&#9670;&nbsp;</a></span>Face</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacepvr.html#a1ca56afd652113209f2535e7688a4189">pvr::Face</a> : uint32_t</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Enumeration of Face facing (front, back...).</p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a1ca56afd652113209f2535e7688a4189a6adf97f83acf6453d4a6a4b1070f3754"></a>None&#160;</td><td class="fielddoc"><p>No faces. </p>
</td></tr>
<tr><td class="fieldname"><a id="a1ca56afd652113209f2535e7688a4189a5835bab1ade0060909e31a06af2e2cde"></a>Front&#160;</td><td class="fielddoc"><p>The front face. </p>
</td></tr>
<tr><td class="fieldname"><a id="a1ca56afd652113209f2535e7688a4189a0557fa923dcee4d0f86b1409f5c2167f"></a>Back&#160;</td><td class="fielddoc"><p>The back face. </p>
</td></tr>
<tr><td class="fieldname"><a id="a1ca56afd652113209f2535e7688a4189a8be41da9b58e32ece35a2b5751f6aeb9"></a>FrontAndBack&#160;</td><td class="fielddoc"><p>Both faces. </p>
</td></tr>
</table>

</div>
</div>
<a id="a84d320093e1561f82e57776aafd947d7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a84d320093e1561f82e57776aafd947d7">&#9670;&nbsp;</a></span>Filter</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacepvr.html#a84d320093e1561f82e57776aafd947d7">pvr::Filter</a> : uint8_t</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Enumeration describing a filtering type of a specific dimension. In order to describe the filtering mode properly, you would have to define a Minification filter, a Magnification filter and a Mipmapping minification filter. Possible values: Nearest, Linear, Cubic, None.</p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a84d320093e1561f82e57776aafd947d7a60494f02d440f316319dd0fad40ad007"></a>Nearest&#160;</td><td class="fielddoc"><p>Nearest neighbour. </p>
</td></tr>
<tr><td class="fieldname"><a id="a84d320093e1561f82e57776aafd947d7a6adf97f83acf6453d4a6a4b1070f3754"></a>None&#160;</td><td class="fielddoc"><p>No filtering. </p>
</td></tr>
<tr><td class="fieldname"><a id="a84d320093e1561f82e57776aafd947d7aec6b5414eb175379ff9efc9b3eef5814"></a>Cubic&#160;</td><td class="fielddoc"><p>Bicubic filtering (IMG extension) </p>
</td></tr>
</table>

</div>
</div>
<a id="aa4440f5fd1256889bd3b3822002208b6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa4440f5fd1256889bd3b3822002208b6">&#9670;&nbsp;</a></span>GpuDatatypes</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacepvr.html#aa4440f5fd1256889bd3b3822002208b6">pvr::GpuDatatypes</a> : uint32_t</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A (normally hardware-supported) GPU datatype (e.g. vec4 etc.)</p>

</div>
</div>
<a id="aee12f61a84bee4c4513c6bfad5b042d2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aee12f61a84bee4c4513c6bfad5b042d2">&#9670;&nbsp;</a></span>ImageAspectFlags</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacepvr.html#aee12f61a84bee4c4513c6bfad5b042d2">pvr::ImageAspectFlags</a> : uint32_t</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Enumeration of the "aspect" (or "semantics") of an image: Color, Depth, Stencil.</p>

</div>
</div>
<a id="ab98ea90165357c2f9030218c337f90bf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab98ea90165357c2f9030218c337f90bf">&#9670;&nbsp;</a></span>ImageType</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacepvr.html#ab98ea90165357c2f9030218c337f90bf">pvr::ImageType</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The dimension of an image.</p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="ab98ea90165357c2f9030218c337f90bfa4be6a4b9c4d4594764eb625d5c146fff"></a>Image1D&#160;</td><td class="fielddoc"><p>One-dimensional image. </p>
</td></tr>
<tr><td class="fieldname"><a id="ab98ea90165357c2f9030218c337f90bfab696e5f895616f606a8be85892c374a9"></a>Image2D&#160;</td><td class="fielddoc"><p>Two-dimensional image. </p>
</td></tr>
<tr><td class="fieldname"><a id="ab98ea90165357c2f9030218c337f90bfa2d4c32ae3db71aee7bf3a801d15f5075"></a>Image3D&#160;</td><td class="fielddoc"><p>Three-dimensional image. </p>
</td></tr>
<tr><td class="fieldname"><a id="ab98ea90165357c2f9030218c337f90bfa9aeb35984c497717cce0044620fc964a"></a>Unallocated&#160;</td><td class="fielddoc"><p>An image that has not been allocated yet. </p>
</td></tr>
<tr><td class="fieldname"><a id="ab98ea90165357c2f9030218c337f90bfa88183b946cc5f0e8c96b2e66e1c74a7e"></a>Unknown&#160;</td><td class="fielddoc"><p>An image of unknown dimensions. </p>
</td></tr>
</table>

</div>
</div>
<a id="a43f03a43047f737186d5b90b19dcaca2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a43f03a43047f737186d5b90b19dcaca2">&#9670;&nbsp;</a></span>ImageViewType</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacepvr.html#a43f03a43047f737186d5b90b19dcaca2">pvr::ImageViewType</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Enumeration of <a class="el" href="classpvr_1_1_texture.html" title="A 2D Texture asset, together with Information, Metadata and actual Pixel data. Only represents the ac...">Texture</a> dimensionalities.</p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a43f03a43047f737186d5b90b19dcaca2a882bc3b744cc0702640a7bacf0bbcfec"></a>ImageView1D&#160;</td><td class="fielddoc"><p>1 dimensional Image View </p>
</td></tr>
<tr><td class="fieldname"><a id="a43f03a43047f737186d5b90b19dcaca2ad6677d8d1d32ba21cdf283ac165924ad"></a>ImageView2D&#160;</td><td class="fielddoc"><p>2 dimensional Image View </p>
</td></tr>
<tr><td class="fieldname"><a id="a43f03a43047f737186d5b90b19dcaca2a6698a767e1fc8afa8db1cd800d78d675"></a>ImageView3D&#160;</td><td class="fielddoc"><p>3 dimensional Image View </p>
</td></tr>
<tr><td class="fieldname"><a id="a43f03a43047f737186d5b90b19dcaca2a0e44904a008408462e8f2567465f2157"></a>ImageView2DCube&#160;</td><td class="fielddoc"><p>cube texture </p>
</td></tr>
<tr><td class="fieldname"><a id="a43f03a43047f737186d5b90b19dcaca2aba6b5050476daa2d65fe7081478ed7a0"></a>ImageView1DArray&#160;</td><td class="fielddoc"><p>1 dimensional Image View </p>
</td></tr>
<tr><td class="fieldname"><a id="a43f03a43047f737186d5b90b19dcaca2abe5a0e508c8c71c3ab11da749a6678a7"></a>ImageView2DArray&#160;</td><td class="fielddoc"><p>2 dimensional Image View </p>
</td></tr>
<tr><td class="fieldname"><a id="a43f03a43047f737186d5b90b19dcaca2a9ffe857cfe5d3eff82077db510ca5675"></a>ImageView2DCubeArray&#160;</td><td class="fielddoc"><p>2 dimensional Image View </p>
</td></tr>
<tr><td class="fieldname"><a id="a43f03a43047f737186d5b90b19dcaca2aa9d24d469028b69a34b22604c244dfc3"></a>ImageViewUnknown&#160;</td><td class="fielddoc"><p>3 dimensional Image View </p>
</td></tr>
</table>

</div>
</div>
<a id="aab40a4733df51a99c80b389348c493ac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aab40a4733df51a99c80b389348c493ac">&#9670;&nbsp;</a></span>IndexType</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacepvr.html#aab40a4733df51a99c80b389348c493ac">pvr::IndexType</a> : uint32_t</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>An enumeration that defines a type that can use as an index, typically 16 or 32 bit int. Especially used in Model classes.</p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="aab40a4733df51a99c80b389348c493acac995e06991264df36fe28315304bcd6e"></a>IndexType16Bit&#160;</td><td class="fielddoc"><p>16 bit index </p>
</td></tr>
<tr><td class="fieldname"><a id="aab40a4733df51a99c80b389348c493aca456ada99990fe2c6043f27810c550148"></a>IndexType32Bit&#160;</td><td class="fielddoc"><p>32 bit index </p>
</td></tr>
</table>

</div>
</div>
<a id="aafc960d10904ec52d4d823ed66717c43"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aafc960d10904ec52d4d823ed66717c43">&#9670;&nbsp;</a></span>PackedSamplerFilter</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacepvr.html#aafc960d10904ec52d4d823ed66717c43">pvr::PackedSamplerFilter</a> : int8_t</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This enum is made to pack all sampler filtering info in 8 bits for specific uses. Use "packSamplerFilter" and "unpackSamplerFilter". NOTE: The defined values are only the most common cases - other 8 bit values are also valid (for example, different minification and magnification filters)</p>

</div>
</div>
<a id="acebf4429ca4e976bca1ecaf28401bd59"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acebf4429ca4e976bca1ecaf28401bd59">&#9670;&nbsp;</a></span>PolygonWindingOrder</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacepvr.html#acebf4429ca4e976bca1ecaf28401bd59">pvr::PolygonWindingOrder</a> : uint8_t</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Enumeration of the different front face to winding order correlations.</p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="acebf4429ca4e976bca1ecaf28401bd59a6baa14a02b39a3336b6bf0087473eff3"></a>FrontFaceCCW&#160;</td><td class="fielddoc"><p>Front face is the Counter Clockwise face. </p>
</td></tr>
<tr><td class="fieldname"><a id="acebf4429ca4e976bca1ecaf28401bd59a8331b56f0f66fa794a20609344081509"></a>FrontFaceCW&#160;</td><td class="fielddoc"><p>Front face is the Clockwise face. </p>
</td></tr>
</table>

</div>
</div>
<a id="a95105fe432efbe2b976187f0270b6012"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a95105fe432efbe2b976187f0270b6012">&#9670;&nbsp;</a></span>PrimitiveTopology</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacepvr.html#a95105fe432efbe2b976187f0270b6012">pvr::PrimitiveTopology</a> : uint32_t</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Enumeration containing all possible Primitive topologies (Point, line trianglelist etc.).</p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a95105fe432efbe2b976187f0270b6012a1a18ff71b3df3e362a2489eef4b30003"></a>PointList&#160;</td><td class="fielddoc"><p>Renders poins. </p>
</td></tr>
<tr><td class="fieldname"><a id="a95105fe432efbe2b976187f0270b6012a596e1b7afe8925f3f578c716d5af8fef"></a>LineList&#160;</td><td class="fielddoc"><p>Each two items render a separate line segment. </p>
</td></tr>
<tr><td class="fieldname"><a id="a95105fe432efbe2b976187f0270b6012ae7f9e73b8edd21f420a63b3ace5768a2"></a>LineStrip&#160;</td><td class="fielddoc"><p>Renders one continuous polyline (n vertices represent n-1 lines) </p>
</td></tr>
<tr><td class="fieldname"><a id="a95105fe432efbe2b976187f0270b6012af5beeab7a1f452e5b0e9b03b44f0de92"></a>TriangleList&#160;</td><td class="fielddoc"><p>Each 3 vertices render one triangle. </p>
</td></tr>
<tr><td class="fieldname"><a id="a95105fe432efbe2b976187f0270b6012a1da0b9ead8b051940a89214bae22831c"></a>TriangleStrip&#160;</td><td class="fielddoc"><p>Renders one continuous triangle strip, (n vertices represent n-2 triangles in a strip configuration) </p>
</td></tr>
<tr><td class="fieldname"><a id="a95105fe432efbe2b976187f0270b6012a18d58fde618e4a30e2dfdc122e693047"></a>TriangleFan&#160;</td><td class="fielddoc"><p>Renders one continuous triangle fan (n vertices represent n-2 triangles in a fan configuration) </p>
</td></tr>
<tr><td class="fieldname"><a id="a95105fe432efbe2b976187f0270b6012af951dbe32c0c5d525b8e0ec3884de6c7"></a>LineListWithAdjacency&#160;</td><td class="fielddoc"><p>Represents a list of lines, but contains adjacency info (2 additional vertices per 2 vertices: 4 vertices per line segment) </p>
</td></tr>
<tr><td class="fieldname"><a id="a95105fe432efbe2b976187f0270b6012ae6a2093eb583f16122d50acb096af542"></a>LineStripWithAdjacency&#160;</td><td class="fielddoc"><p>Represents a continuous strip of lines, but contains adjacency info (2 additional vertices: the vertex before the first and the vertex after the last line segment) </p>
</td></tr>
<tr><td class="fieldname"><a id="a95105fe432efbe2b976187f0270b6012a150324739f6017972f918eff656ba998"></a>TriangleListWithAdjacency&#160;</td><td class="fielddoc"><p>Represents a triangle list with adjacency info (6 vertices per primitive). </p>
</td></tr>
<tr><td class="fieldname"><a id="a95105fe432efbe2b976187f0270b6012aa8df42f3be2313042a310fb7319b4c36"></a>TriangleStripWithAdjacency&#160;</td><td class="fielddoc"><p>Represents a triangle strip with adjacency info (1 additional adjacency vertex per triangle, plus the adjacent vertices of the first and last triangle sides of the list). </p>
</td></tr>
<tr><td class="fieldname"><a id="a95105fe432efbe2b976187f0270b6012af1b220525e3cc747140a46b7e2d7532e"></a>PatchList&#160;</td><td class="fielddoc"><p>A list of Patches, intended for tessellation. </p>
</td></tr>
</table>

</div>
</div>
<a id="a1c5fa1488e4ba61dd568718646a8c73d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1c5fa1488e4ba61dd568718646a8c73d">&#9670;&nbsp;</a></span>Result</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacepvr.html#a1c5fa1488e4ba61dd568718646a8c73d">pvr::Result</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Pre-defined Result codes (success and generic errors).</p>

</div>
</div>
<a id="aedec1ca92cba055434a2a27da89f5643"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aedec1ca92cba055434a2a27da89f5643">&#9670;&nbsp;</a></span>SamplerAddressMode</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacepvr.html#aedec1ca92cba055434a2a27da89f5643">pvr::SamplerAddressMode</a> : uint8_t</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Enumeration for defining texture wrapping mode: Repeat, Mirror, Clamp, Border.</p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="aedec1ca92cba055434a2a27da89f5643a7020426cfb0a204051be4b3053d2acc8"></a>Repeat&#160;</td><td class="fielddoc"><p>repeat </p>
</td></tr>
<tr><td class="fieldname"><a id="aedec1ca92cba055434a2a27da89f5643a39a681a9d5ccc902bebd16a343dd7b74"></a>MirrorRepeat&#160;</td><td class="fielddoc"><p>mirror repeat </p>
</td></tr>
<tr><td class="fieldname"><a id="aedec1ca92cba055434a2a27da89f5643a74556551231333c36debc3d373261134"></a>ClampToEdge&#160;</td><td class="fielddoc"><p>clamp </p>
</td></tr>
<tr><td class="fieldname"><a id="aedec1ca92cba055434a2a27da89f5643afb07f88f6f11cc5ab9c951290716f147"></a>ClampToBorder&#160;</td><td class="fielddoc"><p>border </p>
</td></tr>
<tr><td class="fieldname"><a id="aedec1ca92cba055434a2a27da89f5643a01f488e80fc32761aecfbeb3d1c8f26b"></a>MirrorClampToEdge&#160;</td><td class="fielddoc"><p>mirror clamp </p>
</td></tr>
</table>

</div>
</div>
<a id="ac7a59f03f943f1c79a5339331fc15abe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac7a59f03f943f1c79a5339331fc15abe">&#9670;&nbsp;</a></span>SamplerMipmapMode</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacepvr.html#ac7a59f03f943f1c79a5339331fc15abe">pvr::SamplerMipmapMode</a> : uint8_t</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Enumeration of mipmap modes supported for a sampler</p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="ac7a59f03f943f1c79a5339331fc15abea60494f02d440f316319dd0fad40ad007"></a>Nearest&#160;</td><td class="fielddoc"><p>Nearest neighbour. </p>
</td></tr>
<tr><td class="fieldname"><a id="ac7a59f03f943f1c79a5339331fc15abea32a843da6ea40ab3b17a3421ccdf671b"></a>Linear&#160;</td><td class="fielddoc"><p>Linear. </p>
</td></tr>
</table>

</div>
</div>
<a id="af5c2a4d46bb7aa6a877a0ed8c5ba3ac8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af5c2a4d46bb7aa6a877a0ed8c5ba3ac8">&#9670;&nbsp;</a></span>ShaderType</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacepvr.html#af5c2a4d46bb7aa6a877a0ed8c5ba3ac8">pvr::ShaderType</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Enumeration of all supported shader types.</p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="af5c2a4d46bb7aa6a877a0ed8c5ba3ac8a05c0d061c57b467a86d66f7529f19bb5"></a>UnknownShader&#160;</td><td class="fielddoc"><p>unknown shader type </p>
</td></tr>
<tr><td class="fieldname"><a id="af5c2a4d46bb7aa6a877a0ed8c5ba3ac8aeb3ca4dac3e206977e0b7d998eefcc33"></a>VertexShader&#160;</td><td class="fielddoc"><p>vertex shader </p>
</td></tr>
<tr><td class="fieldname"><a id="af5c2a4d46bb7aa6a877a0ed8c5ba3ac8a90a9bb4e665932b1781da33fc2f32922"></a>FragmentShader&#160;</td><td class="fielddoc"><p>fragment shader </p>
</td></tr>
<tr><td class="fieldname"><a id="af5c2a4d46bb7aa6a877a0ed8c5ba3ac8a2216355d14abbc1a80dadd4f881c0f39"></a>ComputeShader&#160;</td><td class="fielddoc"><p>compute shader </p>
</td></tr>
</table>

</div>
</div>
<a id="adaffc1ac547687d86eef4bb51d0533aa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adaffc1ac547687d86eef4bb51d0533aa">&#9670;&nbsp;</a></span>StencilOp</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacepvr.html#adaffc1ac547687d86eef4bb51d0533aa">pvr::StencilOp</a> : uint8_t</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Enumeration of the different stencil operations.</p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="adaffc1ac547687d86eef4bb51d0533aaa02bce93bff905887ad2233110bf9c49e"></a>Keep&#160;</td><td class="fielddoc"><p>Keep existing value. </p>
</td></tr>
<tr><td class="fieldname"><a id="adaffc1ac547687d86eef4bb51d0533aaad7ed4ee1df437474d005188535f74875"></a>Zero&#160;</td><td class="fielddoc"><p>Set to zero. </p>
</td></tr>
<tr><td class="fieldname"><a id="adaffc1ac547687d86eef4bb51d0533aaa0ebe6df8a3ac338e0512acc741823fdb"></a>Replace&#160;</td><td class="fielddoc"><p>Replace value with Ref. </p>
</td></tr>
<tr><td class="fieldname"><a id="adaffc1ac547687d86eef4bb51d0533aaa39f5ed1c9a1e48cc90401d52864202ab"></a>IncrementClamp&#160;</td><td class="fielddoc"><p>Increment until max value. </p>
</td></tr>
<tr><td class="fieldname"><a id="adaffc1ac547687d86eef4bb51d0533aaa669ecd4a04c7b2cda3fbf54f62e180f1"></a>DecrementClamp&#160;</td><td class="fielddoc"><p>Decrement until min value. </p>
</td></tr>
<tr><td class="fieldname"><a id="adaffc1ac547687d86eef4bb51d0533aaa9b8958acb7be504bb5f55f17c0eea366"></a>Invert&#160;</td><td class="fielddoc"><p>Bitwise-not the existing value. </p>
</td></tr>
<tr><td class="fieldname"><a id="adaffc1ac547687d86eef4bb51d0533aaaaa91cb7f033b90dec9582dc5e9611732"></a>IncrementWrap&#160;</td><td class="fielddoc"><p>Increment the existing value, wrap if &gt;max. </p>
</td></tr>
<tr><td class="fieldname"><a id="adaffc1ac547687d86eef4bb51d0533aaa6ec565c329385c8d59333abc6a1003d1"></a>DecrementWrap&#160;</td><td class="fielddoc"><p>Decrement the existing value, wrap if &lt;min. </p>
</td></tr>
</table>

</div>
</div>
<a id="a6fffa33db4623ece1088010c6f78bc9f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6fffa33db4623ece1088010c6f78bc9f">&#9670;&nbsp;</a></span>StepRate</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacepvr.html#a6fffa33db4623ece1088010c6f78bc9f">pvr::StepRate</a> : uint32_t</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Step rate for a vertex attribute when drawing: Per vertex, per instance, per draw.</p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a6fffa33db4623ece1088010c6f78bc9fab22b929ba52471a02d18bb3a4e4472e6"></a>Vertex&#160;</td><td class="fielddoc"><p>Step rate Per vertex. </p>
</td></tr>
<tr><td class="fieldname"><a id="a6fffa33db4623ece1088010c6f78bc9fad9a17c1c9e8ef6866e4dbeef41c741b2"></a>Instance&#160;</td><td class="fielddoc"><p>Step rate per instance. </p>
</td></tr>
</table>

</div>
</div>
<a id="ab74a3e033b17a2d3f50ee6d0299eb195"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab74a3e033b17a2d3f50ee6d0299eb195">&#9670;&nbsp;</a></span>Swizzle</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacepvr.html#ab74a3e033b17a2d3f50ee6d0299eb195">pvr::Swizzle</a> : uint8_t</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Enumeration of texture Swizzle mask channels.</p>

</div>
</div>
<a id="a8be7d779089afe1df56a1bf542134d0d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8be7d779089afe1df56a1bf542134d0d">&#9670;&nbsp;</a></span>TextureFileFormat</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacepvr.html#a8be7d779089afe1df56a1bf542134d0d">pvr::TextureFileFormat</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Enumerates the texture formats directly supported by the Framework.</p>

</div>
</div>
<a id="a7449705e04c8fe948e390ea793106107"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7449705e04c8fe948e390ea793106107">&#9670;&nbsp;</a></span>VariableScope</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacepvr.html#a7449705e04c8fe948e390ea793106107">pvr::VariableScope</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The possible scope, or frequency of change, of a variable</p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a7449705e04c8fe948e390ea793106107a88183b946cc5f0e8c96b2e66e1c74a7e"></a>Unknown&#160;</td><td class="fielddoc"><p>Scope is unknown, undefined, or custom. </p>
</td></tr>
<tr><td class="fieldname"><a id="a7449705e04c8fe948e390ea793106107a086247a9b57fde6eefee2a0c4752242d"></a>Automatic&#160;</td><td class="fielddoc"><p>Scope is being inferred from use. </p>
</td></tr>
<tr><td class="fieldname"><a id="a7449705e04c8fe948e390ea793106107aa559b87068921eec05086ce5485e9784"></a>Model&#160;</td><td class="fielddoc"><p>The variable is per model (stays constant for a given model, for example, ViewMatrix) </p>
</td></tr>
<tr><td class="fieldname"><a id="a7449705e04c8fe948e390ea793106107aa62d22910732d5343689f5117999abfa"></a>Effect&#160;</td><td class="fielddoc"><p>The variable is per effect (stays constant for a given effect, for example, directional light intensity) </p>
</td></tr>
<tr><td class="fieldname"><a id="a7449705e04c8fe948e390ea793106107a6c3a6944a808a7c0bbb6788dbec54a9f"></a>Node&#160;</td><td class="fielddoc"><p>The variable is per Mesh Node (stays constant for a given node of a model, for example, ModelViewProjection matrix) </p>
</td></tr>
<tr><td class="fieldname"><a id="a7449705e04c8fe948e390ea793106107aa65c9562b8c9e07299be6bc0b4f3a072"></a>BoneBatch&#160;</td><td class="fielddoc"><p>The variable is per Bone Batch (deprecated - stays constant for a given Bone Batch, for example, bones) </p>
</td></tr>
</table>

</div>
</div>
<a id="a6f7777c11dfff8fcf4a03d85e5ab0b98"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6f7777c11dfff8fcf4a03d85e5ab0b98">&#9670;&nbsp;</a></span>VariableType</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacepvr.html#a6f7777c11dfff8fcf4a03d85e5ab0b98">pvr::VariableType</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Enumeration of Datatypes.</p>

</div>
</div>
<a id="a7f3166dd9130684c23ff89682e4b38c8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7f3166dd9130684c23ff89682e4b38c8">&#9670;&nbsp;</a></span>VsyncMode</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacepvr.html#a7f3166dd9130684c23ff89682e4b38c8">pvr::VsyncMode</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The Vertical Synchronization (or lack thereof) modes, A.K.A. Presentation mode.</p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a7f3166dd9130684c23ff89682e4b38c8ad15305d7a4e34e02489c74a5ef542f36"></a>Off&#160;</td><td class="fielddoc"><p>The application does not synchronizes with the vertical sync. If application renders faster than the display refreshes, frames are wasted and tearing may be observed. FPS is uncapped. Maximum power consumption. If unsupported, "ON" value will be used instead. Minimum latency. </p>
</td></tr>
<tr><td class="fieldname"><a id="a7f3166dd9130684c23ff89682e4b38c8a521c36a31c2762741cf0f8890cbe05e3"></a>On&#160;</td><td class="fielddoc"><p>The application is always syncrhonized with the vertical sync. Tearing does not happen. FPS is capped to the display's refresh rate. For fast applications, battery life is improved. Always supported. </p>
</td></tr>
<tr><td class="fieldname"><a id="a7f3166dd9130684c23ff89682e4b38c8a4160be5df3fc34c3b165f28616f1bd16"></a>Relaxed&#160;</td><td class="fielddoc"><p>The application synchronizes with the vertical sync, but only if the application rendering speed is greater than refresh rate. Compared to OFF, there is no tearing. Compared to ON, the FPS will be improved for "slower" applications. If unsupported, "ON" value will be used instead. Recommended for most applications. Default if supported. </p>
</td></tr>
<tr><td class="fieldname"><a id="a7f3166dd9130684c23ff89682e4b38c8a2dcff8c037093c5d3552ad532e603f9f"></a>Mailbox&#160;</td><td class="fielddoc"><p>The presentation engine will always use the latest fully rendered image. Compared to OFF, no tearing will be observed. Compared to ON, battery power will be worse, especially for faster applications. If unsupported, "OFF" will be attempted next. </p>
</td></tr>
<tr><td class="fieldname"><a id="a7f3166dd9130684c23ff89682e4b38c8ac48615a1bc4197056d522af276aa5a85"></a>Half&#160;</td><td class="fielddoc"><p>The application is capped to using half the vertical sync time. FPS artificially capped to Half the display speed (usually 30fps) to maintain battery. Best possible battery savings. Worst possibly performance. Recommended for specific applications where battery saving is critical. </p>
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="a3dc927ae582f3ec00005bf32ceb97830"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3dc927ae582f3ec00005bf32ceb97830">&#9670;&nbsp;</a></span>align()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename t1 , typename t2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">t1 pvr::align </td>
          <td>(</td>
          <td class="paramtype">t1&#160;</td>
          <td class="paramname"><em>numberToAlign</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">t2&#160;</td>
          <td class="paramname"><em>alignment</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Aligns a given number based on the given alignment</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">numberToAlign</td><td>A number ot align based alignment</td></tr>
    <tr><td class="paramname">alignment</td><td>The value to which the numberToAlign will be aligned</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An aligned value</dd></dl>

</div>
</div>
<a id="a0303f68824c30e29b02875302cd75d96"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0303f68824c30e29b02875302cd75d96">&#9670;&nbsp;</a></span>apiCode()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const char* pvr::apiCode </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacepvr.html#a74c5d1afa51512f076dd8e5844b171c8">Api</a>&#160;</td>
          <td class="paramname"><em>api</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get a string of the specific api enum</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">api</td><td>The api</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Api code</dd></dl>

</div>
</div>
<a id="ac0940447f72ad2b8777a37cd3181b5c9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac0940447f72ad2b8777a37cd3181b5c9">&#9670;&nbsp;</a></span>apiName()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const char* pvr::apiName </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacepvr.html#a74c5d1afa51512f076dd8e5844b171c8">Api</a>&#160;</td>
          <td class="paramname"><em>api</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the api name std::string of the given Enumeration</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">api</td><td>The api</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Api name std::string</dd></dl>

</div>
</div>
<a id="ad604ae533aa5f192cf745d3b37e1f7e1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad604ae533aa5f192cf745d3b37e1f7e1">&#9670;&nbsp;</a></span>convertXYZToCubeUV()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void pvr::convertXYZToCubeUV </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>z</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacepvr.html#a87b409df225dee78541eb74988f4e20c">CubeFace</a> &amp;&#160;</td>
          <td class="paramname"><em>face</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float &amp;&#160;</td>
          <td class="paramname"><em>u</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float &amp;&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Converts an x, y and z direction to a texture coordinate of a particular cubemap face.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>The x component of te direction.</td></tr>
    <tr><td class="paramname">y</td><td>The y component of te direction.</td></tr>
    <tr><td class="paramname">z</td><td>The z component of te direction.</td></tr>
    <tr><td class="paramname">face</td><td>The cubemap face enumeration retrieved using the x, y, z direction.</td></tr>
    <tr><td class="paramname">u</td><td>The u component of the texture coordinate retrieved.</td></tr>
    <tr><td class="paramname">v</td><td>The v component of the texture coordinate retrieved.</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a32304b6fe8a8ebcfdaa03d5b227da809"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a32304b6fe8a8ebcfdaa03d5b227da809">&#9670;&nbsp;</a></span>dataTypeIsNormalised()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool pvr::dataTypeIsNormalised </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacepvr.html#a7924324f96dc973225ad3c532cc72309">DataType</a>&#160;</td>
          <td class="paramname"><em>type</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return if the format is Normalized (represents a range between 0..1 for unsigned types or between -1..1 for signed types)</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">type</td><td>The format to test.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the format is Normalised.</dd></dl>
<p>A Normalised format is a value that is stored as an Integer, but that actually represents a value from 0..1 or -1..1 instead of the numeric value of the Integer. For example, for a normalised unsigned char value, the value 0 represents 0.0, the value 127 represents 0.5 and the value 255 represents 1.0.</p>

</div>
</div>
<a id="a4bbe49ea1e5ffbeaf1463379ff1adcfc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4bbe49ea1e5ffbeaf1463379ff1adcfc">&#9670;&nbsp;</a></span>dataTypeSize()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t pvr::dataTypeSize </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacepvr.html#a7924324f96dc973225ad3c532cc72309">DataType</a>&#160;</td>
          <td class="paramname"><em>type</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the Size of a DataType.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">type</td><td>The Data type</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The size of the Datatype in bytes.</dd></dl>

</div>
</div>
<a id="af4676d56d2f795d4c4f5b7a094af90c9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af4676d56d2f795d4c4f5b7a094af90c9">&#9670;&nbsp;</a></span>descriptorTypeToBufferUsage()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacepvr.html#aa6ac287ad32e4b14937cee7ac81fb85e">BufferUsageFlags</a> pvr::descriptorTypeToBufferUsage </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacepvr.html#a3283c5c9822ac5135fefd45a7cdd5932">DescriptorType</a>&#160;</td>
          <td class="paramname"><em>descType</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Infer the BufferUsageFlags that are suitable for the typical use of an object</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">descType</td><td>A descriptor type</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The typical usage flags for &lt;paramref name="descType/&gt;</dd></dl>

</div>
</div>
<a id="a43dd44f92c0013d2ed1dd13363070770"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a43dd44f92c0013d2ed1dd13363070770">&#9670;&nbsp;</a></span>getAlignment()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t pvr::getAlignment </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacepvr.html#aa4440f5fd1256889bd3b3822002208b6">GpuDatatypes</a>&#160;</td>
          <td class="paramname"><em>type</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get required alignment of this type as demanded by std140 rules</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">type</td><td>The datatype to test</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The required alignment of the type based on std140 (see the GLSL spec)</dd></dl>

</div>
</div>
<a id="abe1ac49f71337e1cfd4e6436b3bb9ca6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abe1ac49f71337e1cfd4e6436b3bb9ca6">&#9670;&nbsp;</a></span>getBaseType()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacepvr_1_1_gpu_datatypes_helper.html#abead2e53bdab9ebb17f7c858a2844e14">GpuDatatypesHelper::BaseType</a> pvr::getBaseType </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacepvr.html#aa4440f5fd1256889bd3b3822002208b6">GpuDatatypes</a>&#160;</td>
          <td class="paramname"><em>type</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the underlying element of a type (integer or float)</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">type</td><td>The datatype to test</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A BaseType enum (integer or float)</dd></dl>

</div>
</div>
<a id="a6bc2716579dfbeade26021e2628dd7a7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6bc2716579dfbeade26021e2628dd7a7">&#9670;&nbsp;</a></span>getCpuPackedSize()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t pvr::getCpuPackedSize </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacepvr.html#aa4440f5fd1256889bd3b3822002208b6">GpuDatatypes</a>&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>arrayElements</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the size of n array members of a type, packed in CPU</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">type</td><td>The datatype to test</td></tr>
    <tr><td class="paramname">arrayElements</td><td>The number of array elements</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The base size of the type multiplied by arrayElements</dd></dl>

</div>
</div>
<a id="a65076be9fba2c986f80ffe1eb64aa29a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a65076be9fba2c986f80ffe1eb64aa29a">&#9670;&nbsp;</a></span>getNumMatrixColumns()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t pvr::getNumMatrixColumns </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacepvr.html#aa4440f5fd1256889bd3b3822002208b6">GpuDatatypes</a>&#160;</td>
          <td class="paramname"><em>type</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the number of colums (1..4) of the type</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">type</td><td>The datatype to test</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of matrix colums (1..4) of the type. 1 implies not a matrix</dd></dl>

</div>
</div>
<a id="a8277a30a2c9fa98ba8c66c2c8516f923"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8277a30a2c9fa98ba8c66c2c8516f923">&#9670;&nbsp;</a></span>getNumVecElements()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t pvr::getNumVecElements </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacepvr.html#aa4440f5fd1256889bd3b3822002208b6">GpuDatatypes</a>&#160;</td>
          <td class="paramname"><em>type</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the number of vector elements (i.e. Rows) of a type. (e.g. vec2=&gt;2)</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">type</td><td>The datatype to test</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of vector elements.</dd></dl>

</div>
</div>
<a id="a5b67db200cee4a4078676dc5f3622ec0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5b67db200cee4a4078676dc5f3622ec0">&#9670;&nbsp;</a></span>getOffsetAfter()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t pvr::getOffsetAfter </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacepvr.html#aa4440f5fd1256889bd3b3822002208b6">GpuDatatypes</a>&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>previousTotalSize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Aligns an address/offset with the alignment of a type &ndash; equivalently, assuming you want to place a type after a known offset (i.e. calculating the offset of an item inside a struct having already calculated its previous element) (i.e. aligning a vec4 after an item that ends at 30 bytes returns 32 bytes...)</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">type</td><td>The datatype to test</td></tr>
    <tr><td class="paramname">previousTotalSize</td><td>The address/offset to align for that type</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><em>previousTotalSize</em>  aligned to the requirements of <em>type</em> </dd></dl>

</div>
</div>
<a id="a10f119283374e989cd179f6831fe1e36"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a10f119283374e989cd179f6831fe1e36">&#9670;&nbsp;</a></span>getResultCodeString()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const char* pvr::getResultCodeString </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacepvr.html#a1c5fa1488e4ba61dd568718646a8c73d">Result</a>&#160;</td>
          <td class="paramname"><em>result</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Use this function to convert a Result into a std::string that is suitable for outputting.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">result</td><td>The result</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A std::string suitable for writing out that represents this Result</dd></dl>

</div>
</div>
<a id="a7caef391618cc1a3ebab73d8ffe90a47"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7caef391618cc1a3ebab73d8ffe90a47">&#9670;&nbsp;</a></span>getSelfAlignedArraySize()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t pvr::getSelfAlignedArraySize </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacepvr.html#aa4440f5fd1256889bd3b3822002208b6">GpuDatatypes</a>&#160;</td>
          <td class="paramname"><em>type</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns "how many bytes will an object of this type take", if it is an array member (arrays have potentially stricter requirements).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">type</td><td>The datatype to test</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The size of this type, aligned to max array alignment restrictions</dd></dl>

</div>
</div>
<a id="a239df321236ac77da04fe9d58f5efe55"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a239df321236ac77da04fe9d58f5efe55">&#9670;&nbsp;</a></span>getSelfAlignedSize()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t pvr::getSelfAlignedSize </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacepvr.html#aa4440f5fd1256889bd3b3822002208b6">GpuDatatypes</a>&#160;</td>
          <td class="paramname"><em>type</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns "how many bytes will an object of this type take", if not an array.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">type</td><td>The datatype to test</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The size of this type, aligned to its own alignment restrictions</dd></dl>

</div>
</div>
<a id="a7e17c970a2a4965269fcb9e3e55049dd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7e17c970a2a4965269fcb9e3e55049dd">&#9670;&nbsp;</a></span>getSize()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t pvr::getSize </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacepvr.html#aa4440f5fd1256889bd3b3822002208b6">GpuDatatypes</a>&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>arrayElements</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns how many bytes an array of n objects of this type take, but arrayElements = 1 is NOT considered an array (is aligned as a single object, NOT an array of 1)</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">type</td><td>The datatype to test</td></tr>
    <tr><td class="paramname">arrayElements</td><td>The number of array elements. 1 is NOT considered an array.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The size of X elements takes</dd></dl>

</div>
</div>
<a id="a5486ebd5e2197fa607b0fc29c7850742"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5486ebd5e2197fa607b0fc29c7850742">&#9670;&nbsp;</a></span>getTextureFormatFromFilename()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacepvr.html#a8be7d779089afe1df56a1bf542134d0d">TextureFileFormat</a> pvr::getTextureFormatFromFilename </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>assetname</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Infer the texture format from a filename.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">assetname</td><td>The name of the asset, containing the extension.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The TextureFileFormat if understood, otherwise <a class="el" href="namespacepvr.html#a7449705e04c8fe948e390ea793106107a88183b946cc5f0e8c96b2e66e1c74a7e" title="Scope is unknown, undefined, or custom. ">TextureFileFormat::Unknown</a>.</dd></dl>

</div>
</div>
<a id="a6bc881503cace7cf8d883d54905aa462"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6bc881503cace7cf8d883d54905aa462">&#9670;&nbsp;</a></span>getTotalSizeAfter()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t pvr::getTotalSizeAfter </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacepvr.html#aa4440f5fd1256889bd3b3822002208b6">GpuDatatypes</a>&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>arrayElements</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>previousTotalSize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the new size of a hypothetical struct whose old size was previousTotalSize, and to which "arrayElement" new items of type "type" are added</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">type</td><td>The datatype to add</td></tr>
    <tr><td class="paramname">arrayElements</td><td>The number of items of type <em>type</em>  to add</td></tr>
    <tr><td class="paramname">previousTotalSize</td><td>The address/offset to align for that type</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The new size</dd></dl>

</div>
</div>
<a id="a4c310f549c8db9647eeeef82a0a56af0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4c310f549c8db9647eeeef82a0a56af0">&#9670;&nbsp;</a></span>getVectorSelfAlignedSize()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t pvr::getVectorSelfAlignedSize </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacepvr.html#aa4440f5fd1256889bd3b3822002208b6">GpuDatatypes</a>&#160;</td>
          <td class="paramname"><em>type</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the size of a type, including padding, assuming the next item is of the same type</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">type</td><td>The datatype to test</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The size plus padding of this type</dd></dl>

</div>
</div>
<a id="a3cbe7fd082e1089dc162d9afdacdd6f1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3cbe7fd082e1089dc162d9afdacdd6f1">&#9670;&nbsp;</a></span>getVectorUnalignedSize()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t pvr::getVectorUnalignedSize </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacepvr.html#aa4440f5fd1256889bd3b3822002208b6">GpuDatatypes</a>&#160;</td>
          <td class="paramname"><em>type</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the cpu-packed size of each vector element a type (disregarding matrix columns if they exist)</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">type</td><td>The datatype to test</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The size that a single column of <em>type</em>  would take on the CPU</dd></dl>

</div>
</div>
<a id="a1a43f0a8e74fd2e53e456ced76b3a9ac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1a43f0a8e74fd2e53e456ced76b3a9ac">&#9670;&nbsp;</a></span>growFloat()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">float pvr::growFloat </td>
          <td>(</td>
          <td class="paramtype">const uint32_t &amp;&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t &amp;&#160;</td>
          <td class="paramname"><em>mantissaBits</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t &amp;&#160;</td>
          <td class="paramname"><em>exponentBits</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t &amp;&#160;</td>
          <td class="paramname"><em>exponentBias</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>hasSign</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Produces a floating point value based on the uint32_t value, the mantissa bits and exponent bits</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>The uint32_t value</td></tr>
    <tr><td class="paramname">mantissaBits</td><td>The mantissa bits</td></tr>
    <tr><td class="paramname">exponentBits</td><td>The exponent bits</td></tr>
    <tr><td class="paramname">exponentBias</td><td>The exponent bias</td></tr>
    <tr><td class="paramname">hasSign</td><td>Specifies whether the float has a sign bit</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The resulting floating point value</dd></dl>

</div>
</div>
<a id="ade5ae06be9adae4c32d10aa679b5731e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ade5ae06be9adae4c32d10aa679b5731e">&#9670;&nbsp;</a></span>hash32_32()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1_ &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t pvr::hash32_32 </td>
          <td>(</td>
          <td class="paramtype">const T1_ &amp;&#160;</td>
          <td class="paramname"><em>t</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Function object hashing to 32 bit values into a 32 bit unsigned Integer.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">t</td><td>The value to hash.</td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T1_</td><td>The type of the value to hash.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The hash of the value.</dd></dl>

</div>
</div>
<a id="a18b97ab7a969dcd477d5e6c236a0bec4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a18b97ab7a969dcd477d5e6c236a0bec4">&#9670;&nbsp;</a></span>hash32_bytes()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t pvr::hash32_bytes </td>
          <td>(</td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>bytes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Function object hashing a number of bytes into a 32 bit unsigned Integer.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bytes</td><td>Pointer to a block of memory.</td></tr>
    <tr><td class="paramname">count</td><td>Number of bytes to hash.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The hash of the value.</dd></dl>

</div>
</div>
<a id="a128900aeb6815de42a6d6d2c59f67a6e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a128900aeb6815de42a6d6d2c59f67a6e">&#9670;&nbsp;</a></span>imageViewTypeToImageBaseType()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacepvr.html#ab98ea90165357c2f9030218c337f90bf">ImageType</a> pvr::imageViewTypeToImageBaseType </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacepvr.html#a43f03a43047f737186d5b90b19dcaca2">ImageViewType</a>&#160;</td>
          <td class="paramname"><em>viewtype</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Map an ImageViewType (2dCube etc) to its base type (1d/2d/3d)</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">viewtype</td><td>The ImageViewType</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The base type</dd></dl>

</div>
</div>
<a id="a3fd0cfec4d261dd1caa2ce5eefcc2a53"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3fd0cfec4d261dd1caa2ce5eefcc2a53">&#9670;&nbsp;</a></span>indexTypeSizeInBytes()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t pvr::indexTypeSizeInBytes </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacepvr.html#aab40a4733df51a99c80b389348c493ac">IndexType</a>&#160;</td>
          <td class="paramname"><em>type</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the Size of an IndexType in bytes.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">type</td><td>The Index type</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of bytes in an index type</dd></dl>

</div>
</div>
<a id="aff2eee1ed23143ae72185a5472ea765a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aff2eee1ed23143ae72185a5472ea765a">&#9670;&nbsp;</a></span>isDescriptorTypeDynamic()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool pvr::isDescriptorTypeDynamic </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacepvr.html#a3283c5c9822ac5135fefd45a7cdd5932">DescriptorType</a>&#160;</td>
          <td class="paramname"><em>descType</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks if a descriptor type is dynamic (a dynamic UBO or dynamic SSBO)</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">descType</td><td>A descriptor type</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if descType is UniformBufferDynamic or StorageBufferDynamic, otherwise false</dd></dl>

</div>
</div>
<a id="a47994de10c19816f5b4f0351e265ead5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a47994de10c19816f5b4f0351e265ead5">&#9670;&nbsp;</a></span>isVariableTypeNormalized()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool pvr::isVariableTypeNormalized </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacepvr.html#a6f7777c11dfff8fcf4a03d85e5ab0b98">VariableType</a>&#160;</td>
          <td class="paramname"><em>item</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check if a variable type is a Normalizedtype</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">item</td><td>The variable to check</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if item is a normalized type (nomralized short, normalized integer etc)</dd></dl>

</div>
</div>
<a id="ad8844086c38cb4b2dddc3317494b16ac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad8844086c38cb4b2dddc3317494b16ac">&#9670;&nbsp;</a></span>isVariableTypeSigned()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool pvr::isVariableTypeSigned </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacepvr.html#a6f7777c11dfff8fcf4a03d85e5ab0b98">VariableType</a>&#160;</td>
          <td class="paramname"><em>item</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check if a variable type is a Signed type</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">item</td><td>The variable to check</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if item is a signed type (signed integer, signed float etc), otherwise false</dd></dl>

</div>
</div>
<a id="ac73ce628e547374c22057ff8e3a89bb3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac73ce628e547374c22057ff8e3a89bb3">&#9670;&nbsp;</a></span>mergeDatatypesBigger()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacepvr.html#aa4440f5fd1256889bd3b3822002208b6">GpuDatatypes</a> pvr::mergeDatatypesBigger </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacepvr.html#aa4440f5fd1256889bd3b3822002208b6">GpuDatatypes</a>&#160;</td>
          <td class="paramname"><em>type1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacepvr.html#aa4440f5fd1256889bd3b3822002208b6">GpuDatatypes</a>&#160;</td>
          <td class="paramname"><em>type2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a datatype that is larger or equal to both of two types: 1) Has the most permissive base type (float&gt;int) 2) Has the largest of the two vector widths 3) Has the most of the two matrix colums heights</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">type1</td><td>The first type</td></tr>
    <tr><td class="paramname">type2</td><td>The second type</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A type that can fit either of type1 or type1</dd></dl>

</div>
</div>
<a id="a7ef5be44f3a11eac1a122cafd4a217db"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7ef5be44f3a11eac1a122cafd4a217db">&#9670;&nbsp;</a></span>mergeDatatypesSmaller()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacepvr.html#aa4440f5fd1256889bd3b3822002208b6">GpuDatatypes</a> pvr::mergeDatatypesSmaller </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacepvr.html#aa4440f5fd1256889bd3b3822002208b6">GpuDatatypes</a>&#160;</td>
          <td class="paramname"><em>type1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacepvr.html#aa4440f5fd1256889bd3b3822002208b6">GpuDatatypes</a>&#160;</td>
          <td class="paramname"><em>type2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a datatype that is smaller or equal to both of two types: 1) Has the most permissive base type (float&gt;int) 2) Has the smaller of the two vector widths 3) Has the least of the two matrix colums heights</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">type1</td><td>The first type</td></tr>
    <tr><td class="paramname">type2</td><td>The second type</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A type that will truncate everything the two types don't share</dd></dl>

</div>
</div>
<a id="a33df3732a0a48b5274ac3938a7e570b0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a33df3732a0a48b5274ac3938a7e570b0">&#9670;&nbsp;</a></span>numDataTypeComponents()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t pvr::numDataTypeComponents </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacepvr.html#a7924324f96dc973225ad3c532cc72309">DataType</a>&#160;</td>
          <td class="paramname"><em>type</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the number of components in a datatype.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">type</td><td>The datatype</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of components (e.g. float is 1, vec3 is 3)</dd></dl>

</div>
</div>
<a id="ace778b3dc26297c9b8e57205c37e32b3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ace778b3dc26297c9b8e57205c37e32b3">&#9670;&nbsp;</a></span>operator &() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacepvr.html#aa4440f5fd1256889bd3b3822002208b6">GpuDatatypes</a> pvr::operator&amp; </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacepvr.html#aa4440f5fd1256889bd3b3822002208b6">GpuDatatypes</a>&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacepvr_1_1_gpu_datatypes_helper.html#a84bf23cf8acb6cfb591074eda461590f">GpuDatatypesHelper::Bits</a>&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Bitwise operator AND. Typical semantics. Allows AND between GpuDatatypes and Bits</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>Left hand side</td></tr>
    <tr><td class="paramname">rhs</td><td>Right hand side</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>lhs AND rhs</dd></dl>

</div>
</div>
<a id="ac7ea58158def42897beab0d03b6a715f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac7ea58158def42897beab0d03b6a715f">&#9670;&nbsp;</a></span>operator &() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacepvr.html#aee12f61a84bee4c4513c6bfad5b042d2">ImageAspectFlags</a> pvr::operator&amp; </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacepvr.html#aee12f61a84bee4c4513c6bfad5b042d2">ImageAspectFlags</a>&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacepvr.html#aee12f61a84bee4c4513c6bfad5b042d2">ImageAspectFlags</a>&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Operator&amp;.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The right hand side of the operator</td></tr>
    <tr><td class="paramname">rhs</td><td>The right hand side of the operator</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A set of ImageAspectFlags after applying the operator&amp;.</dd></dl>

</div>
</div>
<a id="a5de0698d0beb6ad53d66cee8c3da3d50"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5de0698d0beb6ad53d66cee8c3da3d50">&#9670;&nbsp;</a></span>operator &=()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void pvr::operator&amp;= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacepvr.html#aee12f61a84bee4c4513c6bfad5b042d2">ImageAspectFlags</a> &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacepvr.html#aee12f61a84bee4c4513c6bfad5b042d2">ImageAspectFlags</a>&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Operator&amp;=.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The right hand side of the operator</td></tr>
    <tr><td class="paramname">rhs</td><td>The right hand side of the operator</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A set of ImageAspectFlags after applying the operator&amp;=.</dd></dl>

</div>
</div>
<a id="ae6830359c957ddaf92782874bb70e825"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae6830359c957ddaf92782874bb70e825">&#9670;&nbsp;</a></span>operator<<()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacepvr.html#aa4440f5fd1256889bd3b3822002208b6">GpuDatatypes</a> pvr::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacepvr.html#aa4440f5fd1256889bd3b3822002208b6">GpuDatatypes</a>&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacepvr_1_1_gpu_datatypes_helper.html#a84bf23cf8acb6cfb591074eda461590f">GpuDatatypesHelper::Bits</a>&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Bitwise operator LEFT SHIFT. Typical semantics. Allows LEFT SHIFT of GpuDatatypes by Bits</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>Left hand side</td></tr>
    <tr><td class="paramname">rhs</td><td>Right hand side</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>lhs LEFT SHIFT rhs</dd></dl>

</div>
</div>
<a id="ab32d83bd296ef37d4c646b2552e276e7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab32d83bd296ef37d4c646b2552e276e7">&#9670;&nbsp;</a></span>operator>>()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacepvr.html#aa4440f5fd1256889bd3b3822002208b6">GpuDatatypes</a> pvr::operator&gt;&gt; </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacepvr.html#aa4440f5fd1256889bd3b3822002208b6">GpuDatatypes</a>&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacepvr_1_1_gpu_datatypes_helper.html#a84bf23cf8acb6cfb591074eda461590f">GpuDatatypesHelper::Bits</a>&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Bitwise operator RIGHT SHIFT. Typical semantics. Allows RIGHT SHIFT of GpuDatatypes by Bits</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>Left hand side</td></tr>
    <tr><td class="paramname">rhs</td><td>Right hand side</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>lhs RIGHT SHIFT rhs</dd></dl>

</div>
</div>
<a id="af90306acc1aaa07ed01111e86229dd02"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af90306acc1aaa07ed01111e86229dd02">&#9670;&nbsp;</a></span>operator|()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacepvr.html#aee12f61a84bee4c4513c6bfad5b042d2">ImageAspectFlags</a> pvr::operator| </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacepvr.html#aee12f61a84bee4c4513c6bfad5b042d2">ImageAspectFlags</a>&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacepvr.html#aee12f61a84bee4c4513c6bfad5b042d2">ImageAspectFlags</a>&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Operator|.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The right hand side of the operator</td></tr>
    <tr><td class="paramname">rhs</td><td>The right hand side of the operator</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A set of ImageAspectFlags after applying the operator|.</dd></dl>

</div>
</div>
<a id="ad9b7e5a5c13f5eb605d551685cff1be7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad9b7e5a5c13f5eb605d551685cff1be7">&#9670;&nbsp;</a></span>operator|=()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void pvr::operator|= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacepvr.html#aee12f61a84bee4c4513c6bfad5b042d2">ImageAspectFlags</a> &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacepvr.html#aee12f61a84bee4c4513c6bfad5b042d2">ImageAspectFlags</a>&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Operator|=.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The right hand side of the operator</td></tr>
    <tr><td class="paramname">rhs</td><td>The right hand side of the operator</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A set of ImageAspectFlags after applying the operator|=.</dd></dl>

</div>
</div>
<a id="abbe45548f9e676d52b1645ea21ba4d11"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abbe45548f9e676d52b1645ea21ba4d11">&#9670;&nbsp;</a></span>packSamplerFilter()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacepvr.html#aafc960d10904ec52d4d823ed66717c43">PackedSamplerFilter</a> pvr::packSamplerFilter </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacepvr.html#a84d320093e1561f82e57776aafd947d7">Filter</a>&#160;</td>
          <td class="paramname"><em>mini</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacepvr.html#a84d320093e1561f82e57776aafd947d7">Filter</a>&#160;</td>
          <td class="paramname"><em>magni</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacepvr.html#ac7a59f03f943f1c79a5339331fc15abe">SamplerMipmapMode</a>&#160;</td>
          <td class="paramname"><em>mip</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Pack a minification filter, a magnification filter and a mipmap filter into an 8 bit value</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mini</td><td>The filtering mode that should be used for minification</td></tr>
    <tr><td class="paramname">magni</td><td>The filtering mode that should be used for magnification</td></tr>
    <tr><td class="paramname">mip</td><td>The filtering mode that should be used for mipmapping</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An 8 bit value representing the described sampler</dd></dl>

</div>
</div>
<a id="a717b05fe80f33f87f83e84aafdcd6029"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a717b05fe80f33f87f83e84aafdcd6029">&#9670;&nbsp;</a></span>PVRTDecompressETC()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t pvr::PVRTDecompressETC </td>
          <td>(</td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>srcData</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>xDim</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>yDim</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>dstData</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>mode</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Decompresses ETC to RGBA 8888.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">srcData</td><td>The ETC texture data to decompress</td></tr>
    <tr><td class="paramname">xDim</td><td>X dimension of the texture</td></tr>
    <tr><td class="paramname">yDim</td><td>Y dimension of the texture</td></tr>
    <tr><td class="paramname">dstData</td><td>The decompressed texture data</td></tr>
    <tr><td class="paramname">mode</td><td>The format of the data</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Return The number of bytes of ETC data decompressed</dd></dl>

</div>
</div>
<a id="aff06586480b28aae72e01be1c735cacf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aff06586480b28aae72e01be1c735cacf">&#9670;&nbsp;</a></span>PVRTDecompressPVRTC()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t pvr::PVRTDecompressPVRTC </td>
          <td>(</td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>compressedData</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>do2bitMode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>xDim</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>yDim</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>outResultImage</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Decompresses PVRTC to RGBA 8888.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">compressedData</td><td>The PVRTC texture data to decompress</td></tr>
    <tr><td class="paramname">do2bitMode</td><td>Signifies whether the data is PVRTC2 or PVRTC4</td></tr>
    <tr><td class="paramname">xDim</td><td>X dimension of the texture</td></tr>
    <tr><td class="paramname">yDim</td><td>Y dimension of the texture</td></tr>
    <tr><td class="paramname">outResultImage</td><td>The decompressed texture data</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Return the amount of data that was decompressed.</dd></dl>

</div>
</div>
<a id="a7cc135f8fc78f66cf936fd87efc7fccf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7cc135f8fc78f66cf936fd87efc7fccf">&#9670;&nbsp;</a></span>randomrange()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">float pvr::randomrange </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>min</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>max</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get a random Number between min and max</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">min</td><td>Minimum number (inclusive)</td></tr>
    <tr><td class="paramname">max</td><td>Maximum number (inclusive)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Random number</dd></dl>

</div>
</div>
<a id="a960c0fbbee6c09de2e753f4d4df0a977"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a960c0fbbee6c09de2e753f4d4df0a977">&#9670;&nbsp;</a></span>textureLoad() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpvr_1_1_texture.html">Texture</a> pvr::textureLoad </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classpvr_1_1_stream.html">Stream</a> &amp;&#160;</td>
          <td class="paramname"><em>textureStream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacepvr.html#a8be7d779089afe1df56a1bf542134d0d">TextureFileFormat</a>&#160;</td>
          <td class="paramname"><em>type</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Load a texture from binary data. Synchronous.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">textureStream</td><td>A stream from which to load the binary data</td></tr>
    <tr><td class="paramname">type</td><td>The type of the texture. Several supported formats.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns a successfully created <a class="el" href="classpvr_1_1_texture.html" title="A 2D Texture asset, together with Information, Metadata and actual Pixel data. Only represents the ac...">pvr::Texture</a> object otherwise will throw</dd></dl>

</div>
</div>
<a id="af78cb1ebeebf974be88e5ec542eff07f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af78cb1ebeebf974be88e5ec542eff07f">&#9670;&nbsp;</a></span>textureLoad() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpvr_1_1_texture.html">Texture</a> pvr::textureLoad </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classpvr_1_1_stream.html">Stream</a> &amp;&#160;</td>
          <td class="paramname"><em>textureStream</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Load a texture from binary data. Synchronous.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">textureStream</td><td>A stream from which to load the binary data</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if successful, otherwise false</dd></dl>

</div>
</div>
<a id="a5a627b4365be1581c05ca10e33752b4f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5a627b4365be1581c05ca10e33752b4f">&#9670;&nbsp;</a></span>to_string()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string pvr::to_string </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacepvr.html#af5c2a4d46bb7aa6a877a0ed8c5ba3ac8">ShaderType</a>&#160;</td>
          <td class="paramname"><em>shaderType</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Converts a <a class="el" href="namespacepvr.html#af5c2a4d46bb7aa6a877a0ed8c5ba3ac8" title="Enumeration of all supported shader types.">pvr::ShaderType</a> to string</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">shaderType</td><td>The type of the shader</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A stringified version of <a class="el" href="namespacepvr.html#af5c2a4d46bb7aa6a877a0ed8c5ba3ac8" title="Enumeration of all supported shader types.">pvr::ShaderType</a></dd></dl>

</div>
</div>
<a id="a547738cbdb228eba2d1d4b58d2c142c9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a547738cbdb228eba2d1d4b58d2c142c9">&#9670;&nbsp;</a></span>toDataType()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacepvr.html#a7924324f96dc973225ad3c532cc72309">DataType</a> pvr::toDataType </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacepvr.html#aa4440f5fd1256889bd3b3822002208b6">GpuDatatypes</a>&#160;</td>
          <td class="paramname"><em>type</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the Cpu Datatype <em>type</em>  refers to (i.e. which CPU datatype must you load in the data you upload to the GPU to correctly upload the same value in the shader).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">type</td><td>The type to convert</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A CPU type that has the same bit representation as one scalar element of type (i.e. mat4x4 returns "float")</dd></dl>

</div>
</div>
<a id="aea8728868bc6c9fa07c48f1f6d0e2f37"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aea8728868bc6c9fa07c48f1f6d0e2f37">&#9670;&nbsp;</a></span>toString()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const char* pvr::toString </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacepvr.html#aa4440f5fd1256889bd3b3822002208b6">GpuDatatypes</a>&#160;</td>
          <td class="paramname"><em>type</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get a string with the glsl variable name of a type</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">type</td><td>The datatype to test</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A c-style string with the glsl variable keyword of <em>type</em> </dd></dl>

</div>
</div>
<a id="a93997dab7a634e84d3ac4cdd4bb7fa33"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a93997dab7a634e84d3ac4cdd4bb7fa33">&#9670;&nbsp;</a></span>unpackSamplerFilter()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void pvr::unpackSamplerFilter </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacepvr.html#aafc960d10904ec52d4d823ed66717c43">PackedSamplerFilter</a>&#160;</td>
          <td class="paramname"><em>packed</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacepvr.html#a84d320093e1561f82e57776aafd947d7">Filter</a> &amp;&#160;</td>
          <td class="paramname"><em>mini</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacepvr.html#a84d320093e1561f82e57776aafd947d7">Filter</a> &amp;&#160;</td>
          <td class="paramname"><em>magni</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacepvr.html#ac7a59f03f943f1c79a5339331fc15abe">SamplerMipmapMode</a> &amp;&#160;</td>
          <td class="paramname"><em>mip</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Unpack a 8 bit PackedSamplerFilter value into a minification, magnification and mip filter mode</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">packed</td><td>The packed sampler filter to unpack</td></tr>
    <tr><td class="paramname">mini</td><td>The filtering mode that should be used for minification</td></tr>
    <tr><td class="paramname">magni</td><td>The filtering mode that should be used for magnification</td></tr>
    <tr><td class="paramname">mip</td><td>The filtering mode that should be used for mipmapping</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An 8 bit value representing the described sampler</dd></dl>

</div>
</div>
<a id="a771a597a351ca78fd99c9059be6b6b0b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a771a597a351ca78fd99c9059be6b6b0b">&#9670;&nbsp;</a></span>writeTGA() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void pvr::writeTGA </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classpvr_1_1_stream.html">pvr::Stream</a> &amp;&#160;</td>
          <td class="paramname"><em>file</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>w</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>h</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned char *&#160;</td>
          <td class="paramname"><em>imageData</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint32_t&#160;</td>
          <td class="paramname"><em>stride</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>pixelReplicate</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Write out TGA data from an image.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">filename</td><td><a class="el" href="classpvr_1_1_stream.html" title="This class is used to abstract streams of data (files, blocks of memory, resources etc...">Stream</a> to write the TGA into</td></tr>
    <tr><td class="paramname">w</td><td>The width of the image</td></tr>
    <tr><td class="paramname">h</td><td>The height of the image</td></tr>
    <tr><td class="paramname">imageData</td><td>Pointer to the raw image data</td></tr>
    <tr><td class="paramname">stride</td><td>Size in bytes of each pixel. (Equal to the number of channels)</td></tr>
    <tr><td class="paramname">pixelReplicate</td><td>Upscale factor.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if successfuly completed, otherwise False. (log error on false)</dd></dl>

</div>
</div>
<a id="a3dc97c9ed2a10c891c9143a98f69c28b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3dc97c9ed2a10c891c9143a98f69c28b">&#9670;&nbsp;</a></span>writeTGA() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void pvr::writeTGA </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classpvr_1_1_stream.html">pvr::Stream</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>file</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>w</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>h</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned char *&#160;</td>
          <td class="paramname"><em>imageData</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned char&#160;</td>
          <td class="paramname"><em>stride</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>pixelReplicate</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Write out TGA data from an image.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">filename</td><td><a class="el" href="classpvr_1_1_stream.html" title="This class is used to abstract streams of data (files, blocks of memory, resources etc...">Stream</a> to write the TGA into</td></tr>
    <tr><td class="paramname">w</td><td>The width of the image</td></tr>
    <tr><td class="paramname">h</td><td>The height of the image</td></tr>
    <tr><td class="paramname">imageData</td><td>Pointer to the raw image data</td></tr>
    <tr><td class="paramname">stride</td><td>Size in bytes of each pixel. (Equal to the number of channels)</td></tr>
    <tr><td class="paramname">pixelReplicate</td><td>Upscale factor.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if successfuly completed, otherwise False. (log error on false)</dd></dl>

</div>
</div>
<a id="a1fbb5d45243437fd1da5e5c676ef886d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1fbb5d45243437fd1da5e5c676ef886d">&#9670;&nbsp;</a></span>writeTGA() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void pvr::writeTGA </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>filename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>w</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>h</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned char *&#160;</td>
          <td class="paramname"><em>imageData</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned char&#160;</td>
          <td class="paramname"><em>stride</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>pixelReplicate</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Write out TGA data from an image.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">filename</td><td>Filename for which a filestream will be created to write the TGA into</td></tr>
    <tr><td class="paramname">w</td><td>The width of the image</td></tr>
    <tr><td class="paramname">h</td><td>The height of the image</td></tr>
    <tr><td class="paramname">imageData</td><td>Pointer to the raw image data</td></tr>
    <tr><td class="paramname">stride</td><td>Size in bytes of each pixel. (Equal to the number of channels)</td></tr>
    <tr><td class="paramname">pixelReplicate</td><td>Upscale factor.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if successfuly completed, otherwise False. (log error on false)</dd></dl>

</div>
</div>
<a id="ac8bab478a8afc2458b8cf7a7f0a86526"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac8bab478a8afc2458b8cf7a7f0a86526">&#9670;&nbsp;</a></span>writeTGAFromPlanar() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void pvr::writeTGAFromPlanar </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classpvr_1_1_stream.html">pvr::Stream</a> &amp;&#160;</td>
          <td class="paramname"><em>stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>w</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>h</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned char *&#160;</td>
          <td class="paramname"><em>imageDataR</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned char *&#160;</td>
          <td class="paramname"><em>imageDataG</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned char *&#160;</td>
          <td class="paramname"><em>imageDataB</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint32_t&#160;</td>
          <td class="paramname"><em>stride</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>pixelReplicate</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Write out TGA data from an image.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">filename</td><td><a class="el" href="classpvr_1_1_stream.html" title="This class is used to abstract streams of data (files, blocks of memory, resources etc...">Stream</a> to write the TGA into</td></tr>
    <tr><td class="paramname">w</td><td>The width of the image</td></tr>
    <tr><td class="paramname">h</td><td>The height of the image</td></tr>
    <tr><td class="paramname">imageDataR</td><td>Pointer to the RED channel image data</td></tr>
    <tr><td class="paramname">imageDataG</td><td>Pointer to the GREEN channel image data</td></tr>
    <tr><td class="paramname">imageDataB</td><td>Pointer to the BLUE channel image data</td></tr>
    <tr><td class="paramname">stride</td><td>Size in bytes of each pixel</td></tr>
    <tr><td class="paramname">pixelReplicate</td><td>Upscale factor.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if successfuly completed, otherwise False. (log error on false)</dd></dl>

</div>
</div>
<a id="ab7a41d371ada7bd24719226dbdb25602"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab7a41d371ada7bd24719226dbdb25602">&#9670;&nbsp;</a></span>writeTGAFromPlanar() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void pvr::writeTGAFromPlanar </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>filename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>w</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>h</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned char *&#160;</td>
          <td class="paramname"><em>imageDataR</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned char *&#160;</td>
          <td class="paramname"><em>imageDataG</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned char *&#160;</td>
          <td class="paramname"><em>imageDataB</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint32_t&#160;</td>
          <td class="paramname"><em>stride</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>pixelReplicate</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Write out TGA data from an image.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">filename</td><td>C-style string with the filename to write the TGA.</td></tr>
    <tr><td class="paramname">w</td><td>The width of the image</td></tr>
    <tr><td class="paramname">h</td><td>The height of the image</td></tr>
    <tr><td class="paramname">imageDataR</td><td>Pointer to the RED channel image data</td></tr>
    <tr><td class="paramname">imageDataG</td><td>Pointer to the GREEN channel image data</td></tr>
    <tr><td class="paramname">imageDataB</td><td>Pointer to the BLUE channel image data</td></tr>
    <tr><td class="paramname">stride</td><td>Size in bytes of each pixel</td></tr>
    <tr><td class="paramname">pixelReplicate</td><td>Upscale factor.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if successfuly completed, otherwise False. (log error on false)</dd></dl>

</div>
</div>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.8.4-->
<!-- start footer part (NON TREEVIEW ONLY!!) -->
<!--BEGIN GENERATE_TREEVIEW-->
<div id="FooterMainContainer">
	<div id="FooterContainer">
		<div class="footerlogo">
			<a href="http://www.imgtec.com" target="_blank"><img src="img-footer-logo-grey.png" width="100%" height="100%" border="none" /></a>
		</div>
		<div class="copyright"><p>&copy; Imagination Technologies Limited<br> All rights reserved</p></div>
	</div>
</div>
</body>
</html>
