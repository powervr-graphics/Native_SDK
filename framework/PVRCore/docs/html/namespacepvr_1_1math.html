<!-- HTML header for doxygen 1.8.4-->
<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="generator" content="Doxygen 1.8.6"/>
<title>PVRCore: pvr::math Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="IMGdoxygen.css" rel="stylesheet" type="text/css"/>
<link rel="shortcut icon" type="image/x-icon" href="img.ico">
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
  <div class="headercontent">
    <div class="PVRlogo">
      <a href="https://www.imgtec.com/developers/" target="_blank"><img src="PVRlogo.png" width="40%" height="40%"  border="none" /></a>
    </div>
    <a class="SiteTitle"><span id="projectname">PVRCore</span> Documentation</a>
   <tbody>
  </div>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.6 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="inherits.html"><span>Class&#160;Hierarchy</span></a></li>
      <li class="current"><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Macros</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(10)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacepvr.html">pvr</a></li><li class="navelem"><a class="el" href="namespacepvr_1_1math.html">math</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">pvr::math Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Contains mathematical functionality and classes, such as bounding box calculations, intersections etc. 
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1math_1_1_axis_aligned_box.html">AxisAlignedBox</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class provides functionality to handle 3 dimensional Axis Aligned Boxes. Center-halfextent representation. <a href="classpvr_1_1math_1_1_axis_aligned_box.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1math_1_1_axis_aligned_box_min_max.html">AxisAlignedBoxMinMax</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An AABB with a min-max representation. <a href="classpvr_1_1math_1_1_axis_aligned_box_min_max.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpvr_1_1math_1_1_frustum.html">Frustum</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class provides functionality to handle the volume enclosed by 6 planes, normally the viewing frustum. The planes are represented in Hessian Normal Form (normal, distance) as vec4( (xyz):[normal], w:[distance from 0,0,0] ) <a href="structpvr_1_1math_1_1_frustum.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpvr_1_1math_1_1_viewing_frustum.html">ViewingFrustum</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class provides specialized functionality for when a frustum is a "normal"viewing frustum, that is, the following conditions hold (The conditions ARE NOT checked) Note: A "frustum side" of a plane means "the
quadrilateral of the plane that is enclosed by the 4 other planes not opposite to it" "Opposite" means the "other" side of the frustum (minusX is opposit plusX). 1) Opposite <a class="el" href="structpvr_1_1math_1_1_frustum.html" title="This class provides functionality to handle the volume enclosed by 6 planes, normally the viewing fru...">Frustum</a> sides do not intersect (their planes may do so outside the frustum) 2) The frustum is "opening", or at least not "closing" accross the z axis accross all directions, meaning that the any point of the projection of the negative Z side of the frustum on the positive Z plane, is inside or on the positive Z side of the frustum. 3) Any point of a positive(negative) part of the frustum has a larger(smaller) corresponding coordinate than its opposite part 4) All plane normals point INTO of the frustum These optimizations allow us to greatly reduce the calculations for a viewing frustum. <a href="structpvr_1_1math_1_1_viewing_frustum.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a45d744e73481d0d55e1ef85e352b9c80"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr_1_1math.html#a45d744e73481d0d55e1ef85e352b9c80">aabbInFrustum</a> (const <a class="el" href="classpvr_1_1math_1_1_axis_aligned_box.html">AxisAlignedBox</a> &amp;box, const <a class="el" href="structpvr_1_1math_1_1_viewing_frustum.html">ViewingFrustum</a> &amp;frustum)</td></tr>
<tr class="memdesc:a45d744e73481d0d55e1ef85e352b9c80"><td class="mdescLeft">&#160;</td><td class="mdescRight">Test if an AABB intersects or is inside a frustum. <a href="#a45d744e73481d0d55e1ef85e352b9c80">More...</a><br/></td></tr>
<tr class="separator:a45d744e73481d0d55e1ef85e352b9c80"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adcced29724690d4e9cd70127c66e1416"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr_1_1math.html#adcced29724690d4e9cd70127c66e1416">adjustOffsetsAndWeightsForLinearSampling</a> (const uint32_t halfCoefficientsMinusOne, std::vector&lt; double &gt; &amp;weights, std::vector&lt; double &gt; &amp;offsets)</td></tr>
<tr class="memdesc:adcced29724690d4e9cd70127c66e1416"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adjust a given set of Gaussian weights and offset to be "linearly samplable" meaning we can achieve the same Gaussian Blur using fewer texture samples using Linear Sampling than would be required if not using Linear Sampling when sampling using the offsets <a href="#adcced29724690d4e9cd70127c66e1416">More...</a><br/></td></tr>
<tr class="separator:adcced29724690d4e9cd70127c66e1416"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a77aed46cf0daa8e155a0ae37887a4caa"><td class="memItemLeft" align="right" valign="top">glm::mat4&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr_1_1math.html#a77aed46cf0daa8e155a0ae37887a4caa">constructSRT</a> (const glm::vec3 &amp;scale, const glm::quat &amp;rotate, const glm::vec3 &amp;translation)</td></tr>
<tr class="memdesc:a77aed46cf0daa8e155a0ae37887a4caa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a scale rotate translation matrix. <a href="#a77aed46cf0daa8e155a0ae37887a4caa">More...</a><br/></td></tr>
<tr class="separator:a77aed46cf0daa8e155a0ae37887a4caa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a604fa4c3a5bcbcdd7ea87858b235e780"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr_1_1math.html#a604fa4c3a5bcbcdd7ea87858b235e780">distancePointToPlane</a> (const glm::vec3 &amp;point, const glm::vec4 &amp;plane)</td></tr>
<tr class="memdesc:a604fa4c3a5bcbcdd7ea87858b235e780"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate the signed (in regards to the plane's normal) distance from a point to a plane <a href="#a604fa4c3a5bcbcdd7ea87858b235e780">More...</a><br/></td></tr>
<tr class="separator:a604fa4c3a5bcbcdd7ea87858b235e780"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af2d743f7b77ed1970b8cce4720329c1d"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:af2d743f7b77ed1970b8cce4720329c1d"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacepvr_1_1math.html#af2d743f7b77ed1970b8cce4720329c1d">gcd</a> (T lhs, T rhs)</td></tr>
<tr class="memdesc:af2d743f7b77ed1970b8cce4720329c1d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate the Greatest Common Divisor of two numbers (the larger number that, if used to divide either value, has a remainder of zero. Order is irrelevant <a href="#af2d743f7b77ed1970b8cce4720329c1d">More...</a><br/></td></tr>
<tr class="separator:af2d743f7b77ed1970b8cce4720329c1d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a85a543782c65e440fd7b13612a9e6b80"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr_1_1math.html#a85a543782c65e440fd7b13612a9e6b80">generateGaussianKernelWeightsAndOffsets</a> (uint32_t kernelSize, bool truncateCoefficients, bool useLinearSamplerOptimization, std::vector&lt; double &gt; &amp;weights, std::vector&lt; double &gt; &amp;offsets, float minimumAcceptableCoefficient=0.0001f)</td></tr>
<tr class="memdesc:a85a543782c65e440fd7b13612a9e6b80"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generates a set of Gaussian weights and offsets based on the given configuration values. This function makes use of the Pascal Triangle for calculating the Gaussian distribution. The Gaussian function is a distribution function of the normal distribution who's discrete equivalent is the binomial distribution for which the Pascal Triangle models. The Pascal Triangle provides us with a convenient and efficient mechanism for calculating the Gaussian weights and offsets required. Our method of generating Gaussian weights and offsets was inspired by <a href="http://rastergrid.com/blog/2010/09/efficient-gaussian-blur-with-linear-sampling/">http://rastergrid.com/blog/2010/09/efficient-gaussian-blur-with-linear-sampling/</a> . <a href="#a85a543782c65e440fd7b13612a9e6b80">More...</a><br/></td></tr>
<tr class="separator:a85a543782c65e440fd7b13612a9e6b80"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6375e3f769eabe69aca533d5fd20f1c2"><td class="memItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr_1_1math.html#a6375e3f769eabe69aca533d5fd20f1c2">generatePascalTriangleRow</a> (const uint32_t row, std::vector&lt; uint64_t &gt; &amp;pascalCoefficients)</td></tr>
<tr class="memdesc:a6375e3f769eabe69aca533d5fd20f1c2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate the Pascal Triangle row for the given row and store and return its pascal triangle coefficinets along with the sum of the coefficients for the given row. <a href="#a6375e3f769eabe69aca533d5fd20f1c2">More...</a><br/></td></tr>
<tr class="separator:a6375e3f769eabe69aca533d5fd20f1c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc0e2a5fcfe563de724d8f73a02e3511"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr_1_1math.html#adc0e2a5fcfe563de724d8f73a02e3511">getFrustumPlanes</a> (<a class="el" href="namespacepvr.html#a74c5d1afa51512f076dd8e5844b171c8">pvr::Api</a> api, const glm::mat4 &amp;projection_from_world, <a class="el" href="structpvr_1_1math_1_1_viewing_frustum.html">ViewingFrustum</a> &amp;frustum_out)</td></tr>
<tr class="memdesc:adc0e2a5fcfe563de724d8f73a02e3511"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve the viewing frustum from a projection matrix <a href="#adc0e2a5fcfe563de724d8f73a02e3511">More...</a><br/></td></tr>
<tr class="separator:adc0e2a5fcfe563de724d8f73a02e3511"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a914dd4e1d9df5dee40d9b2d0fc2d95cf"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr_1_1math.html#a914dd4e1d9df5dee40d9b2d0fc2d95cf">getFrustumPoints</a> (<a class="el" href="structpvr_1_1math_1_1_viewing_frustum.html">ViewingFrustum</a> &amp;frustum_out)</td></tr>
<tr class="memdesc:a914dd4e1d9df5dee40d9b2d0fc2d95cf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve the points of a viewing frustum by intersecting planes <a href="#a914dd4e1d9df5dee40d9b2d0fc2d95cf">More...</a><br/></td></tr>
<tr class="separator:a914dd4e1d9df5dee40d9b2d0fc2d95cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9529225771db0ee761416d8932797b78"><td class="memTemplParams" colspan="2">template&lt;typename Vec2 &gt; </td></tr>
<tr class="memitem:a9529225771db0ee761416d8932797b78"><td class="memTemplItemLeft" align="right" valign="top">Vec2&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacepvr_1_1math.html#a9529225771db0ee761416d8932797b78">getPerpendicular</a> (Vec2 const &amp;aVector)</td></tr>
<tr class="memdesc:a9529225771db0ee761416d8932797b78"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a vector that is perpendicular to another vector <a href="#a9529225771db0ee761416d8932797b78">More...</a><br/></td></tr>
<tr class="separator:a9529225771db0ee761416d8932797b78"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d618e96c7e3333051f2fd4496122a40"><td class="memTemplParams" colspan="2">template&lt;typename genType &gt; </td></tr>
<tr class="memitem:a9d618e96c7e3333051f2fd4496122a40"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacepvr_1_1math.html#a9d618e96c7e3333051f2fd4496122a40">intersectLinePlane</a> (genType const &amp;origin, genType const &amp;dir, genType const &amp;planeOrigin, genType const &amp;planeNormal, typename genType::value_type &amp;intersectionDistance, typename genType::value_type <a class="el" href="_t_p_s_camera_8h.html#a06b50f1ca7258a9862c39d3ed354bf7c">epsilon</a>=std::numeric_limits&lt; typename genType::value_type &gt;::<a class="el" href="_t_p_s_camera_8h.html#a06b50f1ca7258a9862c39d3ed354bf7c">epsilon</a>())</td></tr>
<tr class="memdesc:a9d618e96c7e3333051f2fd4496122a40"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs line -to - plane intersection <a href="#a9d618e96c7e3333051f2fd4496122a40">More...</a><br/></td></tr>
<tr class="separator:a9d618e96c7e3333051f2fd4496122a40"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0925f773288e6778be0ebc6485c42414"><td class="memItemLeft" align="right" valign="top">glm::vec3&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr_1_1math.html#a0925f773288e6778be0ebc6485c42414">IntersectPlanes</a> (glm::vec4 p0, glm::vec4 p1, glm::vec4 p2)</td></tr>
<tr class="memdesc:a0925f773288e6778be0ebc6485c42414"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves the point at which 3 planes intersect <a href="#a0925f773288e6778be0ebc6485c42414">More...</a><br/></td></tr>
<tr class="separator:a0925f773288e6778be0ebc6485c42414"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:accd0426359027cb0b7266a8ae9fcc077"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:accd0426359027cb0b7266a8ae9fcc077"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacepvr_1_1math.html#accd0426359027cb0b7266a8ae9fcc077">lcm</a> (T lhs, T rhs)</td></tr>
<tr class="memdesc:accd0426359027cb0b7266a8ae9fcc077"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate the Least Common Multiple of two numbers (the smaller integer that is a factor of both numbers). Order is irrelevant. If either of the numbers is 0, will return 0 <a href="#accd0426359027cb0b7266a8ae9fcc077">More...</a><br/></td></tr>
<tr class="separator:accd0426359027cb0b7266a8ae9fcc077"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af05f0c9d9f306695f2efc3483c6ed4b3"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:af05f0c9d9f306695f2efc3483c6ed4b3"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacepvr_1_1math.html#af05f0c9d9f306695f2efc3483c6ed4b3">lcm_with_max</a> (T lhs, T rhs)</td></tr>
<tr class="memdesc:af05f0c9d9f306695f2efc3483c6ed4b3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate the Least Common Multiple of two numbers (the smaller integer that is a multiple of both numbers), but discards 0: If either number is 0, will return the other number <a href="#af05f0c9d9f306695f2efc3483c6ed4b3">More...</a><br/></td></tr>
<tr class="separator:af05f0c9d9f306695f2efc3483c6ed4b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa79fff0c4934d5ab39edb53695ee3d4"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr_1_1math.html#afa79fff0c4934d5ab39edb53695ee3d4">makePowerOfTwoHigh</a> (int32_t iVal)</td></tr>
<tr class="memdesc:afa79fff0c4934d5ab39edb53695ee3d4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the smallest power of two that is greater than or equal to the provided value. <a href="#afa79fff0c4934d5ab39edb53695ee3d4">More...</a><br/></td></tr>
<tr class="separator:afa79fff0c4934d5ab39edb53695ee3d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb17baa9649bd59237e2e04eb588c5fb"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr_1_1math.html#aeb17baa9649bd59237e2e04eb588c5fb">makePowerOfTwoLow</a> (int32_t iVal)</td></tr>
<tr class="memdesc:aeb17baa9649bd59237e2e04eb588c5fb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the smallest power of two that is less than or equal to the provided value. <a href="#aeb17baa9649bd59237e2e04eb588c5fb">More...</a><br/></td></tr>
<tr class="separator:aeb17baa9649bd59237e2e04eb588c5fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00842f73cec1ae62bae0d93c79f5ffbb"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr_1_1math.html#a00842f73cec1ae62bae0d93c79f5ffbb">ndcToPixel</a> (float ndc, int32_t screenSize)</td></tr>
<tr class="memdesc:a00842f73cec1ae62bae0d93c79f5ffbb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a normalized device coordinate (-1..1) to a number of pixels from the start (left or top) <a href="#a00842f73cec1ae62bae0d93c79f5ffbb">More...</a><br/></td></tr>
<tr class="separator:a00842f73cec1ae62bae0d93c79f5ffbb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa8e885c1902f9999cb0cfc7a92fd5182"><td class="memItemLeft" align="right" valign="top">glm::mat4&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr_1_1math.html#aa8e885c1902f9999cb0cfc7a92fd5182">ortho</a> (<a class="el" href="namespacepvr.html#a74c5d1afa51512f076dd8e5844b171c8">Api</a> api, float left, float right, float bottom, float top, float rotate=0.0f)</td></tr>
<tr class="memdesc:aa8e885c1902f9999cb0cfc7a92fd5182"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculated an orthographic projection tilted projection matrix <a href="#aa8e885c1902f9999cb0cfc7a92fd5182">More...</a><br/></td></tr>
<tr class="separator:aa8e885c1902f9999cb0cfc7a92fd5182"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac6ebf3ef98b324b9d155b841d26e47ce"><td class="memItemLeft" align="right" valign="top">glm::mat4&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr_1_1math.html#ac6ebf3ef98b324b9d155b841d26e47ce">perspective</a> (<a class="el" href="namespacepvr.html#a74c5d1afa51512f076dd8e5844b171c8">Api</a> api, float fovy, float aspect, float near1, float far1, float rotate=.0f)</td></tr>
<tr class="memdesc:ac6ebf3ef98b324b9d155b841d26e47ce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculated a tilted perspective projection matrix <a href="#ac6ebf3ef98b324b9d155b841d26e47ce">More...</a><br/></td></tr>
<tr class="separator:ac6ebf3ef98b324b9d155b841d26e47ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b5c4ba641c13ab4011b91b6cb120354"><td class="memItemLeft" align="right" valign="top">glm::mat4&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr_1_1math.html#a8b5c4ba641c13ab4011b91b6cb120354">perspectiveFov</a> (<a class="el" href="namespacepvr.html#a74c5d1afa51512f076dd8e5844b171c8">Api</a> api, float fovy, float width, float height, float near1, float far1, float rotate=.0f)</td></tr>
<tr class="memdesc:a8b5c4ba641c13ab4011b91b6cb120354"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculated a tilted perspective projection matrix <a href="#a8b5c4ba641c13ab4011b91b6cb120354">More...</a><br/></td></tr>
<tr class="separator:a8b5c4ba641c13ab4011b91b6cb120354"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07094ae0eacdff77a4974feb63e69896"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr_1_1math.html#a07094ae0eacdff77a4974feb63e69896">pixelToNdc</a> (int32_t pixelCoord, int32_t screenSize)</td></tr>
<tr class="memdesc:a07094ae0eacdff77a4974feb63e69896"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a number of pixels (left or top) to a normalized device coordinate (-1..1) <a href="#a07094ae0eacdff77a4974feb63e69896">More...</a><br/></td></tr>
<tr class="separator:a07094ae0eacdff77a4974feb63e69896"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a76ff8b92d0032831704d3502ea7b6abd"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr_1_1math.html#a76ff8b92d0032831704d3502ea7b6abd">pointOnSide</a> (const glm::vec3 &amp;point, const glm::vec4 &amp;plane)</td></tr>
<tr class="memdesc:a76ff8b92d0032831704d3502ea7b6abd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate if the point is in the positive half-space defined by the plane (i.e. if it is lying on the same side as the normal points <a href="#a76ff8b92d0032831704d3502ea7b6abd">More...</a><br/></td></tr>
<tr class="separator:a76ff8b92d0032831704d3502ea7b6abd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a338b3dc2160224b23419ae90c52e9d6e"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr_1_1math.html#a338b3dc2160224b23419ae90c52e9d6e">quadraticEaseIn</a> (float start, float end, float factor)</td></tr>
<tr class="memdesc:a338b3dc2160224b23419ae90c52e9d6e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs quadratic interpolation between two points, beginning with a slow rate and speeding up. <a href="#a338b3dc2160224b23419ae90c52e9d6e">More...</a><br/></td></tr>
<tr class="separator:a338b3dc2160224b23419ae90c52e9d6e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a516d467fe7ff127e72f7fcfd7c68a22b"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr_1_1math.html#a516d467fe7ff127e72f7fcfd7c68a22b">quadraticEaseOut</a> (float start, float end, float factor)</td></tr>
<tr class="memdesc:a516d467fe7ff127e72f7fcfd7c68a22b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs quadratic interpolation between two points, beginning with a faster rate and slowing down. <a href="#a516d467fe7ff127e72f7fcfd7c68a22b">More...</a><br/></td></tr>
<tr class="separator:a516d467fe7ff127e72f7fcfd7c68a22b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Contains mathematical functionality and classes, such as bounding box calculations, intersections etc.</p>
</div><h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="a45d744e73481d0d55e1ef85e352b9c80"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool pvr::math::aabbInFrustum </td>
          <td>(</td>
          <td class="paramtype">const AxisAlignedBox &amp;&#160;</td>
          <td class="paramname"><em>box</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ViewingFrustum &amp;&#160;</td>
          <td class="paramname"><em>frustum</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Test if an AABB intersects or is inside a frustum.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">box</td><td>A box</td></tr>
    <tr><td class="paramname">frustum</td><td>A frustum</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>False if the AABB is completely outside the frustum, otherwise true</dd></dl>

</div>
</div>
<a class="anchor" id="adcced29724690d4e9cd70127c66e1416"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void pvr::math::adjustOffsetsAndWeightsForLinearSampling </td>
          <td>(</td>
          <td class="paramtype">const uint32_t&#160;</td>
          <td class="paramname"><em>halfCoefficientsMinusOne</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>weights</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>offsets</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Adjust a given set of Gaussian weights and offset to be "linearly samplable" meaning we can achieve the same Gaussian Blur using fewer texture samples using Linear Sampling than would be required if not using Linear Sampling when sampling using the offsets</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">halfCoefficientsMinusOne</td><td>The row of the Pascal to generate coefficients with the first row being the 0th.</td></tr>
    <tr><td class="paramname">weights</td><td>A vector containing the Gaussian weights for the given kernel size.</td></tr>
    <tr><td class="paramname">offsets</td><td>A vector containing the Gaussian offsets for the given kernel.</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a77aed46cf0daa8e155a0ae37887a4caa"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">glm::mat4 pvr::math::constructSRT </td>
          <td>(</td>
          <td class="paramtype">const glm::vec3 &amp;&#160;</td>
          <td class="paramname"><em>scale</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const glm::quat &amp;&#160;</td>
          <td class="paramname"><em>rotate</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const glm::vec3 &amp;&#160;</td>
          <td class="paramname"><em>translation</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs a scale rotate translation matrix.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">scale</td><td>Scaling vector.</td></tr>
    <tr><td class="paramname">rotate</td><td>A quaternion handling the rotation.</td></tr>
    <tr><td class="paramname">translation</td><td>The translation vector.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The resulting SRT matrix.</dd></dl>

</div>
</div>
<a class="anchor" id="a604fa4c3a5bcbcdd7ea87858b235e780"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">float pvr::math::distancePointToPlane </td>
          <td>(</td>
          <td class="paramtype">const glm::vec3 &amp;&#160;</td>
          <td class="paramname"><em>point</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const glm::vec4 &amp;&#160;</td>
          <td class="paramname"><em>plane</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculate the signed (in regards to the plane's normal) distance from a point to a plane</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">point</td><td>The point</td></tr>
    <tr><td class="paramname">plane</td><td>The plane, defined as a vector4, where (xyz: Normal, w: Distance from the origin)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The distance from the point to the plane (along the normal). Positive if on the side of the normal, otherwise false</dd></dl>

</div>
</div>
<a class="anchor" id="af2d743f7b77ed1970b8cce4720329c1d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T pvr::math::gcd </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculate the Greatest Common Divisor of two numbers (the larger number that, if used to divide either value, has a remainder of zero. Order is irrelevant</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The type of the values. Must have equality, assignment and modulo defined</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>One of the input values</td></tr>
    <tr><td class="paramname">rhs</td><td>The other input values</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The GCD. If the numbers are "coprime" (have no common divisor exept 1), the GCD is 1.</dd></dl>

</div>
</div>
<a class="anchor" id="a85a543782c65e440fd7b13612a9e6b80"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void pvr::math::generateGaussianKernelWeightsAndOffsets </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>kernelSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>truncateCoefficients</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>useLinearSamplerOptimization</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>weights</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>offsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>minimumAcceptableCoefficient</em> = <code>0.0001f</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Generates a set of Gaussian weights and offsets based on the given configuration values. This function makes use of the Pascal Triangle for calculating the Gaussian distribution. The Gaussian function is a distribution function of the normal distribution who's discrete equivalent is the binomial distribution for which the Pascal Triangle models. The Pascal Triangle provides us with a convenient and efficient mechanism for calculating the Gaussian weights and offsets required. Our method of generating Gaussian weights and offsets was inspired by <a href="http://rastergrid.com/blog/2010/09/efficient-gaussian-blur-with-linear-sampling/">http://rastergrid.com/blog/2010/09/efficient-gaussian-blur-with-linear-sampling/</a> .</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">kernelSize</td><td>The size of the kernel for which to generate Gaussian Weights and Gaussian Offsets. The size of the kernel is used to select the starting row of the Pascal Triangle.</td></tr>
    <tr><td class="paramname">truncateCoefficients</td><td>Can be used in combination with "minimumAcceptableCoefficient" to ignore coefficients from the Pascal Triangle which are smaller than the given value and are therefore deemed to be negligible. If the starting row is found to have too few coefficients than are required for the kernel size then the next row of the Pascal Triangle will be scanned for a list of coefficients deemed to be non-negligible and so on.</td></tr>
    <tr><td class="paramname">useLinearSamplerOptimization</td><td>Specifies that the Gaussian Weights and Offsets returned will be modified prior to being returned so that they take advantage of Linear <a class="el" href="classpvr_1_1_texture.html" title="A 2D Texture asset, together with Information, Metadata and actual Pixel data. Only represents the ac...">Texture</a> Sampling which can provide a simple means of reducing the number of texture samples.</td></tr>
    <tr><td class="paramname">weights</td><td>The returned by reference list of Gaussian Weights calculated using the Pascal Triangle.</td></tr>
    <tr><td class="paramname">offsets</td><td>The returned by reference list of Gaussian Offsets calculated using the Pascal Triangle.</td></tr>
    <tr><td class="paramname">minimumAcceptableCoefficient</td><td>Only used when ignoreNegligibleCoefficients is true and specifies the minimum coefficient value which is deemed to be non-negligible and therefore can be used as one of the returned weights. If a row does not contain enough coefficients deemed to be non-negligible then the next row will be checked for values greater than the specified minimum acceptable coefficient. Take care when specifying larger values for the minimum acceptable coefficient along with larger kernel sizes as you can run out of available precision quite quickly.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the sum of the coefficients for the given row of the Pascal Triangle.</dd></dl>

</div>
</div>
<a class="anchor" id="a6375e3f769eabe69aca533d5fd20f1c2"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t pvr::math::generatePascalTriangleRow </td>
          <td>(</td>
          <td class="paramtype">const uint32_t&#160;</td>
          <td class="paramname"><em>row</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; uint64_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>pascalCoefficients</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Generate the Pascal Triangle row for the given row and store and return its pascal triangle coefficinets along with the sum of the coefficients for the given row.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">row</td><td>The row of the Pascal to generate coefficients with the first row being the 0th.</td></tr>
    <tr><td class="paramname">pascalCoefficients</td><td>An empty vector capable of storing the pascal coefficients for the given row of the Pascal Triangle.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the sum of the coefficients for the given row of the Pascal Triangle.</dd></dl>

</div>
</div>
<a class="anchor" id="adc0e2a5fcfe563de724d8f73a02e3511"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void pvr::math::getFrustumPlanes </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacepvr.html#a74c5d1afa51512f076dd8e5844b171c8">pvr::Api</a>&#160;</td>
          <td class="paramname"><em>api</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const glm::mat4 &amp;&#160;</td>
          <td class="paramname"><em>projection_from_world</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ViewingFrustum &amp;&#160;</td>
          <td class="paramname"><em>frustum_out</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Retrieve the viewing frustum from a projection matrix</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">projection_from_world</td><td>The projection matrix</td></tr>
    <tr><td class="paramname">frustum_out</td><td>The viewing frustum</td></tr>
    <tr><td class="paramname">api</td><td>The Graphics API for which to get the planes. Used to infer and use the underlying Device coordinate system.</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a914dd4e1d9df5dee40d9b2d0fc2d95cf"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void pvr::math::getFrustumPoints </td>
          <td>(</td>
          <td class="paramtype">ViewingFrustum &amp;&#160;</td>
          <td class="paramname"><em>frustum_out</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Retrieve the points of a viewing frustum by intersecting planes</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">frustum_out</td><td>The viewing frustum</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a9529225771db0ee761416d8932797b78"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Vec2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Vec2 pvr::math::getPerpendicular </td>
          <td>(</td>
          <td class="paramtype">Vec2 const &amp;&#160;</td>
          <td class="paramname"><em>aVector</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get a vector that is perpendicular to another vector</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Vec2</td><td>A vector with two components that can be accessed through .x and .y</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">aVector</td><td>A vector</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A vector that is perpendicular to <em>aVector</em> </dd></dl>

</div>
</div>
<a class="anchor" id="a9d618e96c7e3333051f2fd4496122a40"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename genType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool pvr::math::intersectLinePlane </td>
          <td>(</td>
          <td class="paramtype">genType const &amp;&#160;</td>
          <td class="paramname"><em>origin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">genType const &amp;&#160;</td>
          <td class="paramname"><em>dir</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">genType const &amp;&#160;</td>
          <td class="paramname"><em>planeOrigin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">genType const &amp;&#160;</td>
          <td class="paramname"><em>planeNormal</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename genType::value_type &amp;&#160;</td>
          <td class="paramname"><em>intersectionDistance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename genType::value_type&#160;</td>
          <td class="paramname"><em>epsilon</em> = <code>std::numeric_limits&lt;typename&#160;genType::value_type&gt;::<a class="el" href="_t_p_s_camera_8h.html#a06b50f1ca7258a9862c39d3ed354bf7c">epsilon</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Performs line -to - plane intersection</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">genType</td><td>A glm:: vector type. Otherwise, a type with the following operations defined: A typename member value_type (type of scalar), +/- (vector add/mul), / (divide by scalar), and a dot() function in either the global or glm:: namespace</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">origin</td><td>The start point of the line</td></tr>
    <tr><td class="paramname">dir</td><td>The (positive) direction of the line</td></tr>
    <tr><td class="paramname">planeOrigin</td><td>Any point on the plane</td></tr>
    <tr><td class="paramname">planeNormal</td><td>The normal of the plane</td></tr>
    <tr><td class="paramname">intersectionDistance</td><td>Output parameter: If an intersection happens, this parameter will contain the signed distance from <em>origin</em>  towards <em>dir</em>  of the intersection point.</td></tr>
    <tr><td class="paramname">epsilon</td><td>For any comparison calculations, any value smaller than that will be considered zero (otherwise, if two numbers difference is smaller than this, they are considered equal)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the line and plane intersect, otherwise false</dd></dl>

</div>
</div>
<a class="anchor" id="a0925f773288e6778be0ebc6485c42414"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">glm::vec3 pvr::math::IntersectPlanes </td>
          <td>(</td>
          <td class="paramtype">glm::vec4&#160;</td>
          <td class="paramname"><em>p0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">glm::vec4&#160;</td>
          <td class="paramname"><em>p1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">glm::vec4&#160;</td>
          <td class="paramname"><em>p2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Retrieves the point at which 3 planes intersect</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p0</td><td>Plane 0</td></tr>
    <tr><td class="paramname">p1</td><td>Plane 1</td></tr>
    <tr><td class="paramname">p2</td><td>Plane 2</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The point at which the 3 planes intersect</dd></dl>

</div>
</div>
<a class="anchor" id="accd0426359027cb0b7266a8ae9fcc077"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T pvr::math::lcm </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculate the Least Common Multiple of two numbers (the smaller integer that is a factor of both numbers). Order is irrelevant. If either of the numbers is 0, will return 0</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The type of the values. Must have equality, assignment multiplication and either modulo or a gcd function defined</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>One of the input values</td></tr>
    <tr><td class="paramname">rhs</td><td>The other input values</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The LCM. If the inputs don't have any common factors (except 1), the LCM is equal to lhs * rhs. If either input is 0, returns 0.</dd></dl>

</div>
</div>
<a class="anchor" id="af05f0c9d9f306695f2efc3483c6ed4b3"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T pvr::math::lcm_with_max </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculate the Least Common Multiple of two numbers (the smaller integer that is a multiple of both numbers), but discards 0: If either number is 0, will return the other number</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The type of the values. Must have equality, assignment multiplication and either modulo or a gcd function defined</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>One of the input values</td></tr>
    <tr><td class="paramname">rhs</td><td>The other input values</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The LCM. If the numbers don't have any common factors (except 1), the LCM is equal to lhs * rhs. If either input is 0, returns the other</dd></dl>

</div>
</div>
<a class="anchor" id="afa79fff0c4934d5ab39edb53695ee3d4"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int32_t pvr::math::makePowerOfTwoHigh </td>
          <td>(</td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>iVal</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the smallest power of two that is greater than or equal to the provided value.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">iVal</td><td>An integer value.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The smallest PoT that is greater or equal to iVal</dd></dl>

</div>
</div>
<a class="anchor" id="aeb17baa9649bd59237e2e04eb588c5fb"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int32_t pvr::math::makePowerOfTwoLow </td>
          <td>(</td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>iVal</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the smallest power of two that is less than or equal to the provided value.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">iVal</td><td>An integer value.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The smallest PoT that is less or equal to iVal</dd></dl>

</div>
</div>
<a class="anchor" id="a00842f73cec1ae62bae0d93c79f5ffbb"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int32_t pvr::math::ndcToPixel </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>ndc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>screenSize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert a normalized device coordinate (-1..1) to a number of pixels from the start (left or top)</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ndc</td><td>The normalised coordinate along the direction in question (same direction as screenSize)</td></tr>
    <tr><td class="paramname">screenSize</td><td>The size of the screen along the direction in question (same as ndc)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pixel coordinates from normalized device coordinates</dd></dl>

</div>
</div>
<a class="anchor" id="aa8e885c1902f9999cb0cfc7a92fd5182"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">glm::mat4 pvr::math::ortho </td>
          <td>(</td>
          <td class="paramtype">Api&#160;</td>
          <td class="paramname"><em>api</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>left</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>right</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>bottom</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>top</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>rotate</em> = <code>0.0f</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculated an orthographic projection tilted projection matrix</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">left</td><td>The x coordinate of the left clipping plane</td></tr>
    <tr><td class="paramname">right</td><td>The x coordinate of the right clipping plane</td></tr>
    <tr><td class="paramname">bottom</td><td>The y coordinate of the bottom clipping plane</td></tr>
    <tr><td class="paramname">top</td><td>The y coordinate of the bottom clipping plane</td></tr>
    <tr><td class="paramname">rotate</td><td>Angle of tilt (rotation around the z axis), in radians</td></tr>
    <tr><td class="paramname">api</td><td>The graphics API for which this matrix will be created. It is used for things such as the Framebuffer coordinate conventions.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An orthographic projection matrix for the specified parameters, tilted by rotate</dd></dl>

</div>
</div>
<a class="anchor" id="ac6ebf3ef98b324b9d155b841d26e47ce"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">glm::mat4 pvr::math::perspective </td>
          <td>(</td>
          <td class="paramtype">Api&#160;</td>
          <td class="paramname"><em>api</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>fovy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>aspect</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>near1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>far1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>rotate</em> = <code>.0f</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculated a tilted perspective projection matrix</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">api</td><td>The graphics API for which this matrix will be created. It is used for the Framebuffer coordinate convention.</td></tr>
    <tr><td class="paramname">fovy</td><td>The field of vision in the y axis</td></tr>
    <tr><td class="paramname">aspect</td><td>The aspect of the viewport</td></tr>
    <tr><td class="paramname">near1</td><td>The near clipping plane distance (trailing 1 to avoid win32 keyword)</td></tr>
    <tr><td class="paramname">far1</td><td>The far clipping plane distance (trailing 1 to avoid win32 keyword)</td></tr>
    <tr><td class="paramname">rotate</td><td>Angle of tilt (rotation around the z axis), in radians</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A projection matrix for the specified parameters, tilted by rotate</dd></dl>

</div>
</div>
<a class="anchor" id="a8b5c4ba641c13ab4011b91b6cb120354"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">glm::mat4 pvr::math::perspectiveFov </td>
          <td>(</td>
          <td class="paramtype">Api&#160;</td>
          <td class="paramname"><em>api</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>fovy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>width</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>height</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>near1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>far1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>rotate</em> = <code>.0f</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculated a tilted perspective projection matrix</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fovy</td><td>The field of vision in the y axis</td></tr>
    <tr><td class="paramname">width</td><td>The width of the viewport</td></tr>
    <tr><td class="paramname">height</td><td>The height of the viewport</td></tr>
    <tr><td class="paramname">near1</td><td>The near clipping plane distance</td></tr>
    <tr><td class="paramname">far1</td><td>The far clipping plane distance</td></tr>
    <tr><td class="paramname">rotate</td><td>Angle of tilt (rotation around the z axis), in radians</td></tr>
    <tr><td class="paramname">api</td><td>The graphics API for which this matrix will be created. It is used for things such as the Framebuffer coordinate conventions.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A projection matrix for the specified parameters, tilted by rotate</dd></dl>

</div>
</div>
<a class="anchor" id="a07094ae0eacdff77a4974feb63e69896"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">float pvr::math::pixelToNdc </td>
          <td>(</td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>pixelCoord</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>screenSize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert a number of pixels (left or top) to a normalized device coordinate (-1..1)</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pixelCoord</td><td>The pixel coordinate (number of pixels) along the direction in question (same direction as screenSize)</td></tr>
    <tr><td class="paramname">screenSize</td><td>The size of the screen along the direction in question (same as pixelCoord)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Normalized device coordinates (number in the 0..1 range)</dd></dl>

</div>
</div>
<a class="anchor" id="a76ff8b92d0032831704d3502ea7b6abd"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool pvr::math::pointOnSide </td>
          <td>(</td>
          <td class="paramtype">const glm::vec3 &amp;&#160;</td>
          <td class="paramname"><em>point</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const glm::vec4 &amp;&#160;</td>
          <td class="paramname"><em>plane</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculate if the point is in the positive half-space defined by the plane (i.e. if it is lying on the same side as the normal points</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">point</td><td>The point</td></tr>
    <tr><td class="paramname">plane</td><td>The plane, defined as a vector4, where (xyz: Normal, w: Distance from the origin)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the point is on the plane or on the same side as the normal, otherwise false</dd></dl>

</div>
</div>
<a class="anchor" id="a338b3dc2160224b23419ae90c52e9d6e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">float pvr::math::quadraticEaseIn </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>factor</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Performs quadratic interpolation between two points, beginning with a slow rate and speeding up.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">start</td><td>The starting point.</td></tr>
    <tr><td class="paramname">end</td><td>The end point</td></tr>
    <tr><td class="paramname">factor</td><td>Interpolation factor. At 0, returns start. At 1, returns end. Closer to 0, the rate of change is slower, closer to 1 faster.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The modified value to use, quadratically interpolated between start and end with factor factor.</dd></dl>

</div>
</div>
<a class="anchor" id="a516d467fe7ff127e72f7fcfd7c68a22b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">float pvr::math::quadraticEaseOut </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>factor</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Performs quadratic interpolation between two points, beginning with a faster rate and slowing down.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">start</td><td>The starting point.</td></tr>
    <tr><td class="paramname">end</td><td>The end point</td></tr>
    <tr><td class="paramname">factor</td><td>Current LINEAR interpolation factor, from 0..1</td></tr>
  </table>
  </dd>
</dl>
<p>0 </p>
<dl class="section return"><dt>Returns</dt><dd>For <em>factor</em> =0, returns <em>start</em> . For <em>factor</em> =1, returns <em>end</em> . Closer to 0, the rate of change is faster, closer to 1 slower.</dd></dl>

</div>
</div>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.8.4-->
<!-- start footer part (NON TREEVIEW ONLY!!) -->
<!--BEGIN GENERATE_TREEVIEW-->
<div id="FooterMainContainer">
	<div id="FooterContainer">
		<div class="footerlogo">
			<a href="http://www.imgtec.com" target="_blank"><img src="img-footer-logo-grey.png" width="100%" height="100%" border="none" /></a>
		</div>
		<div class="copyright"><p>&copy; Imagination Technologies Limited<br> All rights reserved</p></div>
	</div>
</div>
</body>
</html>
